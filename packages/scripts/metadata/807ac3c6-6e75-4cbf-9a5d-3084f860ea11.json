{
  "data": {
    "id": 1701,
    "exerciseKey": "807ac3c6-6e75-4cbf-9a5d-3084f860ea11",
    "category": "QA",
    "renderType": "md",
    "title": "JavaScript中的 sort 方法是怎么实现的？",
    "desc": null,
    "options": null,
    "explanation": "本答案将介绍js中常用的几种排序算法，并结合v8中相关源码分析sort实现的策略\n\n## 常见排序算法\n首先温习下排序算法需要关注的两大要素\n\n### 时间复杂度\n描述该算法的运行时间，通常用`大O`描述，附上一张时间复杂度曲线图帮助理解\n\n![image.png](https://static.ecool.fun//article/d64d13f8-0600-4d41-b958-cb3f0b96a9f8.jpeg)\n    \n### 空间复杂度\n度量一个算法在运行过程中占用存储空间大小\n\n### 常见排序\n常见的[十大经典排序算法](https://gitee.com/webfrontup/javascript-algorithms)就不在这科普了，根据特性可将它们从不同角度进行分类\n\n- 是否基于比较：比较类排序和非比较类排序\n\n- 是否稳定：稳定类排序和不稳定类排序\n\n通常我们`从是否基于排序`的视角进行分类\n\n- 比较类排序\n\n  通过比较来决定元素间的相对次序，其时间复杂度不能突破` O(nlogn)`，因此也称为`非线性时间比较`类排序。\n- 非比较类排序\n\n  不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以`线性时间运行`，因此也称为`线性时间非比较`类排序。\n\n具体分类枚举可以结合下图理解\n\n![image.png](https://static.ecool.fun//article/9ea8e675-8240-438a-b988-187c03dac21e.jpeg)\n\n接下来我们写下几个常见的经典排序\n\n#### 快速排序\n快速排序主要使用`递归分支`的思想，通过一趟排序，将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n```js\nvar a = [ 25, 76, 34, 232, 6, 456, 221];\nfunction quickSort(array) {\n  var quick = function(arr) {\n    if (arr.length <= 1) return arr\n    const index = Math.floor(len >> 1)\n    const pivot = arr.splice(index, 1)[0]\n    const left = []\n    const right = []\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] > pivot) {\n        right.push(arr[i])\n      } else if (arr[i] <= pivot) {\n        left.push(arr[i])\n      }\n    }\n    return quick(left).concat([pivot], quick(right))\n  }\n  const result = quick(array)\n  return result\n\n}\nquickSort(a);//  [ 6, 25, 34, 76, 221, 232, 456]\n```\n\n#### 堆排序\n堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵`完全二叉树`，可以用数组实现。\n\n根节点最大的堆叫作`大根堆`，根节点最小的堆叫作`小根堆`，你可以根据从大到小排序或者从小到大来排序，分别建立对应的堆就可以。请看下面的代码。\n\n```js\nvar a = [25, 76, 34, 232, 6, 456, 221];\nfunction heap_sort(arr) {\n  var len = arr.length\n  var k = 0\n  function swap(i, j) {\n    var temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n  }\n\n  function max_heapify(start, end) {\n    var dad = start\n    var son = dad * 2 + 1\n    if (son >= end) return\n    if (son + 1 < end && arr[son] < arr[son + 1]) {\n      son++\n    }\n    if (arr[dad] <= arr[son]) {\n      swap(dad, son)\n      max_heapify(son, end)\n    }\n  }\n  for (var i = Math.floor(len / 2) - 1; i >= 0; i--) {\n    max_heapify(i, len)\n  }\n\n  for (var j = len - 1; j > k; j--) {\n    swap(0, j)\n    max_heapify(0, j)\n  }\n  return arr\n}\n\nheap_sort(a); // [6, 25, 34, 76, 221, 232, 456]\n```\n\n#### 归并排序\n归并排序是建立在`归并`操作上的一种有效的排序算法，该算法是采用`分治法`的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为`二路归并`。\n\n```js\nvar a = [25, 76, 34, 232, 6, 456, 221];\nfunction mergeSort(array) {\n  const merge = (right, left) => {\n    const result = []\n    let il = 0\n    let ir = 0\n    while (il < left.length && ir < right.length) {\n      if (left[il] < right[ir]) {\n        result.push(left[il++])\n      } else {\n        result.push(right[ir++])\n      }\n    }\n    while (il < left.length) {\n      result.push(left[il++])\n    }\n    while (ir < right.length) {\n      result.push(right[ir++])\n    }\n    return result\n  }\n  const mergeSort = array => {\n    if (array.length === 1) { return array }\n    const mid = Math.floor(array.length / 2)\n    const left = array.slice(0, mid)\n    const right = array.slice(mid, array.length)\n    return merge(mergeSort(left), mergeSort(right))\n  }\n  return mergeSort(array)\n}\nmergeSort(a); // [6, 25, 34, 76, 221, 232, 456]\n\n```\n\n最后附上一张各排序算法统计对照表:\n\n![image.png](https://static.ecool.fun//article/139cfecc-7643-41c3-8b25-0113826c6ea6.jpeg)\n\n\n## js中的sort方法\n\n### sort方法基本使用\n\n> arr.sort([compareFunction])\n\n如果不传入 compareFunction，则元素按照转换为字符串的各个字符的 `Unicode` 位点进行排序，有些同学经常在整数排序上犯错误，多半是因为遗漏了这一规则\n\n```js\nconst names = ['tom', 'jesse', 'jack'];\nnames.sort();\n\nconsole.log(names);\n// [\"jack\", \"jesse\", \"tom\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\n\nconsole.log(array1);\n// [1, 100000, 21, 30, 4]\n```\n如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的`返回值排序`，即 a 和 b 是两个将要被比较的元素：\n- compareFunction（a, b）< 0，a 会被排列到 b 之前\n- compareFunction（a, b）=== 0，a 和 b 的相对位置不变\n- compareFunction（a, b）> 0，b 会被排列到 a 之前\n\n### sort源码分析\n查阅 [v8源码sort部分](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L709) 我们可以发现，对于需要排序的元素个数n，具体排序策略有几下中情形：\n\n- 当 n<=10 时，采用`插入排序`；\n- 当 n>10 时，采用`三路快速排序`；\n- 10<n <=1000，采用中位数作为哨兵元素；\n- n>1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。\n\n乍一看结论你可能会纠结两个问题\n\n##### 1、为何元素较少的时候要用快排\n\n其实仔细分析一下不难究其原因。对于插排和快排，理论上的平均时间复杂度分别为O(n^2)和O(nlogn)，其中插排在最好情况下的时间复杂度是 O(n)。对比不难得出结论，当n足够小的时候，快排优势变小。事实上插排经优化后对于小数据集的排序性能可以超过快排。\n\n##### 2、为何要选择哨兵元素\n\n因为快速排序的性能瓶颈在于`递归的深度`，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。如果这么排下去，递归的层数就达到了` n `, 而每一层的复杂度是` O(n)`，因此快排这时候会`退化`成` O(n^2) `级别。\n\n这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少\n\n最后我们看下源码中的sort的基本结构\n\n```js\nfunction ArraySort(comparefn) {\n    CHECK_OBJECT_COERCIBLE(this,\"Array.prototype.sort\");\n    var array = TO_OBJECT(this);\n    var length = TO_LENGTH(array.length);\n    return InnerArraySort(array, length, comparefn);\n}\nfunction InnerArraySort(array, length, comparefn) {\n// 比较函数未传入\nif (!IS_CALLABLE(comparefn)) {\n      comparefn = function (x, y) {\n        if (x === y) return 0;\n        if (%_IsSmi(x) && %_IsSmi(y)) {\n          return %SmiLexicographicCompare(x, y);\n        }\n        x = TO_STRING(x);\n        y = TO_STRING(y);\n        if (x == y) return 0;\n        else return x < y ? -1 : 1;\n   };\n}\nfunction InsertionSort(a, from, to) {\n  // 插入排序\n  for (var i = from + 1; i < to; i++) {\n        var element = a[i];\n        for (var j = i - 1; j >= from; j--) {\n          var tmp = a[j];\n          var order = comparefn(tmp, element);\n          if (order > 0) {\n            a[j + 1] = tmp;\n          } else {\n            break;\n          }\n        }\n      a[j + 1] = element;\n   }\n}\nfunction GetThirdIndex(a, from, to) {   // 元素个数大于1000时寻找哨兵元素\n  var t_array = new InternalArray();\n  var increment = 200 + ((to - from) & 15);\n  var j = 0;\n  from += 1;\n  to -= 1;\n  for (var i = from; i < to; i += increment) {\n     t_array[j] = [i, a[i]];\n     j++;\n  }\n  t_array.sort(function(a, b) {\n     return comparefn(a[1], b[1]);\n  });\n  var third_index = t_array[t_array.length >> 1][0];\n  return third_index;\n}\nfunction QuickSort(a, from, to) {  // 快速排序实现\n      //哨兵位置\n      var third_index = 0;\n      while (true) {\n        if (to - from <= 10) {\n          InsertionSort(a, from, to); // 数据量小，使用插入排序，速度较快\n          return;\n        }\n        if (to - from > 1000) {\n          third_index = GetThirdIndex(a, from, to);\n        } else {\n          // 小于1000 直接取中点\n          third_index = from + ((to - from) >> 1);\n        }\n        // 下面开始快排\n        var v0 = a[from];\n        var v1 = a[to - 1];\n        var v2 = a[third_index];\n        var c01 = comparefn(v0, v1);\n        if (c01 > 0) {\n          var tmp = v0;\n          v0 = v1;\n          v1 = tmp;\n        }\n        var c02 = comparefn(v0, v2);\n        if (c02 >= 0) {\n          var tmp = v0;\n          v0 = v2;\n          v2 = v1;\n          v1 = tmp;\n        } else {\n          var c12 = comparefn(v1, v2);\n          if (c12 > 0) {\n            var tmp = v1;\n            v1 = v2;\n            v2 = tmp;\n          }\n        }\n        a[from] = v0;\n        a[to - 1] = v2;\n        var pivot = v1;\n        var low_end = from + 1; \n        var high_start = to - 1;\n        a[third_index] = a[low_end];\n        a[low_end] = pivot;\n        partition: for (var i = low_end + 1; i < high_start; i++) {\n          var element = a[i];\n          var order = comparefn(element, pivot);\n          if (order < 0) {\n            a[i] = a[low_end];\n            a[low_end] = element;\n            low_end++;\n          } else if (order > 0) {\n            do {\n              high_start--;\n              if (high_start == i) break partition;\n              var top_elem = a[high_start];\n              order = comparefn(top_elem, pivot);\n            } while (order > 0);\n            a[i] = a[high_start];\n            a[high_start] = element;\n            if (order < 0) {\n              element = a[i];\n              a[i] = a[low_end];\n              a[low_end] = element;\n              low_end++;\n            }\n          }\n        }\n        // 快排的核心思路，递归调用快速排序方法\n        if (to - high_start < low_end - from) {\n          QuickSort(a, high_start, to);\n          to = low_end;\n        } else {\n          QuickSort(a, from, low_end);\n          from = high_start;\n        }\n    }\n  }\n```\n\n\n\n\n\n\n\n\n\n",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2022-03-20T12:57:50.000Z",
    "updateAt": "2024-01-25T19:37:06.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 44,
    "prev": "33c7d09a-4394-480b-a513-85bb834cbeff",
    "next": "4fae3374-d530-49b9-b626-c176eb5ee22b"
  },
  "post": {
    "exerciseKey": "807ac3c6-6e75-4cbf-9a5d-3084f860ea11",
    "category": "QA",
    "title": "JavaScript中的 sort 方法是怎么实现的？",
    "level": 3.5,
    "updateAt": "2024-01-25T19:37:06+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}
