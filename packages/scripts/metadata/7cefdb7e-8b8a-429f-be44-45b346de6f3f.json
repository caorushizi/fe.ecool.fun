{
  "data": {
    "id": 240,
    "exerciseKey": "7cefdb7e-8b8a-429f-be44-45b346de6f3f",
    "category": "QA",
    "renderType": "md",
    "title": "说说你对Vue中 keep-alive 的理解",
    "desc": null,
    "options": null,
    "explanation": "## 一、Keep-alive 是什么\n\n`keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM`\n\n`keep-alive` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们\n\n`keep-alive`可以设置以下`props`属性：\n\n- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存\n- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存\n- `max` - 数字。最多可以缓存多少组件实例\n\n关于`keep-alive`的基本用法：\n\n```js\n<keep-alive>\n  <component :is=\"view\"></component>\n</keep-alive>\n```\n\n使用`includes`和`exclude`：\n\n```js\n<keep-alive include=\"a,b\">\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 正则表达式 (使用 `v-bind`) -->\n<keep-alive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 数组 (使用 `v-bind`) -->\n<keep-alive :include=\"['a', 'b']\">\n  <component :is=\"view\"></component>\n</keep-alive>\n```\n\n匹配首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)，匿名组件不能被匹配\n\n设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：\n\n- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`\n\n- 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`\n\n## 二、使用场景\n\n使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用`keepalive`\n\n举个栗子:\n\n当我们从`首页`–>`列表页`–>`商详页`–>`再返回`，这时候列表页应该是需要`keep-alive`\n\n从`首页`–>`列表页`–>`商详页`–>`返回到列表页(需要缓存)`–>`返回到首页(需要缓存)`–>`再次进入列表页(不需要缓存)`，这时候可以按需来控制页面的`keep-alive`\n\n在路由中设置`keepAlive`属性判断是否需要缓存\n\n```js\n{\n  path: 'list',\n  name: 'itemList', // 列表页\n  component (resolve) {\n    require(['@/pages/item/list'], resolve)\n },\n meta: {\n  keepAlive: true,\n  title: '列表页'\n }\n}\n```\n\n使用`<keep-alive>`\n\n```js\n<div id=\"app\" class='wrapper'>\n    <keep-alive>\n        <!-- 需要缓存的视图组件 --> \n        <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n     </keep-alive>\n      <!-- 不需要缓存的视图组件 -->\n     <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n</div>\n```\n\n\n## 三、原理分析\n\n`keep-alive`是`vue`中内置的一个组件\n\n源码位置：src/core/components/keep-alive.js\n\n```js\nexport default {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n\n  created () {\n    this.cache = Object.create(null)\n    this.keys = []\n  },\n\n  destroyed () {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted () {\n    this.$watch('include', val => {\n      pruneCache(this, name => matches(val, name))\n    })\n    this.$watch('exclude', val => {\n      pruneCache(this, name => !matches(val, name))\n    })\n  },\n\n  render() {\n    /* 获取默认插槽中的第一个组件节点 */\n    const slot = this.$slots.default\n    const vnode = getFirstComponentChild(slot)\n    /* 获取该组件节点的componentOptions */\n    const componentOptions = vnode && vnode.componentOptions\n\n    if (componentOptions) {\n      /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */\n      const name = getComponentName(componentOptions)\n\n      const { include, exclude } = this\n      /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */\n      if (\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      const { cache, keys } = this\n      /* 获取组件的key值 */\n      const key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n        : vnode.key\n     /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance\n        // make current key freshest\n        remove(keys, key)\n        keys.push(key)\n      }\n        /* 如果没有命中缓存，则将其设置进缓存 */\n        else {\n        cache[key] = vnode\n        keys.push(key)\n        // prune oldest entry\n        /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\n        }\n      }\n\n      vnode.data.keepAlive = true\n    }\n    return vnode || (slot && slot[0])\n  }\n}\n```\n\n可以看到该组件没有`template`，而是用了`render`，在组件渲染的时候会自动执行`render`函数\n\n`this.cache`是一个对象，用来存储需要缓存的组件，它将以如下形式存储：\n\n```js\nthis.cache = {\n    'key1':'组件1',\n    'key2':'组件2',\n    // ...\n}\n```\n\n在组件销毁的时候执行`pruneCacheEntry`函数\n\n```js\nfunction pruneCacheEntry (\n  cache: VNodeCache,\n  key: string,\n  keys: Array<string>,\n  current?: VNode\n) {\n  const cached = cache[key]\n  /* 判断当前没有处于被渲染状态的组件，将其销毁*/\n  if (cached && (!current || cached.tag !== current.tag)) {\n    cached.componentInstance.$destroy()\n  }\n  cache[key] = null\n  remove(keys, key)\n}\n```\n\n在`mounted`钩子函数中观测 `include` 和 `exclude` 的变化，如下：\n\n```javascript\nmounted () {\n    this.$watch('include', val => {\n        pruneCache(this, name => matches(val, name))\n    })\n    this.$watch('exclude', val => {\n        pruneCache(this, name => !matches(val, name))\n    })\n}\n```\n\n如果`include` 或`exclude` 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行`pruneCache`函数，函数如下：\n\n```javascript\nfunction pruneCache (keepAliveInstance, filter) {\n  const { cache, keys, _vnode } = keepAliveInstance\n  for (const key in cache) {\n    const cachedNode = cache[key]\n    if (cachedNode) {\n      const name = getComponentName(cachedNode.componentOptions)\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode)\n      }\n    }\n  }\n}\n```\n\n在该函数内对`this.cache`对象进行遍历，取出每一项的`name`值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用`pruneCacheEntry`函数将其从`this.cache`对象剔除即可\n\n关于`keep-alive`的最强大缓存功能是在`render`函数中实现\n\n首先获取组件的`key`值：\n\n```javascript\nconst key = vnode.key == null? \ncomponentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n: vnode.key\n```\n\n拿到`key`值后去`this.cache`对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：\n\n```javascript\n/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */\nif (cache[key]) {\n    vnode.componentInstance = cache[key].componentInstance\n    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */\n    remove(keys, key)\n    keys.push(key)\n} \n```\n\n直接从缓存中拿 `vnode` 的组件实例，此时重新调整该组件`key`的顺序，将其从原来的地方删掉并重新放在`this.keys`中最后一个\n\n`this.cache`对象中没有该`key`值的情况，如下：\n\n```javascript\n/* 如果没有命中缓存，则将其设置进缓存 */\nelse {\n    cache[key] = vnode\n    keys.push(key)\n    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */\n    if (this.max && keys.length > parseInt(this.max)) {\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\n    }\n}\n```\n\n表明该组件还没有被缓存过，则以该组件的`key`为键，组件`vnode`为值，将其存入`this.cache`中，并且把`key`存入`this.keys`中\n\n此时再判断`this.keys`中缓存组件的数量是否超过了设置的最大缓存数量值`this.max`，如果超过了，则把第一个缓存组件删掉\n\n\n\n## 四、思考题：缓存后如何获取数据\n\n解决方案可以有以下两种：\n\n- beforeRouteEnter\n- actived\n\n### beforeRouteEnter\n\n每次组件渲染的时候，都会执行`beforeRouteEnter`\n\n```js\nbeforeRouteEnter(to, from, next){\n    next(vm=>{\n        console.log(vm)\n        // 每次进入路由执行\n        vm.getData()  // 获取数据\n    })\n},\n```\n\n### actived\n\n在`keep-alive`缓存的组件被激活的时候，都会执行`actived`钩子\n\n```js\nactivated(){\n\t  this.getData() // 获取数据\n},\n```\n\n注意：服务器端渲染期间`avtived`不被调用\n\n",
    "level": 3,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-04T03:41:35.000Z",
    "updateAt": "2024-01-25T14:36:31.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 130,
    "prev": "d5acd6cf-38c3-4afb-965d-be79f03cd045",
    "next": "adaa5c02-f04c-4247-b6d6-0fe3f1bd439c"
  },
  "post": {
    "exerciseKey": "7cefdb7e-8b8a-429f-be44-45b346de6f3f",
    "category": "QA",
    "title": "说说你对Vue中 keep-alive 的理解",
    "level": 3,
    "updateAt": "2024-01-25T14:36:31+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 68
  }
}
