{
  "data": {
    "id": 247,
    "exerciseKey": "605ec5f7-3768-4aa4-8cdc-3b5bd90bebc3",
    "category": "QA",
    "renderType": "md",
    "title": "Axios的原理是什么？",
    "desc": null,
    "options": null,
    "explanation": "## 一、axios的使用\n\n关于`axios`的基本使用，上篇文章已经有所涉及，这里再稍微回顾下：\n\n**发送请求**\n\n```js\nimport axios from 'axios';\n\naxios(config) // 直接传入配置\naxios(url[, config]) // 传入url和配置\naxios[method](url[, option]) // 直接调用请求方式方法，传入url和配置\naxios[method](url[, data[, option]]) // 直接调用请求方式方法，传入data、url和配置\naxios.request(option) // 调用 request 方法\n\nconst axiosInstance = axios.create(config)\n// axiosInstance 也具有以上 axios 的能力\n\naxios.all([axiosInstance1, axiosInstance2]).then(axios.spread(response1, response2))\n// 调用 all 和传入 spread 回调\n\n```\n\n\n\n**请求拦截器**\n\n```js\naxios.interceptors.request.use(function (config) {\n    // 这里写发送请求前处理的代码\n    return config;\n}, function (error) {\n    // 这里写发送请求错误相关的代码\n    return Promise.reject(error);\n});\n```\n\n\n\n**响应拦截器**\n\n```js\naxios.interceptors.response.use(function (response) {\n    // 这里写得到响应数据后处理的代码\n    return response;\n}, function (error) {\n    // 这里写得到错误响应处理的代码\n    return Promise.reject(error);\n});\n```\n\n\n\n**取消请求**\n\n```js\n// 方式一\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('xxxx', {\n  cancelToken: source.token\n})\n// 取消请求 (请求原因是可选的)\nsource.cancel('主动取消请求');\n\n// 方式二\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('xxxx', {\n  cancelToken: new CancelToken(function executor(c) {\n    cancel = c;\n  })\n});\ncancel('主动取消请求');\n```\n\n\n\n\n\n## 二、实现一个简易版axios\n\n构建一个`Axios`构造函数，核心代码为`request`\n\n```js\nclass Axios {\n    constructor() {\n\n    }\n\n    request(config) {\n        return new Promise(resolve => {\n            const {url = '', method = 'get', data = {}} = config;\n            // 发送ajax请求\n            const xhr = new XMLHttpRequest();\n            xhr.open(method, url, true);\n            xhr.onload = function() {\n                console.log(xhr.responseText)\n                resolve(xhr.responseText);\n            }\n            xhr.send(data);\n        })\n    }\n}\n```\n\n导出`axios`实例\n\n```js\n// 最终导出axios的方法，即实例的request方法\nfunction CreateAxiosFn() {\n    let axios = new Axios();\n    let req = axios.request.bind(axios);\n    return req;\n}\n\n// 得到最后的全局变量axios\nlet axios = CreateAxiosFn();\n```\n\n上述就已经能够实现`axios({ })`这种方式的请求\n\n下面是来实现下`axios.method()`这种形式的请求\n\n```js\n// 定义get,post...方法，挂在到Axios原型上\nconst methodsArr = ['get', 'delete', 'head', 'options', 'put', 'patch', 'post'];\nmethodsArr.forEach(met => {\n    Axios.prototype[met] = function() {\n        console.log('执行'+met+'方法');\n        // 处理单个方法\n        if (['get', 'delete', 'head', 'options'].includes(met)) { // 2个参数(url[, config])\n            return this.request({\n                method: met,\n                url: arguments[0],\n                ...arguments[1] || {}\n            })\n        } else { // 3个参数(url[,data[,config]])\n            return this.request({\n                method: met,\n                url: arguments[0],\n                data: arguments[1] || {},\n                ...arguments[2] || {}\n            })\n        }\n\n    }\n})\n```\n\n将`Axios.prototype`上的方法搬运到`request`上\n\n首先实现个工具类，实现将`b`方法混入到`a`，并且修改`this`指向\n\n```js\nconst utils = {\n  extend(a,b, context) {\n    for(let key in b) {\n      if (b.hasOwnProperty(key)) {\n        if (typeof b[key] === 'function') {\n          a[key] = b[key].bind(context);\n        } else {\n          a[key] = b[key]\n        }\n      }\n      \n    }\n  }\n}\n```\n\n修改导出的方法\n\n```js\nfunction CreateAxiosFn() {\n  let axios = new Axios();\n  \n  let req = axios.request.bind(axios);\n  // 增加代码\n  utils.extend(req, Axios.prototype, axios)\n  \n  return req;\n}\n```\n\n\n\n构建拦截器的构造函数\n\n```js\nclass InterceptorsManage {\n  constructor() {\n    this.handlers = [];\n  }\n\n  use(fullfield, rejected) {\n    this.handlers.push({\n      fullfield,\n      rejected\n    })\n  }\n}\n```\n\n实现`axios.interceptors.response.use`和`axios.interceptors.request.use`\n\n```js\nclass Axios {\n    constructor() {\n        // 新增代码\n        this.interceptors = {\n            request: new InterceptorsManage,\n            response: new InterceptorsManage\n        }\n    }\n\n    request(config) {\n \t\t...\n    }\n}\n```\n\n执行语句`axios.interceptors.response.use`和`axios.interceptors.request.use`的时候，实现获取`axios`实例上的`interceptors`对象，然后再获取`response`或`request`拦截器，再执行对应的拦截器的`use`方法\n\n把`Axios`上的方法和属性搬到`request`过去\n\n```js\nfunction CreateAxiosFn() {\n  let axios = new Axios();\n  \n  let req = axios.request.bind(axios);\n  // 混入方法， 处理axios的request方法，使之拥有get,post...方法\n  utils.extend(req, Axios.prototype, axios)\n  // 新增代码\n  utils.extend(req, axios)\n  return req;\n}\n```\n\n现在`request`也有了`interceptors`对象，在发送请求的时候，会先获取`request`拦截器的`handlers`的方法来执行\n\n首先将执行`ajax`的请求封装成一个方法\n\n```js\nrequest(config) {\n    this.sendAjax(config)\n}\nsendAjax(config){\n    return new Promise(resolve => {\n        const {url = '', method = 'get', data = {}} = config;\n        // 发送ajax请求\n        console.log(config);\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        xhr.onload = function() {\n            console.log(xhr.responseText)\n            resolve(xhr.responseText);\n        };\n        xhr.send(data);\n    })\n}\n```\n\n获得`handlers`中的回调\n\n```js\nrequest(config) {\n    // 拦截器和请求组装队列\n    let chain = [this.sendAjax.bind(this), undefined] // 成对出现的，失败回调暂时不处理\n\n    // 请求拦截\n    this.interceptors.request.handlers.forEach(interceptor => {\n        chain.unshift(interceptor.fullfield, interceptor.rejected)\n    })\n\n    // 响应拦截\n    this.interceptors.response.handlers.forEach(interceptor => {\n        chain.push(interceptor.fullfield, interceptor.rejected)\n    })\n\n    // 执行队列，每次执行一对，并给promise赋最新的值\n    let promise = Promise.resolve(config);\n    while(chain.length > 0) {\n        promise = promise.then(chain.shift(), chain.shift())\n    }\n    return promise;\n}\n```\n\n`chains`大概是`['fulfilled1','reject1','fulfilled2','reject2','this.sendAjax','undefined','fulfilled2','reject2','fulfilled1','reject1']`这种形式\n\n这样就能够成功实现一个简易版`axios`\n\n\n\n## 三、源码分析\n\n首先看看目录结构\n\n ![](https://static.ecool.fun//article/aa354d57-bb09-40c5-ba3e-cc5680443a28.png)\n\n\n\n`axios`发送请求有很多实现的方法，实现入口文件为`axios.js `\n\n```js\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n\n  // instance指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用 \n  // Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用\n  var instance = bind(Axios.prototype.request, context);\n\n  // 把Axios.prototype上的方法扩展到instance对象上，\n  // 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  // 把context对象上的自身属性和方法扩展到instance上\n  // 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性\n  // 这样，instance 就有了  defaults、interceptors 属性。\n  utils.extend(instance, context);\n  return instance;\n}\n\n// Create the default instance to be exported 创建一个由默认配置生成的axios实例\nvar axios = createInstance(defaults);\n\n// Factory for creating new instances 扩展axios.create工厂函数，内部也是 createInstance\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\nmodule.exports = axios;\n```\n\n主要核心是 `Axios.prototype.request`，各种请求方式的调用实现都是在 `request` 内部实现的， 简单看下 `request` 的逻辑\n\n```js\nAxios.prototype.request = function request(config) {\n  // Allow for axios('example/url'[, config]) a la fetch API\n  // 判断 config 参数是否是 字符串，如果是则认为第一个参数是 URL，第二个参数是真正的config\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    // 把 url 放置到 config 对象中，便于之后的 mergeConfig\n    config.url = arguments[0];\n  } else {\n    // 如果 config 参数是否是 字符串，则整体都当做config\n    config = config || {};\n  }\n  // 合并默认配置和传入的配置\n  config = mergeConfig(this.defaults, config);\n  // 设置请求方法\n  config.method = config.method ? config.method.toLowerCase() : 'get';\n  /*\n    something... 此部分会在后续拦截器单独讲述\n  */\n};\n\n// 在 Axios 原型上挂载 'delete', 'get', 'head', 'options' 且不传参的请求方法，实现内部也是 request\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\n// 在 Axios 原型上挂载 'post', 'put', 'patch' 且传参的请求方法，实现内部同样也是 request\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n```\n\n`request`入口参数为`config`，可以说`config`贯彻了`axios`的一生\n\n`axios` 中的 `config `主要分布在这几个地方：\n\n- 默认配置 `defaults.js`\n- `config.method`默认为 `get`\n- 调用 `createInstance` 方法创建 `axios `实例，传入的`config`\n- 直接或间接调用 `request` 方法，传入的 `config`\n\n```js\n// axios.js\n// 创建一个由默认配置生成的axios实例\nvar axios = createInstance(defaults);\n\n// 扩展axios.create工厂函数，内部也是 createInstance\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Axios.js\n// 合并默认配置和传入的配置\nconfig = mergeConfig(this.defaults, config);\n// 设置请求方法\nconfig.method = config.method ? config.method.toLowerCase() : 'get';\n\n```\n\n从源码中，可以看到优先级：默认配置对象`default` < `method:get` < `Axios`的实例属性`this.default` < `request`参数\n\n下面重点看看`request`方法\n\n```js\nAxios.prototype.request = function request(config) {\n  /*\n    先是 mergeConfig ... 等，不再阐述\n  */\n  // Hook up interceptors middleware 创建拦截器链. dispatchRequest 是重中之重，后续重点\n  var chain = [dispatchRequest, undefined];\n\n  // push各个拦截器方法 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    // 请求拦截器逆序 注意此处的 forEach 是自定义的拦截器的forEach方法\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    // 响应拦截器顺序 注意此处的 forEach 是自定义的拦截器的forEach方法\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  // 初始化一个promise对象，状态为resolved，接收到的参数为已经处理合并过的config对象\n  var promise = Promise.resolve(config);\n\n  // 循环拦截器的链\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift()); // 每一次向外弹出拦截器\n  }\n  // 返回 promise\n  return promise;\n};\n```\n\n拦截器`interceptors`是在构建`axios`实例化的属性\n\n```js\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(), // 请求拦截\n    response: new InterceptorManager() // 响应拦截\n  };\n}\n```\n\n`InterceptorManager`构造函数\n\n```js\n// 拦截器的初始化 其实就是一组钩子函数\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n// 调用拦截器实例的use时就是往钩子函数中push方法\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n// 拦截器是可以取消的，根据use的时候返回的ID，把某一个拦截器方法置为null\n// 不能用 splice 或者 slice 的原因是 删除之后 id 就会变化，导致之后的顺序或者是操作不可控\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n// 这就是在 Axios的request方法中 中循环拦截器的方法 forEach 循环执行钩子函数\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n}\n```\n\n请求拦截器方法是被 `unshift`到拦截器中，响应拦截器是被`push`到拦截器中的。最终它们会拼接上一个叫`dispatchRequest`的方法被后续的 `promise` 顺序执行\n\n```js\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n// 判断请求是否已被取消，如果已经被取消，抛出已取消\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // 如果包含baseUrl, 并且不是config.url绝对路径，组合baseUrl以及config.url\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    // 组合baseURL与url形成完整的请求路径\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  config.headers = config.headers || {};\n\n  // 使用/lib/defaults.js中的transformRequest方法，对config.headers和config.data进行格式化\n  // 比如将headers中的Accept，Content-Type统一处理成大写\n  // 比如如果请求正文是一个Object会格式化为JSON字符串，并添加application/json;charset=utf-8的Content-Type\n  // 等一系列操作\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // 合并不同配置的headers，config.headers的配置优先级更高\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  // 删除headers中的method属性\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  // 如果config配置了adapter，使用config中配置adapter的替代默认的请求方法\n  var adapter = config.adapter || defaults.adapter;\n\n  // 使用adapter方法发起请求（adapter根据浏览器环境或者Node环境会有不同）\n  return adapter(config).then(\n    // 请求正确返回的回调\n    function onAdapterResolution(response) {\n      // 判断是否以及取消了请求，如果取消了请求抛出以取消\n      throwIfCancellationRequested(config);\n\n      // 使用/lib/defaults.js中的transformResponse方法，对服务器返回的数据进行格式化\n      // 例如，使用JSON.parse对响应正文进行解析\n      response.data = transformData(\n        response.data,\n        response.headers,\n        config.transformResponse\n      );\n\n      return response;\n    },\n    // 请求失败的回调\n    function onAdapterRejection(reason) {\n      if (!isCancel(reason)) {\n        throwIfCancellationRequested(config);\n\n        if (reason && reason.response) {\n          reason.response.data = transformData(\n            reason.response.data,\n            reason.response.headers,\n            config.transformResponse\n          );\n        }\n      }\n      return Promise.reject(reason);\n    }\n  );\n};\n```\n\n再来看看`axios`是如何实现取消请求的，实现文件在`CancelToken.js`\n\n```js\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n  // 在 CancelToken 上定义一个 pending 状态的 promise ，将 resolve 回调赋值给外部变量 resolvePromise\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  // 立即执行 传入的 executor函数，将真实的 cancel 方法通过参数传递出去。\n  // 一旦调用就执行 resolvePromise 即前面的 promise 的 resolve，就更改promise的状态为 resolve。\n  // 那么xhr中定义的 CancelToken.promise.then方法就会执行, 从而xhr内部会取消请求\n  executor(function cancel(message) {\n    // 判断请求是否已经取消过，避免多次执行\n    if (token.reason) {\n      return;\n    }\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\nCancelToken.source = function source() {\n  // source 方法就是返回了一个 CancelToken 实例，与直接使用 new CancelToken 是一样的操作\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  // 返回创建的 CancelToken 实例以及取消方法\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n```\n\n实际上取消请求的操作是在 `xhr.js` 中也有响应的配合的\n\n```js\nif (config.cancelToken) {\n    config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n            return;\n        }\n        // 取消请求\n        request.abort();\n        reject(cancel);\n    });\n}\n```\n\n巧妙的地方在 `CancelToken`中 `executor` 函数，通过`resolve`函数的传递与执行，控制`promise`的状态\n\n\n\n### 小结\n\n ![](https://static.ecool.fun//article/e785c66f-b0a5-4816-b303-a1f638eda1b8.png)\n\n\n\n\n\n## 参考文献\n\n- https://juejin.cn/post/6856706569263677447#heading-4\n- https://juejin.cn/post/6844903907500490766\n- https://github.com/axios/axios",
    "level": 3,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-04T03:47:22.000Z",
    "updateAt": "2024-01-25T15:38:30.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 126,
    "prev": "fe2b8ddc-c302-4179-a215-edcec1e80f3c",
    "next": "71d2fd07-2629-4ffd-a9ea-750ee912f912"
  },
  "post": {
    "exerciseKey": "605ec5f7-3768-4aa4-8cdc-3b5bd90bebc3",
    "category": "QA",
    "title": "Axios的原理是什么？",
    "level": 3,
    "updateAt": "2024-01-25T15:38:30+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}
