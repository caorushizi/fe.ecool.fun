{
  "data": {
    "id": 1941,
    "exerciseKey": "d66f9477-309f-4af7-b667-d39ad3525a5b",
    "category": "QA",
    "renderType": "md",
    "title": "说说你对“立即执行函数”的理解\n",
    "desc": null,
    "options": null,
    "explanation": "什么是立即执行函数？\n\nJS立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式（命名的或者匿名的），在创建后立即执行。\n\n**立即执行函数的两种常见写法**：\n\n* 匿名函数包裹在一个括号运算符中，后面跟一个小括号\n\n```js\n(function(){\n    //...\n})()\n```\n\n* 匿名函数后面跟一个小括号，整个包裹在一个括号运算符中\n\n```js\n(function(){\n    //...\n}())\n```\n\n()，！，+，-，=等运算符都能起到立即执行的作用，这些运算符的作用就是将匿名函数或函数声明转换为函数表达式。\n\n注意：\n\n* 函数体后面要有小括号()\n* 函数体必须是函数表达式而不能是函数声明\n\n例：\n\n```js\n(function (test) {    //使用()运算符,输出123\n    console.log(test);\n})(123);\n\n(function (test) {    //使用()运算符,输出123\n    console.log(test);\n}(123));\n\n!function (test) {    //使用!运算符,输出123\n    console.log(test);\n}(123);\nvar fn = function (test) {  //使用=运算符,输出123\n    console.log(test);\n}(123);\n```\n\n**好处**：\n\n* 不必为函数命名，避免了污染全局变量\n* 立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量\n* 封装变量\n\n总之：立即执行函数会形成一个单独的作用域，可以封装一些临时变量或者局部变量，避免污染全局变量。",
    "level": 1,
    "status": 2,
    "appId": 7,
    "createAt": "2023-03-12T08:48:07.000Z",
    "updateAt": "2023-03-12T16:48:15.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 434,
    "prev": "eda0c7a2-e591-4eeb-8bf0-69f8162c8db1",
    "next": "a0e34df4-b603-4b18-bcd6-ebf8c94b3325"
  },
  "post": {
    "exerciseKey": "d66f9477-309f-4af7-b667-d39ad3525a5b",
    "category": "QA",
    "title": "说说你对“立即执行函数”的理解\n",
    "level": 1,
    "updateAt": "2023-03-12T16:48:15+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}
