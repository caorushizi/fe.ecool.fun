{
  "data": {
    "id": 249,
    "exerciseKey": "f43b7906-f51f-454f-8028-ea027ae3e121",
    "category": "QA",
    "renderType": "md",
    "title": "Vue怎么实现权限管理？控制到按钮级别的权限怎么做？",
    "desc": null,
    "options": null,
    "explanation": "## 一、是什么\n\n权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源\n\n而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发\n\n- 页面加载触发\n- 页面上的按钮点击触发\n\n总的来说，所有的请求发起都触发自前端路由或视图\n\n所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：\n\n- 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 `4xx` 提示页\n\n- 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件\n\n- 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截\n\n\n\n## 二、如何做\n\n前端权限控制可以分为四个方面：\n\n- 接口权限\n- 按钮权限\n- 菜单权限\n- 路由权限\n\n\n\n### 接口权限\n\n接口权限目前一般采用`jwt`的形式来验证，没有通过的话一般返回`401`，跳转到登录页面重新进行登录\n\n登录完拿到`token`，将`token`存起来，通过`axios`请求拦截器进行拦截，每次请求的时候头部携带`token`\n\n```js\naxios.interceptors.request.use(config => {\n    config.headers['token'] = cookie.get('token')\n    return config\n})\naxios.interceptors.response.use(res=>{},{response}=>{\n    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误\n        router.push('/login')\n    }\n})\n```\n\n\n\n### 路由权限控制\n\n**方案一**\n\n初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验\n\n```js\nconst routerMap = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/index',\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [{\n      path: 'page',\n      component: () => import('@/views/permission/page'),\n      name: 'pagePermission',\n      meta: {\n        title: 'pagePermission',\n        roles: ['admin'] // or you can only set roles in sub nav\n      }\n    }, {\n      path: 'directive',\n      component: () => import('@/views/permission/directive'),\n      name: 'directivePermission',\n      meta: {\n        title: 'directivePermission'\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]\n\n```\n\n这种方式存在以下四种缺点：\n\n- 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。\n\n- 全局路由守卫里，每次路由跳转都要做权限判断。\n\n- 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n\n- 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n\n\n**方案二**\n\n初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制\n\n登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用`addRoutes`添加路由\n\n```js\nimport router from './router'\nimport store from './store'\nimport { Message } from 'element-ui'\nimport NProgress from 'nprogress' // progress bar\nimport 'nprogress/nprogress.css'// progress bar style\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nNProgress.configure({ showSpinner: false })// NProgress Configuration\n\n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role => permissionRoles.indexOf(role) >= 0)\n}\n\nconst whiteList = ['/login', '/authredirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === '/login') {\n      next({ path: '/' })\n      NProgress.done() // if current page is dashboard will not trigger\tafterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch('GetUserInfo').then(res => { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']\n          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) => {\n          store.dispatch('FedLogOut').then(() => {\n            Message.error(err || 'Verification failed, please login again')\n            next({ path: '/' })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n\nrouter.afterEach(() => {\n  NProgress.done() // finish progress bar\n})\n\n```\n\n按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限\n\n这种方式也存在了以下的缺点：\n\n- 全局路由守卫里，每次路由跳转都要做判断\n- 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n- 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n\n\n### 菜单权限\n\n菜单权限可以理解成将页面与理由进行解耦\n\n#### 方案一\n\n菜单与路由分离，菜单由后端返回\n\n前端定义路由信息\n\n```js\n{\n    name: \"login\",\n    path: \"/login\",\n    component: () => import(\"@/pages/Login.vue\")\n}\n```\n\n`name`字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有`name`对应的字段，并且做唯一性校验\n\n全局路由守卫里做判断\n\n```js\nfunction hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n\n}\n\nRouter.beforeEach(async (to, from, next) => {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(\"GetUserInfo\")\n        await store.dispatch('updateAccessMenu')\n        if (to.path === '/login') {\n          next({ name: 'home_index' })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next('/login')\n        }\n      }\n    } else {\n      if (to.path === '/login') {\n        next({ name: 'home_index' })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: '/403',replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login')\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n\nRouter.afterEach((to) => {\n  window.scrollTo(0, 0);\n});\n```\n\n每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的`name`与路由的`name`是一一对应的，而后端返回的菜单就已经是经过权限过滤的\n\n如果根据路由`name`找不到对应的菜单，就表示用户有没权限访问\n\n如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过`addRoutes`动态挂载\n\n这种方式的缺点：\n\n- 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用\n- 全局路由守卫里，每次路由跳转都要做判断\n\n\n\n#### 方案二\n\n菜单和路由都由后端返回\n\n前端统一定义路由组件\n\n```js\nconst Home = () => import(\"../pages/Home.vue\");\nconst UserInfo = () => import(\"../pages/UserInfo.vue\");\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};\n```\n\n后端路由组件返回以下格式\n\n```js\n[\n    {\n        name: \"home\",\n        path: \"/\",\n        component: \"home\"\n    },\n    {\n        name: \"home\",\n        path: \"/userinfo\",\n        component: \"userInfo\"\n    }\n]\n```\n\n在将后端返回路由通过`addRoutes`动态挂载之间，需要将数据处理一下，将`component`字段换为真正的组件\n\n如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理\n\n这种方法也会存在缺点：\n\n- 全局路由守卫里，每次路由跳转都要做判断\n- 前后端的配合要求更高\n\n\n\n### 按钮权限\n\n#### 方案一\n\n按钮权限也可以用`v-if`判断\n\n但是如果页面过多，每个页面页面都要获取用户权限`role`和路由表里的`meta.btnPermissions`，然后再做判断\n\n这种方式就不展开举例了\n\n\n\n#### 方案二\n\n通过自定义指令进行按钮权限的判断\n\n首先配置路由\n\n```js\n{\n    path: '/permission',\n    component: Layout,\n    name: '权限测试',\n    meta: {\n        btnPermissions: ['admin', 'supper', 'normal']\n    },\n    //页面需要的权限\n    children: [{\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin', 'supper']\n        } //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin']\n        } //页面需要的权限\n    }]\n}\n```\n\n自定义权限鉴定指令\n\n```js\nimport Vue from 'vue'\n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) > -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n```\n\n在使用的按钮中只需要引用`v-has`指令\n\n```js\n<el-button @click='editClick' type=\"primary\" v-has>编辑</el-button>\n```\n\n\n\n### 小结\n\n关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离\n\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 3,
    "appId": 7,
    "createAt": "2021-07-04T03:48:55.000Z",
    "updateAt": "2024-08-10T17:04:47.000Z",
    "isCollected": false,
    "currentIndex": 1250,
    "filterTotalNum": 1487,
    "prev": "3538f4eb-5b78-4ffc-aeae-ccfdd45976a4",
    "next": "fe2b8ddc-c302-4179-a215-edcec1e80f3c"
  },
  "post": {
    "exerciseKey": "f43b7906-f51f-454f-8028-ea027ae3e121",
    "category": "QA",
    "title": "Vue怎么实现权限管理？控制到按钮级别的权限怎么做？",
    "level": 3,
    "createAt": "2021-07-04T03:48:55+00:00",
    "updateAt": "2024-08-10T17:04:47+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 97
  }
}