{
  "data": {
    "id": 1848,
    "exerciseKey": "8ecafda7-0ae6-40bd-b8c6-385d02fa7165",
    "category": "QA",
    "renderType": "md",
    "title": "说说你对JS的模块化方案的了解",
    "desc": null,
    "options": null,
    "explanation": "## 前言\n\nJavaScript 语言诞生至今，模块规范化之路曲曲折折。社区先后出现了各种解决方案，包括 AMD、CMD、CommonJS 等，而后 ECMA 组织在 JavaScript 语言标准层面，增加了模块功能（因为该功能是在 ES2015 版本引入的，所以在下文中将之称为 ES6 module）。   \n今天我们就来聊聊，为什么会出现这些不同的模块规范，它们在所处的历史节点解决了哪些问题？\n\n## 何谓模块化？\n\n或根据功能、或根据数据、或根据业务，将一个大程序拆分成互相依赖的小文件，再用简单的方式拼装起来。\n\n## 全局变量\n\n### 演示项目\n\n为了更好的理解各个模块规范，先增加一个简单的项目用于演示。\n\n```\n# 项目目录:\n├─ js              # js文件夹\n│  ├─ main.js      # 入口\n│  ├─ config.js    # 项目配置\n│  └─ utils.js     # 工具\n└─  index.html     # 页面html\n```\n\n### Window\n\n在刀耕火种的前端原始社会，JS 文件之间的通信基本完全依靠`window`对象（借助 HTML、CSS 或后端等情况除外）。\n\n```js\n// config.js\nvar api = 'https://github.com/ronffy';\nvar config = {\n  api: api,\n}\n\n// utils.js\nvar utils = {\n  request() {\n    console.log(window.config.api);\n  }\n}\n\n// main.js\nwindow.utils.request();\n```\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>小贼先生：【深度全面】JS模块规范进化论</title>\n</head>\n<body>\n\n  <!-- 所有 script 标签必须保证顺序正确，否则会依赖报错 -->\n  <script src=\"./js/config.js\"></script>\n  <script src=\"./js/utils.js\"></script>\n  <script src=\"./js/main.js\"></script>\n</body>\n</html>\n```\n\n### IIFE\n\n浏览器环境下，在全局作用域声明的变量都是全局变量。全局变量存在命名冲突、占用内存无法被回收、代码可读性低等诸多问题。\n\n这时，IIFE（匿名立即执行函数）出现了：\n\n```js\n;(function () {\n  ...\n}());\n```\n\n用IIFE重构 config.js：\n\n```js\n;(function (root) {\n  var api = 'https://github.com/ronffy';\n  var config = {\n    api: api,\n  };\n  root.config = config;\n}(window));\n```\n\nIIFE的出现，使全局变量的声明数量得到了有效的控制。\n\n### 命名空间\n\n依靠`window`对象承载数据的方式是“不可靠”的，如`window.config.api`，如果`window.config`不存在，则`window.config.api`就会报错，所以为了避免这样的错误，代码里会大量的充斥`var api = window.config && window.config.api;`这样的代码。\n\n这时，`namespace`登场了，简约版本的`namespace`函数的实现（只为演示，不要用于生产）：\n\n```js\nfunction namespace(tpl, value) {\n  return tpl.split('.').reduce((pre, curr, i) => {\n    return (pre[curr] = i === tpl.split('.').length - 1\n      ? (value || pre[curr])\n      : (pre[curr] || {}))\n  }, window);\n}\n```\n\n用`namespace`设置`window.app.a.b`的值：\n\n```js\nnamespace('app.a.b', 3); // window.app.a.b 值为 3\n```\n\n用`namespace`获取`window.app.a.b`的值：\n\n```js\nvar b = namespace('app.a.b');  // b 的值为 3\n \nvar d = namespace('app.a.c.d'); // d 的值为 undefined \n\n```\n\n`app.a.c`值为`undefined`，但因为使用了`namespace`, 所以`app.a.c.d`不会报错，变量`d`的值为`undefined`。\n\n## AMD/CMD\n\n随着前端业务增重，代码越来越复杂，靠全局变量通信的方式开始捉襟见肘，前端急需一种更清晰、更简单的处理代码依赖的方式，将 JS 模块化的实现及规范陆续出现，其中被应用较广的模块规范有 AMD 和 CMD。\n\n面对一种模块化方案，我们首先要了解的是：1\\. 如何导出接口；2\\. 如何导入接口。\n\n### AMD\n\n> 异步模块定义规范（AMD）制定了定义模块的规则，这样模块和模块的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。\n\n本规范只定义了一个函数`define`，它是全局变量。\n\n```js\n/**\n * @param {string} id 模块名称\n * @param {string[]} dependencies 模块所依赖模块的数组\n * @param {function} factory 模块初始化要执行的函数或对象\n * @return {any} 模块导出的接口\n */\nfunction define(id?, dependencies?, factory): any\n```\n\n### RequireJS\n\nAMD 是一种异步模块规范，RequireJS 是 AMD 规范的实现。\n\n接下来，我们用 RequireJS 重构上面的项目。\n\n在原项目 js 文件夹下增加 require.js 文件：\n\n```\n# 项目目录:\n├─ js                # js文件夹\n│  ├─ ...\n│  └─ require.js     # RequireJS 的 JS 库\n└─  ...\n```\n\n```js\n// config.js\ndefine(function() {\n  var api = 'https://github.com/ronffy';\n  var config = {\n    api: api,\n  };\n  return config;\n});\n\n// utils.js\ndefine(['./config'], function(config) {\n  var utils = {\n    request() {\n      console.log(config.api);\n    }\n  };\n  return utils;\n});\n\n// main.js\nrequire(['./utils'], function(utils) {\n  utils.request();\n});\n```\n\n```html\n<!-- index.html  -->\n<!-- ...省略其他 -->\n<body>\n\n  <script data-main=\"./js/main\" src=\"./js/require.js\"></script>\n</body>\n</html>\n```\n\n可以看到，使用 RequireJS 后，每个文件都可以作为一个模块来管理，通信方式也是以模块的形式，这样既可以清晰的管理模块依赖，又可以避免声明全局变量。\n\n特别说明： \n\n先有 RequireJS，后有 AMD 规范，随着 RequireJS 的推广和普及，AMD 规范才被创建出来。\n\n### CMD和AMD\n\n* CMD 和 AMD 一样，都是 JS 的模块化规范，也主要应用于浏览器端。  \n* AMD 是 RequireJS 在的推广和普及过程中被创造出来。  \n* CMD 是 SeaJS 在的推广和普及过程中被创造出来。\n\n二者的的主要区别是 CMD 推崇依赖就近，AMD 推崇依赖前置：\n\n```js\n// AMD\n// 依赖必须一开始就写好\ndefine(['./utils'], function(utils) {\n  utils.request();\n});\n\n// CMD\ndefine(function(require) {\n  // 依赖可以就近书写\n  var utils = require('./utils');\n  utils.request();\n});\n```\n\nAMD 也支持依赖就近，但 RequireJS 作者和官方文档都是优先推荐依赖前置写法。\n\n考虑到目前主流项目中对 AMD 和 CMD 的使用越来越少，大家对 AMD 和 CMD 有大致的认识就好，此处不再过多赘述。\n\n随着 ES6 模块规范的出现，AMD/CMD 终将成为过去，但毋庸置疑的是，AMD/CMD 的出现，是前端模块化进程中重要的一步。\n\n## CommonJS\n\n前面说了， AMD、CMD 主要用于浏览器端，随着 node 诞生，服务器端的模块规范 CommonJS 被创建出来。\n\n还是以上面介绍到的 `config.js、utils.js、main.js` 为例，看看 CommonJS 的写法:\n\n```js\n// config.js\nvar api = 'https://github.com/ronffy';\nvar config = {\n  api: api,\n};\nmodule.exports = config;\n\n// utils.js\nvar config = require('./config');\nvar utils = {\n  request() {\n    console.log(config.api);\n  }\n};\nmodule.exports = utils;\n\n// main.js\nvar utils = require('./utils');\nutils.request();\nconsole.log(global.api)\n```\n\n执行`node main.js`，`https://github.com/ronffy`被打印了出来。   \n\n在 main.js 中打印`global.api`，打印结果是`undefined`。node 用`global`管理全局变量，与浏览器的`window`类似。与浏览器不同的是，浏览器中顶层作用域是全局作用域，在顶层作用域中声明的变量都是全局变量，而 node 中顶层作用域不是全局作用域，所以在顶层作用域中声明的变量非全局变量。\n\n### module.exports和exports\n\n我们在看 node 代码时，应该会发现，关于接口导出，有的地方使用`module.exports`，而有的地方使用`exports`，这两个有什么区别呢?\n\nCommonJS 规范仅定义了`exports`，但`exports`存在一些问题（下面会说到），所以`module.exports`被创造了出来，它被称为 CommonJS2 。   \n\n每一个文件都是一个模块，每个模块都有一个`module`对象，这个`module`对象的`exports`属性用来导出接口，外部模块导入当前模块时，使用的也是`module`对象，这些都是 node 基于 CommonJS2 规范做的处理。\n\n```js\n// a.js\nvar s = 'i am ronffy'\nmodule.exports = s;\nconsole.log(module);\n```\n\n执行`node a.js`，看看打印的`module`对象：\n\n```\n{\n  exports: 'i am ronffy',\n  id: '.',                                // 模块id\n  filename: '/Users/apple/Desktop/a.js',  // 文件路径名称\n  loaded: false,                          // 模块是否加载完成\n  parent: null,                           // 父级模块\n  children: [],                           // 子级模块\n  paths: [ /* ... */ ],                   // 执行 node a.js 后 node 搜索模块的路径\n}\n```\n\n其他模块导入该模块时：\n\n```js\n// b.js\nvar a = require('./a.js'); // a --> i am ronffy\n```\n\n当在 a.js 里这样写时：\n\n```js\n// a.js\nvar s = 'i am ronffy'\nexports = s;\n```\n\na.js 模块的`module.exports`是一个空对象。\n\n```js\n// b.js\nvar a = require('./a.js'); // a --> {}\n```\n\n把`module.exports`和`exports`放到“明面”上来写，可能就更清楚了：\n\n```js\nvar module = {\n  exports: {}\n}\nvar exports = module.exports;\nconsole.log(module.exports === exports); // true\n\nvar s = 'i am ronffy'\nexports = s; // module.exports 不受影响\nconsole.log(module.exports === exports); // false\n```\n\n模块初始化时，`exports`和`module.exports`指向同一块内存，`exports`被重新赋值后，就切断了跟原内存地址的关系。\n\n所以，`exports`要这样使用：\n\n```js\n// a.js\nexports.s = 'i am ronffy';\n\n// b.js\nvar a = require('./a.js');\nconsole.log(a.s); // i am ronffy\n```\n\nCommonJS 和 CommonJS2 经常被混淆概念，一般大家经常提到的 CommonJS 其实是指 CommonJS2，本文也是如此，不过不管怎样，大家知晓它们的区别和如何应用就好。\n\n### CommonJS与AMD\n\nCommonJS 和 AMD 都是运行时加载，换言之：都是在运行时确定模块之间的依赖关系。 \n\n二者有何不同点：\n\n1. CommonJS 是服务器端模块规范，AMD 是浏览器端模块规范。\n2. CommonJS 加载模块是同步的，即执行`var a = require('./a.js');`时，在 a.js 文件加载完成后，才执行后面的代码。AMD 加载模块是异步的，所有依赖加载完成后以回调函数的形式执行代码。\n3. \\[如下代码\\]`fs`和`chalk`都是模块，不同的是，`fs`是 node 内置模块，`chalk`是一个 npm 包。这两种情况在 CommonJS 中才有，AMD 不支持。\n\n```js\nvar fs = require('fs');\nvar chalk = require('chalk');\n```\n\n## UMD\n\n> Universal Module Definition.\n\n存在这么多模块规范，如果产出一个模块给其他人用，希望支持全局变量的形式，也符合 AMD 规范，还能符合 CommonJS 规范，能这么全能吗？   \n是的，可以如此全能，UMD 闪亮登场。\n\nUMD 是一种通用模块定义规范，代码大概这样(假如我们的模块名称是 myLibName):\n\n```js\n!function (root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') {\n    // CommonJS2\n    module.exports = factory()\n    // define.amd 用来判断项目是否应用 require.js。\n    // 更多 define.amd 介绍，请[查看文档](https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property-)\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory)\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.myLibName = factory()\n  } else {\n    // 全局变量\n    root.myLibName = factory()\n  }\n}(window, function () {\n  // 模块初始化要执行的代码\n});\n```\n\nUMD 解决了 JS 模块跨模块规范、跨平台使用的问题，它是非常好的解决方案。\n\n## ES6 module\n\nAMD 、 CMD 等都是在原有JS语法的基础上二次封装的一些方法来解决模块化的方案，ES6 module（在很多地方被简写为 ESM）是语言层面的规范，ES6 module 旨在为浏览器和服务器提供通用的模块解决方案。长远来看，未来无论是基于 JS 的 WEB 端，还是基于 node 的服务器端或桌面应用，模块规范都会统一使用 ES6 module。\n\n### 兼容性\n\n目前，无论是浏览器端还是 node ，都没有完全原生支持 ES6 module，如果使用 ES6 module ，可借助 [babel](https://link.segmentfault.com/?enc=OURkG%2BIY5AFtYQSvk2oXpA%3D%3D.lln5vToJ82eedPfkBshKMEyE0fom4DKUYQxzvphPFmo%3D) 等编译器。本文只讨论 ES6 module 语法，故不对 babel 或 typescript 等可编译 ES6 的方式展开讨论。\n\n### 导出接口\n\nCommonJS 中顶层作用域不是全局作用域，同样的，ES6 module 中，一个文件就是一个模块，文件的顶层作用域也不是全局作用域。导出接口使用`export`关键字，导入接口使用`import`关键字。\n\n`export`导出接口有以下方式：\n\n#### 方式1\n\n```js\nexport const prefix = 'https://github.com';\nexport const api = `${prefix}/ronffy`;\n```\n\n#### 方式2\n\n```js\nconst prefix = 'https://github.com';\nconst api = `${prefix}/ronffy`;\nexport {\n  prefix,\n  api,\n}\n```\n\n方式1和方式2只是写法不同，结果是一样的，都是把`prefix`和`api`分别导出。\n\n#### 方式3（默认导出）\n\n```js\n// foo.js\nexport default function foo() {}\n\n// 等同于：\nfunction foo() {}\nexport {\n  foo as default\n}\n```\n\n`export default`用来导出模块默认的接口，它等同于导出一个名为`default`的接口。配合`export`使用的`as`关键字用来在导出接口时为接口重命名。\n\n#### 方式4（先导入再导出简写）\n\n```js\nexport { api } from './config.js';\n\n// 等同于：\nimport { api } from './config.js';\nexport {\n  api\n}\n```\n\n如果需要在一个模块中先导入一个接口，再导出，可以使用`export ... from 'module'`这样的简便写法。\n\n### 导入模块接口\n\nES6 module 使用`import`导入模块接口。\n\n导出接口的模块代码1：\n\n```js\n// config.js\nconst prefix = 'https://github.com';\nconst api = `${prefix}/ronffy`;\nexport {\n  prefix,\n  api,\n}\n```\n\n接口已经导出，如何导入呢：\n\n#### 方式1\n\n```js\nimport { api } from './config.js';\n\n// or\n// 配合`import`使用的`as`关键字用来为导入的接口重命名。\nimport { api as myApi } from './config.js';\n```\n\n#### 方式2（整体导入）\n\n```js\nimport * as config from './config.js';\nconst api = config.api;\n```\n\n将 config.js 模块导出的所有接口都挂载在`config`对象上。\n\n#### 方式3（默认导出的导入）\n\n```js\n// foo.js\nexport const conut = 0;\nexport default function myFoo() {}\n\n// index.js\n// 默认导入的接口此处刻意命名为cusFoo，旨在说明该命名可完全自定义。\nimport cusFoo, { count } from './foo.js';\n\n// 等同于：\nimport { default as cusFoo, count } from './foo.js';\n```\n\n`export default`导出的接口，可以使用`import name from 'module'`导入。这种方式，使导入默认接口很便捷。\n\n#### 方式4（整体加载）\n\nimport './config.js';\n\n这样会加载整个 config.js 模块，但未导入该模块的任何接口。\n\n#### 方式5（动态加载模块）\n\n上面介绍了 ES6 module 各种导入接口的方式，但有一种场景未被涵盖：动态加载模块。比如用户点击某个按钮后才弹出弹窗，弹窗里功能涉及的模块的代码量比较重，所以这些相关模块如果在页面初始化时就加载，实在浪费资源，`import()`可以解决这个问题，从语言层面实现模块代码的按需加载。\n\nES6 module 在处理以上几种导入模块接口的方式时都是编译时处理，所以`import`和`export`命令只能用在模块的顶层，以下方式都会报错：\n\n```js\n// 报错\nif (/* ... */) {\n  import { api } from './config.js'; \n}\n\n// 报错\nfunction foo() {\n  import { api } from './config.js'; \n}\n\n// 报错\nconst modulePath = './utils' + '/api.js';\nimport modulePath;\n```\n\n使用`import()`实现按需加载：\n\n```js\nfunction foo() {\n  import('./config.js')\n    .then(({ api }) => {\n\n    });\n}\n\nconst modulePath = './utils' + '/api.js';\nimport(modulePath);\n\n```\n\n特别说明：   \n该功能的提议目前处于 TC39 流程的第4阶段。更多说明，请查看[TC39/proposal-dynamic-import](https://link.segmentfault.com/?enc=u61kJdRaczxbmqQREX%2FCUw%3D%3D.j9rCDxYgxXMW%2FmIMJvWZqURrkN38%2FXqha2fZM6a3RRy61j%2BPqOJa7i5wATeqRqGR)。\n\n### CommonJS 和 ES6 module\n\nCommonJS 和 AMD 是运行时加载，在运行时确定模块的依赖关系。  \n\nES6 module 是在编译时（`import()`是运行时加载）处理模块依赖关系，。\n\n#### CommonJS\n\nCommonJS 在导入模块时，会加载该模块，所谓“CommonJS 是运行时加载”，正因代码在运行完成后生成`module.exports`的缘故。当然，CommonJS 对模块做了缓存处理，某个模块即使被多次多处导入，也只加载一次。\n\n```js\n// o.js\nlet num = 0;\nfunction getNum() {\n  return num;\n}\nfunction setNum(n) {\n  num = n;\n}\nconsole.log('o init');\nmodule.exports = {\n  num,\n  getNum,\n  setNum,\n}\n\n// a.js\nconst o = require('./o.js');\no.setNum(1);\n\n// b.js\nconst o = require('./o.js');\n// 注意：此处只是演示，项目里不要这样修改模块\no.num = 2;\n\n// main.js\nconst o = require('./o.js');\n\nrequire('./a.js');\nconsole.log('a o.num:', o.num);\n\nrequire('./b.js');\nconsole.log('b o.num:', o.num);\nconsole.log('b o.getNum:', o.getNum());\n```\n\n命令行执行`node main.js`，打印结果如下：\n\n```\n1. `o init`  \n_模块即使被其他多个模块导入，也只会加载一次，并且在代码运行完成后将接口赋值到`module.exports`属性上。_\n2. `a o.num: 0`  \n_模块在加载完成后，模块内部的变量变化不会反应到模块的`module.exports`。_\n3. `b o.num: 2`  \n_对导入模块的直接修改会反应到该模块的`module.exports`。_\n4. `b o.getNum: 1`  \n_模块在加载完成后即形成一个闭包。_\n```\n\n#### ES6 module\n\n```js\n// o.js\nlet num = 0;\nfunction getNum() {\n  return num;\n}\nfunction setNum(n) {\n  num = n;\n}\nconsole.log('o init');\nexport {\n  num,\n  getNum,\n  setNum,\n}\n\n// main.js\nimport { num, getNum, setNum } from './o.js';\n\nconsole.log('o.num:', num);\nsetNum(1);\n\nconsole.log('o.num:', num);\nconsole.log('o.getNum:', getNum());\n```\n\n我们增加一个 index.js 用于在 node 端支持 ES6 module：\n\n```js\n// index.js\nrequire(\"@babel/register\")({\n  presets: [\"@babel/preset-env\"]\n});\n\nmodule.exports = require('./main.js')\n```\n\n命令行执行`npm install @babel/core @babel/register @babel/preset-env -D`安装 ES6 相关 npm 包。\n\n命令行执行`node index.js`，打印结果如下：\n\n```\n1. `o init`  \n_模块即使被其他多个模块导入，也只会加载一次。_\n2. `o.num: 0`\n3. `o.num: 1`  \n_编译时确定模块依赖的 ES6 module，通过`import`导入的接口只是值的引用，所以`num`才会有两次不同打印结果。_\n4. `o.getNum: 1`\n```\n\n对于打印结果3，知晓其结果，在项目中注意这一点就好。这块会涉及到“Module Records（模块记录）”、“module instance（模快实例）” “linking（链接）”等诸多概念和原理，大家可查看[ES modules: A cartoon deep-dive](https://link.segmentfault.com/?enc=hJYZAxC5vGU2b7y9DswrNw%3D%3D.GLzrq10c45xH5q5ft4hV%2FfypqEagM9x1KX5sfe6PEYfk0n%2BDoqMPVqv23r5OHj1%2FPPpkj7AY0cgIX1dO%2B%2BNsMtCuUx27jMNt9Dq1LUmiBgs%3D)进行深入的研究，本文不再展开。\n\nES6 module 是编译时加载（或叫做“静态加载”），利用这一点，可以对代码做很多之前无法完成的优化：\n\n1. 在开发阶段就可以做导入和导出模块相关的代码检查。\n2. 结合 Webpack、Babel 等工具可以在打包阶段移除上下文中未引用的代码（dead-code），这种技术被称作“tree shaking”，可以极大的减小代码体积、缩短程序运行时间、提升程序性能。\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 3,
    "appId": 7,
    "createAt": "2022-07-03T05:30:11.000Z",
    "updateAt": "2024-08-10T17:06:47.000Z",
    "isCollected": false,
    "currentIndex": 541,
    "filterTotalNum": 1487,
    "prev": "d76e76c3-7400-4c6e-958a-b5f00916d47d",
    "next": "2ed6f1f7-b974-475a-b314-f1962c744faf"
  },
  "post": {
    "exerciseKey": "8ecafda7-0ae6-40bd-b8c6-385d02fa7165",
    "category": "QA",
    "title": "说说你对JS的模块化方案的了解",
    "level": 3,
    "createAt": "2022-07-03T05:30:11+00:00",
    "updateAt": "2024-08-10T17:06:47+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 379
  }
}