{
  "data": {
    "id": 1684,
    "exerciseKey": "5e131c75-d26e-4527-8f51-29d842f3c829",
    "category": "QA",
    "renderType": "md",
    "title": "ES6有哪些新特性？",
    "desc": null,
    "options": null,
    "explanation": " ### 关于ES6和JavaScript的关系\n\n##### 1、ES6是对于ES2015+的俗称，也可以说是通常叫法，那么，ES6是什么呢？\n\nES 全称是ECMAScript，它是JavaScript基础构建的一种语言，JavaScript正是建立在ECMAScript语言的基础规范中建立使用的，那么，ECMAScript的使用，对于JavaScript至关重要！\n\n在我的理解中，ECMAScript是一种语言层面的东西，它只是定义了JavaScript以及在它基础之上建立的其他语言的语法规范，而JavaScript的语言，更关于一种平台性质在其中。\n\nJavaScript包括 ECMAScript、DOM、BOM三个组成部分，DOM和BOM是web API提供的接口或者是JavaScript和浏览器之间进行交互的部分，实质就是操纵文档元素，进行展示布局，而ECMAScript在JavaScript中其中语法的作用，它不会去跟文档有直接的关系，但是他的数据处理完成后会通过web API展示在文档中。\n\n### ES6新特性的分类\n\n新特性主要归为四大类：\n\n* 解决原有语法上的一些不足\n\n比如let 和 const 的块级作用域\n\n* 对原有语法进行增强\n\n比如解构、展开、参数默认值、模板字符串\n\n* 全新的对象、全新的方法、全新的功能\n\n比如promise、proxy、object的assign、is\n\n* 全新的数据类型和数据结构\n\n比如symbol、set、map\n\n下面具体进行介绍\n\n## 1. let、const 块级作用域以及和 var 的区别\n\n- let、const 声明的变量，在 for，if 语句中，会形成块级作用域，块级作用域内的变量，不能被作用域外部使用\n- let、const 声明变量不再会有声明提升，在变量声明之前使用运行时会报错\n\n```js\n//块级作用域一级块级作用域的使用\nif (true) {\n  const param = 'param in if block'\n  console.log(param) //param in if block\n}\nconsole.log(param) //块级作用域外访问内部定义的变量，ReferenceError: param is not defined\n```\n\n- 块级作用域声明变量，会出现“暂时性死区”，块级作用域声明变量前使用变量，将会报错\n\n```js\n// 暂时性死区\nconst i = 100\nif (i) {\n  console.log(i) //ReferenceError: Cannot access 'i' before initialization\n  const i = 1000\n}\n```\n\n- const 声明的是一个常量，声明必须初始化\n\n```js\n\n    // const常量声明必须初始化\n    const i;\n    i = 10;\n    console.log(i) //SyntaxError: Missing initializer in const declaration\n\n```\n\n- 如果 const 声明的是基本类型常量，初始化之后不能修改；引用类型的常量，可以修改其成员变量；\n\n```js\n// 基本类型常量不能修改，引用类型常量能修改属性\nconst str = 'str'\nstr = 'str1' //TypeError: Assignment to constant variable.\n\nconst arr = [1, 2, 3]\narr[0] = 100\nconsole.log(arr[0]) //100\n```\n\n- 和 var 的区别\n\n| 声明方式 | 变量提升 | 作用域 | 初始值 | 重复定义 |\n| -------- | -------- | ------ | ------ | -------- |\n| var      | 是       | 函数级 | 不需要 | 允许     |\n| let      | 否       | 块级   | 不需要 | 不允许   |\n| const    | 否       | 块级   | 必需   | 不允许   |\n\n## 2.解构-快速提取数组/对象中的元素\n\n- **数组解构**\n\n- 单独解构-根据数组索引，将数组解构成单独的元素\n\n```js\nconst arr = [1, 2, 3]\n\nconst [a, b, c] = arr\nconsole.log(a, b, c) //1,2,3\nconst [, , d] = arr\nconsole.log(d) //3\n```\n\n- 默认值，解构时可以给变量设置默认值，数组没有这个元素的话\n\n```js\nconst arr = [1, 2, 3]\n\nconst [, , , defaultVal = '4'] = arr\nconsole.log('设置默认值', defaultVal)\n```\n\n- 剩余解构-用 \"...+变量名\" 解构剩余参数到新数组，只能用一次\n\n```js\nconst arr = [1, 2, 3]\n\nconst [e, ...rest] = arr\nconsole.log(rest) //[2, 3]\n```\n\n- 实例应用\n\n```js\n// 拆分字符串\nconst str = 'xiaobai/18/200'\nconst strArr = str.split('/')\nconst [, age] = strArr\nconsole.log(age) //18\n```\n\n- **对象解构**\n\n- 单个/多个解构-跟数组解构差不多\n\n```js\nconst obj = { name: 'xiaohui', age: 18, height: undefined }\nconst { name, age } = obj\nconsole.log(name, age) // 'xiaohui', 18\n```\n\n- 解构+重命名-给解构出来的变量重命名\n\n```js\nconst obj = { name: 'xiaohui', age: 18, height: undefined }\nconst { name: objName } = obj\nconsole.log(objName)\n```\n\n- 默认值-给解构变量设置默认值\n\n```js\nconst obj = { name: 'xiaohui', age: 18, height: undefined }\nconst { next = 'default' } = obj\nconsole.log(next)\n```\n\n## 3.模板字符串\n\n用法：使用``将字符串包裹起来\n\n功能：可以换行、插值、使用标签函数进行字符串操作\n\n示例：\n\n- 换行/插值\n\n```js\n//换行\nconst str = `fdsjak\n    fdsa`\nconsole.log(str)\n\n// 插值\nconst strs = `random: ${Math.random()}`\nconsole.log(strs)\n```\n\n- 标签函数-可以对模板字符串的字符串和插值进行处理和过滤等操作\n\n```js\n/**\n * 字符串模板函数\n * @param {array} strs 以插值为分隔符组成的字符串数组\n * @param {string} name 插值的value，有多少个就会传入多少个\n */\nconst tagFunc = (strs, name, gender) => {\n  const [str1, str2, str3] = strs\n  const genderParsed = gender == '1' ? '男' : '女'\n  // 可以在此做过滤，字符串处理，多语言等操作\n  return str1 + name + str2 + str3 + genderParsed\n}\n\n// 带标签的模板字符串,\nconst person = {\n  name: 'xiaohui',\n  gender: 1,\n}\n// 返回值为标签函数的返回值\nconst result = tagFunc`my name is ${person.name}.gender is ${person.gender}`\nconsole.log(result) //my name is xiaohui.gender is 男\n```\n\n## 4. 字符串扩展方法\n\n- includes-是否包含\n- startsWith-是否以什么开始\n- endsWith-是否以什么结束\n\n```js\nconst str = 'abcd'\n\nconsole.log(str.includes('e')) //false\nconsole.log(str.startsWith('a')) //true\nconsole.log(str.endsWith('a')) //false\n```\n\n## 5.参数默认值&剩余参数\n\n- 给函数形参设置默认值\n\n```js\n// 带默认参数的形参一般放在后面，减少传参导致的错误几率\nconst defaultParams = function (name, age = 0) {\n  return [age, name]\n}\nconsole.log(defaultParams(1))\n```\n\n- 使用...rest 形式设置剩余形参，支持无限参数\n\n```js\n// 剩余参数，转化成数组\nconst restParams = function (...args) {\n  console.log(args.toString()) //1, 2, 3, 4, 5\n}\n\nrestParams(1, 2, 3, 4, 5)\n```\n\n## 6.展开数组\n\n使用...将数组展开\n\n```js\nconst arr = [1, 2, 3]\n\nconsole.log(...arr)\n// 等价于es5中以下写法\nconsole.log.apply(console, arr)\n```\n\n## 7.箭头函数\n\n**特性&优势：**\n\n- 1、简化了函数的写法\n- 2、没有 this 机制，this 继承自上一个函数的上下文，如果上一层没有函数，则指向 window\n- 3、作为异步回调函数时，可解决 this 指向问题\n\n```js\nconst inc = (n) => n + 1\nconsole.log(inc(100))\n\nconst obj = {\n  name: 'aa',\n  func() {\n    setTimeout(() => {\n      console.log(this.name) //aa\n    }, 0)\n    setTimeout(function () {\n      console.log(this.name) //undefined\n    }, 0)\n  },\n}\nobj.func()\n```\n\n## 8.对象字面量增强\n\n- 同名属性可以省略 key:value 形式，直接 key，\n- 函数可以省略 key：value 形式\n- 可以直接 func(),\n- 可以使用计算属性，比如：{[Math.random()]: value}\n\n```js\n/**\n * 1、增强了对象字面量：\n * 1，同名属性可以省略key:value形式，直接key，\n * 2，函数可以省略key：value形式\n * 3，可以直接func(),\n * 4，可以使用计算属性，比如：{[Math.random()]: value}\n */\nconst arr = [1, 2, 3]\nconst obj = {\n  arr,\n  func() {\n    console.log(this.arr)\n  },\n  [Math.random()]: arr,\n}\n\nconsole.log(obj)\n```\n\n## 9.Object.assign(target1, target2, targetN)-复制/合并对象\n\n```js\n/**\n * Object.assign(target1, target2, ...targetn)\n * 后面的属性向前面的属性合并\n * 如果target1是空对象，可以创建一个全新对象，而不是对象引用\n */\nconst obj1 = {\n  a: 1,\n  b: 2,\n}\nconst obj2 = {\n  a: 1,\n  b: 2,\n}\n\nconst obj3 = Object.assign({}, obj1)\nobj3.a = 5\nconsole.log(obj3, obj2, obj1)\n```\n\n## 10.Object.is(value1, value2)\n\n作用：比较两个值是否相等\n\n特性：\n\n- 没有隐式转换\n- 可以比较+0,-0、NaN\n\n```js\nconsole.log(NaN === NaN) //false\nconsole.log(Object.is(NaN, NaN)) //true\nconsole.log(0 === -0) // true\nconsole.log(Object.is(0, -0)) //false\nconsole.log(Object.is(1, 1)) //true\n```\n\n## 11.Proxy(object, handler)\n\n**作用：**\n\n- 代理一个对象的所有，包括读写操作和各种操作的监听\n\n**用法：**\n\n```js\nconst P = {\n  n: 'p',\n  a: 19,\n}\n\nconst proxy = new Proxy(P, {\n  get(target, property) {\n    console.log(target, property)\n    return property in target ? target[property] : null\n  },\n  defineProperty(target, property, attrs) {\n    console.log(target, property, attrs)\n    //   throw new Error('不允许修改')\n  },\n  deleteProperty(target, property) {\n    console.log(target, property)\n    delete target[property]\n  },\n  set(target, property, value) {\n    target[property] = value\n  },\n})\n\nproxy.c = 100\nconsole.log('pp', P)\n```\n\n与 Object.definePropert 对比\n\n优势：\n\n- **拥有很多 defineProperty 没有的属性方法，比如：**\n  - handler.getPrototypeOf() ---Object.getPrototypeOf 方法的监听器\n  - handler.setPrototypeOf() ---Object.setPrototypeOf 方法的监听器。\n  - handler.isExtensible() ---Object.isExtensible 方法的监听器。\n  - handler.preventExtensions() ---Object.preventExtensions 方法的监听器。\n  - handler.getOwnPropertyDescriptor() ---Object.getOwnPropertyDescriptor 方法的监听器。\n  - handler.defineProperty() ---Object.defineProperty 方法的监听器。\n  - handler.has() ---in 操作符的监听器。\n  - handler.get() ---属性读取操作的监听器。\n  - handler.set() ---属性设置操作的监听器。\n  - handler.deleteProperty() ---delete 操作符的监听器\n  - handler.ownKeys() ---Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的监听器。\n  - handler.apply() ---函数调用操作的监听器。\n  - handler.construct() ---new 操作符的监听器。\n- **对数组的监视更方便**\n- **以非侵入的访视监管对象的读写**\n\n## 12.Reflect\n\n作用：\n\n集成 Object 操作的所有方法，统一、方便，具体方法如下：\n\n用于对对象的统一操作，集成 Object 相关的所有方法\n\n1、apply：类似 Function.prototype.apply\n\n2、Reflect.construct()\n\n对构造函数进行 new 操作，相当于执行 new target(...args)。\n\n3、Reflect.defineProperty()\n\n和 Object.defineProperty() 类似。\n\n4、Reflect.deleteProperty()\n\n作为函数的 delete 操作符，相当于执行 delete target[name]。\n\n5、Reflect.get()\n\n获取对象身上某个属性的值，类似于 target[name]。\n\n6、Reflect.getOwnPropertyDescriptor()\n\n类似于 Object.getOwnPropertyDescriptor()。\n\n7、Reflect.getPrototypeOf()\n\n类似于 Object.getPrototypeOf(), 获取目标对象的原型。\n\n8、Reflect.has()\n\n判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。\n\n9、Reflect.isExtensible()\n\n类似于 Object.isExtensible().判断对象是否可扩展，可以添加额外属性\n\nObject.seal(封闭对象)， Object.freeze（冻结对象）是不可扩展的\n\n10、Reflect.ownKeys()\n\n返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响).\n\n11、Reflect.preventExtensions()\n\n类似于 Object.preventExtensions()。返回一个 Boolean。\n\n12、Reflect.set()\n\n将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true, 反之返回 false。\n\n13、Reflect.setPrototypeOf()\n\n类似于 Object.setPrototypeOf()。\n\n示例：\n\n```js\nconst obj = {\n  name: 'reflect',\n}\nReflect.preventExtensions(obj) //禁止扩展\nconsole.log(Reflect.set(obj, 'age', 'xiaobai')) //false\nconsole.log(obj) //{ name: 'reflect' }\nconsole.log(Reflect.isExtensible(obj, 'name')) //false\nconsole.log(Reflect.ownKeys(obj)) //[ 'name' ]\n```\n\n## 13.Promise\n\n作用：解决异步编程中回调嵌套过深问题\n\n## 14.class&静态方法&继承\n\n**定义**\n\n- 使用 class 关键字定义类\n\n```js\nclass Person {\n  constructor(props) {\n    this.props = props\n  }\n}\n```\n\n**方法**\n\n- 实例方法，需要实例化之后才能调用，this 指向实例\n- 静态方法，用 static 修饰符修饰，可以直接通过类名调用，不需要实例化，this 不指向实例，而是指向当前类\n\n```js\nclass Person {\n  constructor(props) {\n    this.props = props\n  }\n  // 实例方法\n  eat() {}\n  // 静态方法\n  static run() {}\n}\n// 调用静态方法\nPerson.run()\nconst person = new Person('props')\n// 调用实例方法\nperson.eat()\n```\n\n**继承：子类使用 extends 关键字实现继承，可以继承父类所有属性**\n\n```js\nclass Student extends Person {\n  constructor(props) {\n    super(props)\n  }\n  printProps() {\n    console.log(this.props)\n  }\n}\n\nconst student = new Student('student')\nstudent.printProps()\n```\n\n## 15.Set\n\n说明：\n\nSet 是一种类似于数组的数据结构\n\n特性：\n\n- 元素唯一性，不允许重复元素\n- 使用 add 增加重复元素，将会被忽略\n\n用途：\n\n- 数组去重\n- 数据存储\n\n```js\nconst arr = [1, 3, 1, 1, 1]\nconst set = new Set(arr)\nset.add(1).add(1)\nconsole.log(set.size) //2\nconst newArr = Array.from(set)\nconsole.log(newArr) //[ 1, 3 ]\n```\n\n## 16.Map\n\n说明：\n\n类似 Object，以 key、value 形式存储数据\n\n区别：\n\nMap 键不会隐式转换成字符串，而是保持原有类型\n\n实例：\n\n```js\nconst map = new Map()\nmap.set(1, 1)\nmap.set('name', 'map')\nmap.set(obj, obj)\nconsole.log(map.get(1)) //1\n/**\n        1 1\n        name map\n        { '1': 1, true: true, a: 'a' } { '1': 1, true: true, a: 'a' }\n     */\nmap.forEach((val, key) => {\n  console.log(key, val)\n})\n```\n\n## 17.Symbol\n\n说明：\n\nJavaScript 第六种原始数据类型，用来定义一个唯一的变量\n\n作用：\n\n- 创建唯一的变量，解决对象键名重复问题\n- 为对象、类、函数等创建私有属性\n\n- 修改对象的 toString 标签\n- 为对象添加迭代器属性\n\n如何获取对象的 symbol 属性？\n\n- Object.getOwnPropertySymbols(object)\n\n实例\n\n```js\n// 对象属性重名问题；\nconst objSymbol = {\n  [Symbol()]: 1,\n  [Symbol()]: 2,\n}\nconsole.log(objSymbol)\n\n// 2、为对象、类、函数等创建私有属性\nconst name = Symbol()\nconst obj2 = {\n  [name]: 'symbol',\n  testPrivate() {\n    console.log(this[name])\n  },\n}\n\nobj2.testPrivate()\n// 定义toString标签；\nconsole.log(obj2.toString())\nobj2[Symbol.toStringTag] = 'xx'\nconsole.log(obj2.toString()) //[object xx]\n```\n\n## 18.for...of...\n\n用途：\n\n已统一的方式，遍历所有引用数据类型\n\n特性：\n\n可以随时使用 break 终止遍历，而 forEach 不行\n\n实例：\n\n```js\n// 基本用法\n// 遍历数组\nconst arr = [1, 2, 3, 4]\nfor (const item of arr) {\n  if (item > 3) {\n    break\n  }\n  if (item > 2) {\n    console.log(item)\n  }\n}\n\n// 遍历set\nconst set = new Set()\nset.add('foo').add('bar')\nfor (const item of set) {\n  console.log('set for of', item)\n}\n// 遍历map\nconst map = new Map()\nmap.set('foo', 'one').set('bar', 'two')\nfor (const [key, val] of map) {\n  console.log('for of map', key, val)\n}\n//迭代对象\nconst obj = {\n  name: 'xiaohui',\n  age: '10',\n  store: [1, 2, 3],\n  // 实现可迭代的接口\n  [Symbol.iterator]: function () {\n    const params = [this.name, this.age, this.store]\n    let index = 0\n    return {\n      next() {\n        const ret = {\n          value: params[index],\n          done: index >= params.length,\n        }\n        index++\n        return ret\n      },\n    }\n  },\n}\n\nfor (const item of obj) {\n  console.log('obj for of', item)\n}\n```\n\n## 19. 迭代器模式\n\n作用：通过 Symbol.interator 对外提供统一的接口，获取内部的数据\n\n外部可以通过 for...of...去迭代内部的数据\n\n```js\nconst tods = {\n  life: ['eat', 'sleep'],\n  learn: ['js', 'dart'],\n  // 增加的任务\n  work: ['sale', 'customer'],\n  [Symbol.iterator]: function () {\n    const all = []\n    Object.keys(this).forEach((key) => {\n      all.push(...this[key])\n    })\n    let index = 0\n    return {\n      next() {\n        const ret = {\n          value: all[index],\n          done: index >= all.length,\n        }\n        index++\n        return ret\n      },\n    }\n  },\n}\n\nfor (const item of tods) {\n  console.log(item)\n}\n```\n\n## 20.Generator 生成器\n\n- Generator\n- 函数前添加 *，生成一个生成器\n- 一般配合 yield 关键字使用\n- 最大特点，惰性执行，调 next 才会往下执行\n- 主要用来解决异步回调过深的问题\n\n```js\n// 生成迭代器方法\n//  生成器Generator的应用\n\nfunction* createIdGenerator() {\n  let id = 1\n  while (id < 3) yield id++\n}\nconst createId = createIdGenerator()\nconsole.log(createId.next()) //{ value: 1, done: false }\nconsole.log(createId.next()) //{ value: 2, done: false }\nconsole.log(createId.next()) //{ value: undefined, done: true }\n\nconst todos = {\n  life: ['eat', 'sleep', 'baba'],\n  learn: ['es5', 'es6', 'design pattern'],\n  work: ['b', 'c', 'framework'],\n  [Symbol.iterator]: function* () {\n    const all = [...this.life, ...this.learn, ...this.work]\n    for (const i of all) {\n      yield i\n    }\n  },\n}\nfor (const item of todos) {\n  console.log(item)\n}\n```\n\n## 21.includes 函数-es2016\n\n判断数组是否包含某个元素，包含 NaN，解决 indexOf 无法查找 NaN 问题\n\n```js\n//  includes函数\nconst arr = ['foo', 'bar', 'baz', NaN]\nconsole.log(arr.includes(NaN)) //true\nconsole.log(arr.indexOf(NaN)) //-1\n```\n\n## 22. 运算符-es2016\n\n指数运算\n\n```js\n// 指数运算符 **\n// es5中2十次方\nconsole.log(Math.pow(2, 10))\n// es6中2十次方\nconsole.log(2 ** 10)\n```\n\n## 23.values 函数-es2017\n\n将对象的值以数组的形式返回\n\n```js\nconst obj = {\n  foo: 1,\n  bar: 2,\n  baz: 3,\n}\n\nconsole.log(Object.values(obj)) //[ 1, 2, 3 ]\n```\n\n## 24.entries 函数-es2017\n\n将对象以键值对二维数组返回，使之可以使用 for...of...遍历\n\n```js\nconst obj = {\n  foo: 1,\n  bar: 2,\n  baz: 3,\n}\nconsole.log(Object.entries(obj))\nconst entry = Object.entries(obj)\nfor (const [key, value] of entry) {\n  console.log(key, value)\n}\n```\n\n## 25.Object.getOwnPropertyDescriptors(obj)-es2017\n\n获取对象的描述信息\n\n可以通过获得的描述信息，配合 Object.defineProperties 来完整复制对象，包含 get，set 方法\n\n```js\n// getOwnPropertyDescriptors\n\n// 普通get方法\nconst objGet = {\n  foo: 1,\n  bar: 2,\n  get getCount() {\n    return this.foo + this.bar\n  },\n}\n// assign方法会把getCount当做普通属性复制，从而getCount为3，修改bar不管用\nconst objGet1 = Object.assign({}, objGet)\nobjGet1.bar = 3\nconsole.log(objGet1.getCount) //3\n// descriptors\nconst descriptors = Object.getOwnPropertyDescriptors(objGet)\nconsole.log('des', descriptors)\n// 通过descriptors来复制对象，可以完整复制对象，包含get，set\nconst objGet2 = Object.defineProperties({}, descriptors)\nobjGet2.bar = 3\nconsole.log(objGet2.getCount) //4\n```\n\n## 26.padStart, padEnd 函数-es2017\n\n在字符串前，或者后面追加指定字符串\n\n参数：\n\ntargetLenght: 填充后的目标长度\n\npadString:填充的字符串\n\n规则：\n\n1、填充的字符串超过目标长度，会在规定长度时被截断\n\n2、填充字符串太短会以空格填充\n\n3、padString 未传值，以空格填充\n\n作用：\n\n一般用来对齐字符串输出\n\n```js\n\n    /**\n     *  foo.................|1\n        barbar..............|2\n        bazbazbaz...........|3\n     */\n    console.log(`${key.padEnd(20, '.')}${value.toString().padStart(2, '|')}`)\n```\n\n\n\n",
    "level": 2,
    "status": 2,
    "appId": 7,
    "createAt": "2022-03-07T04:45:25.000Z",
    "updateAt": "2023-04-16T10:27:15.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 404,
    "prev": "63d73ae0-ea78-4b4c-8a85-6be7513a62a4",
    "next": "23cebacc-48d3-4b48-9393-5c424afffab0"
  },
  "post": {
    "exerciseKey": "5e131c75-d26e-4527-8f51-29d842f3c829",
    "category": "QA",
    "title": "ES6有哪些新特性？",
    "level": 2,
    "updateAt": "2023-04-16T10:27:15+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}