{
  "data": {
    "id": 1772,
    "exerciseKey": "29821d8e-dc41-4581-91fe-9fde7658a559",
    "category": "QA",
    "renderType": "md",
    "title": "async、await 实现原理",
    "desc": null,
    "options": null,
    "explanation": "# JavaScript 异步编程回顾\n\n由于 JavaScript 是单线程执行模型，因此必须支持异步编程才能提高运行效率。异步编程的语法目标是让异步过程写起来像同步过程。\n\n## 1. 回调函数\n\n回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。\n\n```js\nconst fs = require('fs')\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) {\n    console.error(err)\n    return\n  }\n  console.log(data.toString())\n})\n```\n\n回调函数最大的问题是容易形成回调地狱，即多个回调函数嵌套，降低代码可读性，增加逻辑的复杂性，容易出错。\n\n```js\nfs.readFile(fileA, function (err, data) {\n  fs.readFile(fileB, function (err, data) {\n    // ...\n  })\n})\n```\n\n## 2. Promise\n\n为解决回调函数的不足，社区创造出 Promise。\n\n```js\nconst fs = require('fs')\n\nconst readFileWithPromise = file => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, (err, data) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(data)\n      }\n    })\n  })\n}\n\nreadFileWithPromise('/etc/passwd')\n  .then(data => {\n    console.log(data.toString())\n    return readFileWithPromise('/etc/profile')\n  })\n  .then(data => {\n    console.log(data.toString())\n  })\n  .catch(err => {\n    console.log(err)\n  })\n```\n\n简单的 Promise 实现，窥探下本质\n\nPromise 实际上是利用编程技巧将回调函数的横向加载，改成纵向加载，达到链式调用的效果，避免回调地狱。最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。\n\n## 3. async、await\n\n为了解决 Promise 的问题，async、await 在 ES8 中被提了出来，是目前为止最好的解决方案\n\n```js\nconst fs = require('fs')\nasync function readFile() {\n  try {    \n    var f1 = await readFileWithPromise('/etc/passwd')\n    console.log(f1.toString())\n    var f2 = await readFileWithPromise('/etc/profile')\n    console.log(f2.toString())\n  } catch (err) {\n    console.log(err)\n  }\n}\\\n```\n\nasync、await 函数写起来跟同步函数一样，条件是需要接收 Promise 或原始类型的值。异步编程的最终目标是转换成人类最容易理解的形式。\n\n# async、await\n\n分析 async、await 实现原理之前，先介绍下预备知识\n\n## 1. generator\n\ngenerator 函数是协程在 ES6 的实现。协程简单来说就是多个线程互相协作，完成异步任务。\n\n![image-1-1620701628067.png](https://static.ecool.fun//article/466ad367-1f3f-4f4c-8fa1-bd5dace7bbb7.jpeg)\n\n整个 generator 函数就是一个封装的异步任务，异步操作需要暂停的地方，都用 yield 语句注明。generator 函数的执行方法如下：\n\n```js\nfunction* gen(x) {\n  console.log('start')\n  const y = yield x * 2\n  return y\n}\n\nconst g = gen(1)\ng.next()   // start { value: 2, done: false }\ng.next(4)  // { value: 4, done: true }\n```\n\n* `gen()` 不会立即执行，而是一上来就暂停，返回一个 `Iterator` 对象（具体可以参考 [Iterator遍历器](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangfupeng1988%2Fjs-async-tutorial%2Fblob%2Fmaster%2Fpart4-generator%2F02-iterator.md \"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part4-generator/02-iterator.md\") ）\n* 每次 `g.next()` 都会打破暂停状态去执行，直到遇到下一个 `yield` 或者 `return`\n* 遇到 `yield` 时，会执行 `yield` 后面的表达式，并返回执行之后的值，然后再次进入暂停状态，此时 `done: false` 。\n* `next` 函数可以接受参数，作为上个阶段异步任务的返回结果，被函数体内的变量接收\n* 遇到 `return` 时，会返回值，执行结束，即 `done: true`\n* 每次 `g.next()` 的返回值永远都是 `{value: ... , done: ...}` 的形式\n\n## 2. thunk函数\n\nJavaScript 中的 thunk 函数（译为转换程序）简单来说就是把带有回调函数的多参数函数转换成只接收回调函数的单参数版本\n\n```js\nconst fs = require('fs')\nconst thunkify = fn => (...rest) => callback => fn(...rest, callback)\nconst thunk = thunkify(fs.readFile)\nconst readFileThunk = thunk('/etc/passwd', 'utf8')\nreadFileThunk((err, data) => {\n   // ...\n})\n```\n\n单纯的 thunk 函数并没有很大的用处， 大牛们想到了和 generator 结合：\n\n```js\nfunction* readFileThunkWithGen() {\n  try {\n    const content1 = yield readFileThunk('/etc/passwd', 'utf8')\n    console.log(content1)\n    const content2 = yield readFileThunk('/etc/profile', 'utf8')\n    console.log(content2)\n    return 'done'\n  } catch (err) {\n    console.error(err)\n    return 'fail'\n  }  \n}\n\nconst g = readFileThunkWithGen()\ng.next().value((err, data) => {\n  if (err) {\n    return g.throw(err).value\n  }\n  g.next(data.toString()).value((err, data) => {\n    if (err) {\n      return g.throw(err).value\n    }\n    g.next(data.toString())\n  })\n})\n```\n\nthunk 函数的真正作用是统一多参数函数的调用方式，在 next 调用时把控制权交还给 generator，使 generator 函数可以使用递归方式自启动流程\n\n```js\nconst run = generator => {\n  const g = generator()\n  const next = (err, ...rest) => {\n    if (err) {\n      return g.throw(err).value\n    }\n    const result = g.next(rest.length > 1 ? rest : rest[0])\n    if (result.done) {\n      return result.value\n    }\n    result.value(next)\n  }\n  next()\n}\nrun(readFileThunkWithGen)\n```\n\n有了自启动的加持之后，generator 函数内就可以写\"同步\"的代码了。generator 函数也可以与 Promise 结合：\n\n```js\nfunction* readFileWithGen() {\n  try {    \n    const content1 = yield readFileWithPromise('/etc/passwd', 'utf8')\n    console.log(content1)\n    const content2 = yield readFileWithPromise('/etc/profile', 'utf8')\n    console.log(content2)\n    return 'done'\n  } catch (err) {\n    console.error(err)\n    return 'fail'\n  }\n}\n\nconst run = generator => {\n  return new Promise((resolve, reject) => {\n    const g = generator()\n    const next = res => {\n      const result = g.next(res)\n      if (result.done) {\n        return resolve(result.value)\n      }\n      result.value\n        .then(\n          next,\n          err => reject(gen.throw(err).value)\n        )\n    }\n    next()\n  })\n}\n\nrun(readFileWithGen)\n  .then(res => console.log(res))\n  .catch(err => console.log(err))\n```\n\ngenerator 可以暂停执行，很容易让它和异步操作产生联系，因为我们在处理异步操作时，在等待的时候可以暂停当前任务，把程序控制权交还给其他程序，当异步任务有返回时，在回调中再把控制权交还给之前的任务。generator 实际上并没有改变 JavaScript 单线程、使用回调处理异步任务的本质。\n\n## 3. co 函数库\n\n每次执行 generator 函数时自己写启动器比较麻烦。 [co函数库](https://github.com/tj/co) 是一个 generator 函数的自启动执行器，使用条件是 generator 函数的 yield 命令后面，只能是 thunk 函数或 Promise 对象，co 函数执行完返回一个 Promise 对象。\n\n```js\nconst co = require('co')\nco(readFileWithGen).then(res => console.log(res)) // 'done'\nco(readFileThunkWithGen).then(res => console.log(res)) // 'done'\n```\n\nco 函数库的源码实现其实就是把上面两种情况做了综合:\n\n```js\n// 做了简化，与源码基本一致\nconst co = (generator, ...rest) => {\n  const ctx = this\n  return new Promise((resolve, reject) => {\n    const gen = generator.call(ctx, ...rest)\n    if (!gen || typeof gen.next !== 'function') {\n      return resolve(gen)\n    } \n    \n    const onFulfilled = res => {\n      let ret\n      try {\n        ret = gen.next(res)\n      } catch (e) {\n        return reject(e)\n      }\n      next(ret)\n    }    \n\n    const onRejected = err => {\n      let ret\n      try {\n        ret = gen.throw(err)\n      } catch (e) {\n        return reject(e)\n      }\n      next(ret)\n    }\n\n    const next = result => {\n      if (result.done) {\n        return resolve(result.value)\n      }\n      toPromise(result.value).then(onFulfilled, onRejected)\n    }\n\n    onFulfilled()\n  })  \n}\n\nconst toPromise = value => {\n  if (isPromise(value)) return value\n  if ('function' == typeof value) {\n    return new Promise((resolve, reject) => {\n      value((err, ...rest) => {\n        if (err) {\n          return reject(err)\n        }\n        resolve(rest.length > 1 ? rest : rest[0])\n      })\n    })\n  }\n}\n\n```\n\n## 4. 理解 async、await\n\n一句话，async、await 是 co 库的官方实现。也可以看作自带启动器的 generator 函数的语法糖。不同的是，async、await 只支持 Promise 和原始类型的值，不支持 thunk 函数。\n\n```js\n// generator with co\nco(function* () {\n  try {    \n    const content1 = yield readFileWithPromise('/etc/passwd', 'utf8')\n    console.log(content1)\n    const content2 = yield readFileWithPromise('/etc/profile', 'utf8')\n    console.log(content2)\n    return 'done'\n  } catch (err) {\n    console.error(err)\n    return 'fail'\n  }\n})\n\n// async await\nasync function readfile() {\n  try {\n    const content1 = await readFileWithPromise('/etc/passwd', 'utf8')\n    console.log(content1)\n    const content2 = await readFileWithPromise('/etc/profile', 'utf8')\n    console.log(content2)\n    return 'done'\n  } catch (err) {\n    throw(err)\n  }\n}\nreadfile().then(\n  res => console.log(res),\n  err => console.error(err)\n)\n```\n\n# 总结\n\n不论以上哪种方式，都没有改变 JavaScript 单线程、使用回调处理异步任务的本质。人类总是追求最简单易于理解的编程方式。\n",
    "level": 4,
    "status": 2,
    "appId": 7,
    "createAt": "2022-04-14T01:30:57.000Z",
    "updateAt": "2024-03-28T10:40:27.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 1,
    "prev": "",
    "next": "26e22fa9-becc-4552-b79a-da2f67451455"
  },
  "post": {
    "exerciseKey": "29821d8e-dc41-4581-91fe-9fde7658a559",
    "category": "QA",
    "title": "async、await 实现原理",
    "level": 4,
    "updateAt": "2024-03-28T10:40:27+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}
