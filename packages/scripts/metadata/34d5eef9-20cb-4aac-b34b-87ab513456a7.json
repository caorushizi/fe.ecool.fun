{
  "data": {
    "id": 184,
    "exerciseKey": "34d5eef9-20cb-4aac-b34b-87ab513456a7",
    "category": "QA",
    "renderType": "md",
    "title": "你是怎么理解ES6中 Promise的？使用场景有哪些？",
    "desc": null,
    "options": null,
    "explanation": "\n## 一、介绍\n\n`Promise `，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大\n\n在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码\n\n```js\ndoSomething(function(result) {\n  doSomethingElse(result, function(newResult) {\n    doThirdThing(newResult, function(finalResult) {\n      console.log('得到最终结果: ' + finalResult);\n    }, failureCallback);\n  }, failureCallback);\n}, failureCallback);\n```\n\n阅读上面代码，是不是很难受，上述形成了经典的回调地狱\n\n现在通过`Promise`的改写上面的代码\n\n```js\ndoSomething().then(function(result) {\n  return doSomethingElse(result);\n})\n.then(function(newResult) {\n  return doThirdThing(newResult);\n})\n.then(function(finalResult) {\n  console.log('得到最终结果: ' + finalResult);\n})\n.catch(failureCallback);\n```\n\n瞬间感受到`promise`解决异步操作的优点：\n\n- 链式操作减低了编码难度\n- 代码可读性明显增强\n\n\n\n下面我们正式来认识`promise`：\n\n### 状态\n\n`promise`对象仅有三种状态\n\n- `pending`（进行中）\n- `fulfilled`（已成功）\n- `rejected`（已失败）\n\n### 特点\n\n- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态\n- 一旦状态改变（从`pending`变为`fulfilled`和从`pending`变为`rejected`），就不会再变，任何时候都可以得到这个结果\n\n\n\n### 流程\n\n认真阅读下图，我们能够轻松了解`promise`整个流程\n\n ![](https://static.ecool.fun//article/f4d1e317-abd6-499d-8ea4-8680ef2901ba.png)\n\n\n\n## 二、用法\n\n`Promise`对象是一个构造函数，用来生成`Promise`实例\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`\n\n- `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”\n- `reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”\n\n\n\n### 实例方法\n\n`Promise`构建出来的实例存在以下方法：\n\n- then()\n- then()\n- catch()\n- finally()\n\n\n\n#### then()\n\n`then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数\n\n`then`方法返回的是一个新的`Promise`实例，也就是`promise`能链式书写的原因\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n\n\n#### catch\n\n`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数\n\n```javascript\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n`Promise `对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\n\n```javascript\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n```\n\n一般来说，使用`catch`方法代替`then()`第二个参数\n\n`Promise `对象抛出的错误不会传递到外层代码，即不会有任何反应\n\n```js\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n```\n\n浏览器运行到这一行，会打印出错误提示`ReferenceError: x is not defined`，但是不会退出进程\n\n`catch()`方法之中，还能再抛出错误，通过后面`catch`方法捕获到\n\n\n\n#### finally()\n\n`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\n\n```javascript\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n\n\n### 构造函数方法\n\n`Promise`构造函数存在以下方法：\n\n- all()\n- race()\n- allSettled()\n- resolve()\n- reject()\n- try()\n\n\n\n### all()\n\n`Promise.all()`方法用于将多个 `Promise `实例，包装成一个新的 `Promise `实例\n\n```javascript\nconst p = Promise.all([p1, p2, p3]);\n```\n\n接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例\n\n实例`p`的状态由`p1`、`p2`、`p3`决定，分为两种：\n\n- 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数\n- 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数\n\n注意，如果作为参数的 `Promise` 实例，自己定义了`catch`方法，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n```\n\n如果`p2`没有自己的`catch`方法，就会调用`Promise.all()`的`catch`方法\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n```\n\n\n\n### race()\n\n`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\n\n```javascript\nconst p = Promise.race([p1, p2, p3]);\n```\n\n只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变\n\n率先改变的 Promise 实例的返回值则传递给`p`的回调函数\n\n```javascript\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n\n\n\n### allSettled()\n\n`Promise.allSettled()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例\n\n只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束\n\n```javascript\nconst promises = [\n  fetch('/api-1'),\n  fetch('/api-2'),\n  fetch('/api-3'),\n];\n\nawait Promise.allSettled(promises);\nremoveLoadingIndicator();\n```\n\n\n\n#### resolve()\n\n将现有对象转为 `Promise `对象\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n\n参数可以分成四种情况，分别如下：\n\n- 参数是一个 Promise 实例，`promise.resolve`将不做任何修改、原封不动地返回这个实例\n- 参数是一个`thenable`对象，`promise.resolve`会将这个对象转为 `Promise `对象，然后就立即执行`thenable`对象的`then()`方法\n- 参数不是具有`then()`方法的对象，或根本就不是对象，`Promise.resolve()`会返回一个新的 Promise 对象，状态为`resolved`\n- 没有参数时，直接返回一个`resolved`状态的 Promise 对象\n\n\n\n#### reject()\n\n`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`\n\n```javascript\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n`Promise.reject()`方法的参数，会原封不动地变成后续方法的参数\n\n```javascript\nPromise.reject('出错了')\n.catch(e => {\n  console.log(e === '出错了')\n})\n// true\n```\n\n\n\n## 三、使用场景\n\n将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化\n\n```javascript\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n```\n\n通过链式操作，将多个渲染数据分别给个`then`，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题\n\n```js\n// 各司其职\ngetInfo().then(res=>{\n    let { bannerList } = res\n    //渲染轮播图\n    console.log(bannerList)\n    return res\n}).then(res=>{\n    \n    let { storeList } = res\n    //渲染店铺列表\n    console.log(storeList)\n    return res\n}).then(res=>{\n    let { categoryList } = res\n    console.log(categoryList)\n    //渲染分类列表\n    return res\n})\n```\n\n通过`all()`实现多个请求合并在一起，汇总所有请求结果，只需设置一个`loading`即可\n\n```js\nfunction initLoad(){\n    // loading.show() //加载loading\n    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>{\n        console.log(res)\n        loading.hide() //关闭loading\n    }).catch(err=>{\n        console.log(err)\n        loading.hide()//关闭loading\n    })\n}\n//数据初始化    \ninitLoad()\n```\n\n通过`race`可以设置图片请求超时\n\n```js\n//请求某个图片资源\nfunction requestImg(){\n    var p = new Promise(function(resolve, reject){\n        var img = new Image();\n        img.onload = function(){\n           resolve(img);\n        }\n        //img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\"; 正确的\n        img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1\";\n    });\n    return p;\n}\n\n//延时函数，用于给请求计时\nfunction timeout(){\n    var p = new Promise(function(resolve, reject){\n        setTimeout(function(){\n            reject('图片请求超时');\n        }, 5000);\n    });\n    return p;\n}\n\nPromise\n.race([requestImg(), timeout()])\n.then(function(results){\n    console.log(results);\n})\n.catch(function(reason){\n    console.log(reason);\n});\n```",
    "pivot": "",
    "vipLimit": 0,
    "level": 3,
    "appId": 7,
    "createAt": "2021-07-03T13:37:00.000Z",
    "updateAt": "2024-08-10T17:04:27.000Z",
    "isCollected": false,
    "currentIndex": 1315,
    "filterTotalNum": 1487,
    "prev": "6b4f3ad8-5cd8-49f3-941c-c916615546d0",
    "next": "4232c372-316f-4a53-99b9-6d9299b7e91f"
  },
  "post": {
    "exerciseKey": "34d5eef9-20cb-4aac-b34b-87ab513456a7",
    "category": "QA",
    "title": "你是怎么理解ES6中 Promise的？使用场景有哪些？",
    "level": 3,
    "createAt": "2021-07-03T13:37:00+00:00",
    "updateAt": "2024-08-10T17:04:27+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 379
  }
}