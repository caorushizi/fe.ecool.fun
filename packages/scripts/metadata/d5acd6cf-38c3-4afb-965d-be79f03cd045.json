{
  "data": {
    "id": 243,
    "exerciseKey": "d5acd6cf-38c3-4afb-965d-be79f03cd045",
    "category": "QA",
    "renderType": "md",
    "title": "什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路",
    "desc": null,
    "options": null,
    "explanation": "## 一、什么是虚拟DOM\n\n虚拟 DOM （`Virtual DOM` ）这个概念相信大家都不陌生，从 `React` 到 `Vue` ，虚拟 `DOM` 为这两个框架都带来了跨平台的能力（`React-Native` 和 `Weex`）\n\n实际上它只是一层对真实`DOM`的抽象，以`JavaScript` 对象 (`VNode` 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上\n\n在`Javascript`对象中，虚拟`DOM` 表现为一个 `Object `对象。并且最少包含标签名 (`tag`)、属性 (`attrs`) 和子元素对象 (`children`) 三个属性，不同框架对这三个属性的名命可能会有差别\n\n创建虚拟`DOM`就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟`DOM`对象的节点与真实`DOM`的属性一一照应\n\n在`vue`中同样使用到了虚拟`DOM`技术\n\n定义真实`DOM`\n\n```html\n<div id=\"app\">\n    <p class=\"p\">节点内容</p>\n    <h3>{{ foo }}</h3>\n</div>\n```\n\n实例化`vue`\n\n```js\nconst app = new Vue({\n    el:\"#app\",\n    data:{\n        foo:\"foo\"\n    }\n})\n```\n\n观察`render`的`render`，我们能得到虚拟`DOM`\n\n```js\n(function anonymous(\n) {\n\twith(this){return _c('div',{attrs:{\"id\":\"app\"}},[_c('p',{staticClass:\"p\"},\n\t\t\t\t\t  [_v(\"节点内容\")]),_v(\" \"),_c('h3',[_v(_s(foo))])])}})\n```\n\n通过`VNode`，`vue`可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过`diff`算法得出一些需要修改的最小单位,再更新视图，减少了`dom`操作，提高了性能\n\n## 二、为什么需要虚拟DOM\n\n`DOM`是很慢的，其元素非常庞大，页面的性能问题，大部分都是由`DOM`操作引起的\n\n真实的`DOM`节点，哪怕一个最简单的`div`也包含着很多属性，可以打印出来直观感受一下：\n ![](https://static.ecool.fun//article/2967524b-26f4-44a1-ae01-818bd4283f23.png)\n\n由此可见，操作`DOM`的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验\n\n**举个例子：**\n\n你用传统的原生`api`或`jQuery`去操作`DOM`时，浏览器会从构建`DOM`树开始从头到尾执行一遍流程\n\n当你在一次操作时，需要更新10个`DOM`节点，浏览器没这么智能，收到第一个更新`DOM`请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程\n\n而通过`VNode`，同样更新10个`DOM`节点，虚拟`DOM`不会立即操作`DOM`，而是将这10次更新的`diff`内容保存到本地的一个`js`对象中，最终将这个`js`对象一次性`attach`到`DOM`树上，避免大量的无谓计算\n\n> 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI\n\n\n## 三、如何实现虚拟DOM\n\n首先可以看看`vue`中`VNode`的结构\n\n源码位置：src/core/vdom/vnode.js\n\n```js\nexport default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array<VNode>;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component's scope\n  functionalContext: Component | void; // only for functional component root nodes\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions\n  ) {\n    /*当前节点的标签名*/\n    this.tag = tag\n    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/\n    this.data = data\n    /*当前节点的子节点，是一个数组*/\n    this.children = children\n    /*当前节点的文本*/\n    this.text = text\n    /*当前虚拟节点对应的真实dom节点*/\n    this.elm = elm\n    /*当前节点的名字空间*/\n    this.ns = undefined\n    /*编译作用域*/\n    this.context = context\n    /*函数化组件作用域*/\n    this.functionalContext = undefined\n    /*节点的key属性，被当作节点的标志，用以优化*/\n    this.key = data && data.key\n    /*组件的option选项*/\n    this.componentOptions = componentOptions\n    /*当前节点对应的组件的实例*/\n    this.componentInstance = undefined\n    /*当前节点的父节点*/\n    this.parent = undefined\n    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/\n    this.raw = false\n    /*静态节点标志*/\n    this.isStatic = false\n    /*是否作为跟节点插入*/\n    this.isRootInsert = true\n    /*是否为注释节点*/\n    this.isComment = false\n    /*是否为克隆节点*/\n    this.isCloned = false\n    /*是否有v-once指令*/\n    this.isOnce = false\n  }\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next https://github.com/answershuto/learnVue*/\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\n这里对`VNode`进行稍微的说明：\n\n- 所有对象的 `context` 选项都指向了 `Vue` 实例\n- `elm` 属性则指向了其相对应的真实 `DOM` 节点\n\n`vue`是通过`createElement`生成`VNode`\n\n源码位置：src/core/vdom/create-element.js\n\n```js\nexport function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode | Array<VNode> {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n```\n\n上面可以看到`createElement` 方法实际上是对 `_createElement` 方法的封装，对参数的传入进行了判断\n\n```javascript\nexport function _createElement(\n    context: Component,\n    tag?: string | Class<Component> | Function | Object,\n    data?: VNodeData,\n    children?: any,\n    normalizationType?: number\n): VNode | Array<VNode> {\n    if (isDef(data) && isDef((data: any).__ob__)) {\n        process.env.NODE_ENV !== 'production' && warn(\n            `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n            'Always create fresh vnode data objects in each render!',\n            context`\n        )\n        return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n        tag = data.is\n    }\n    if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode()\n    }\n    ... \n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n        typeof children[0] === 'function'\n    ) {\n        data = data || {}\n        data.scopedSlots = { default: children[0] }\n        children.length = 0\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children)\n    } else if ( === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children)\n    }\n\t// 创建VNode\n    ...\n}\n```\n\n可以看到`_createElement`接收5个参数：\n\n- `context` 表示 `VNode` 的上下文环境，是 `Component` 类型\n- tag 表示标签，它可以是一个字符串，也可以是一个 `Component`\n\n- `data` 表示 `VNode` 的数据，它是一个 `VNodeData` 类型\n\n- `children` 表示当前 `VNode `的子节点，它是任意类型的\n\n- `normalizationType` 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 `render` 函数是编译生成的还是用户手写的\n\n根据`normalizationType` 的类型，`children`会有不同的定义\n\n```js\nif (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n} else if ( === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n}\n```\n\n`simpleNormalizeChildren`方法调用场景是 `render` 函数是编译生成的\n\n`normalizeChildren`方法调用场景分为下面两种：\n\n-  `render` 函数是用户手写的\n- 编译 `slot`、`v-for` 的时候会产生嵌套数组\n\n无论是`simpleNormalizeChildren`还是`normalizeChildren`都是对`children`进行规范（使`children` 变成了一个类型为 `VNode` 的 `Array`），这里就不展开说了\n\n规范化`children`的源码位置在：src/core/vdom/helpers/normalzie-children.js\n\n在规范化`children`后，就去创建`VNode`\n\n```js\nlet vnode, ns\n// 对tag进行判断\nif (typeof tag === 'string') {\n  let Ctor\n  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n  if (config.isReservedTag(tag)) {\n    // 如果是内置的节点，则直接创建一个普通VNode\n    vnode = new VNode(\n      config.parsePlatformTagName(tag), data, children,\n      undefined, undefined, context\n    )\n  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n    // component\n    // 如果是component类型，则会通过createComponent创建VNode节点\n    vnode = createComponent(Ctor, data, context, children, tag)\n  } else {\n    vnode = new VNode(\n      tag, data, children,\n      undefined, undefined, context\n    )\n  }\n} else {\n  // direct component options / constructor\n  vnode = createComponent(tag, data, context, children)\n}\n```\n\n`createComponent`同样是创建`VNode`\n\n源码位置：src/core/vdom/create-component.js\n\n```js\nexport function createComponent (\n  Ctor: Class<Component> | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array<VNode>,\n  tag?: string\n): VNode | Array<VNode> | void {\n  if (isUndef(Ctor)) {\n    return\n  }\n // 构建子类构造函数 \n  const baseCtor = context.$options._base\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor)\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(`Invalid Component definition: ${String(Ctor)}`, context)\n    }\n    return\n  }\n\n  // async component\n  let asyncFactory\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)\n    if (Ctor === undefined) {\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {}\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor)\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data)\n  }\n\n  // extract props\n  const propsData = extractPropsFromVNodeData(data, Ctor, tag)\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  const listeners = data.on\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn\n\n  if (isTrue(Ctor.options.abstract)) {\n    const slot = data.slot\n    data = {}\n    if (slot) {\n      data.slot = slot\n    }\n  }\n\n  // 安装组件钩子函数，把钩子函数合并到data.hook中\n  installComponentHooks(data)\n\n  //实例化一个VNode返回。组件的VNode是没有children的\n  const name = Ctor.options.name || tag\n  const vnode = new VNode(\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n    data, undefined, undefined, undefined, context,\n    { Ctor, propsData, listeners, tag, children },\n    asyncFactory\n  )\n  if (__WEEX__ && isRecyclableComponent(vnode)) {\n    return renderRecyclableComponentTemplate(vnode)\n  }\n\n  return vnode\n}\n```\n\n稍微提下`createComponent`生成`VNode`的三个关键流程：\n\n- 构造子类构造函数`Ctor `\n- `installComponentHooks`安装组件钩子函数\n- 实例化 `vnode`\n\n### 小结\n\n`createElement` 创建 `VNode` 的过程，每个 `VNode` 有 `children`，`children` 每个元素也是一个`VNode`，这样就形成了一个虚拟树结构，用于描述真实的`DOM`树结构\n",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-04T03:44:23.000Z",
    "updateAt": "2024-01-25T14:37:27.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 129,
    "prev": "7d27dc57-5d95-4e3f-88a7-eb685b7c21e4",
    "next": "7cefdb7e-8b8a-429f-be44-45b346de6f3f"
  },
  "post": {
    "exerciseKey": "d5acd6cf-38c3-4afb-965d-be79f03cd045",
    "category": "QA",
    "title": "什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路",
    "level": 3.5,
    "updateAt": "2024-01-25T14:37:27+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 68
  }
}
