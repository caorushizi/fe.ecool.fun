{
  "data": {
    "id": 227,
    "exerciseKey": "41132096-4901-45d1-a453-6119931a083e",
    "category": "QA",
    "renderType": "md",
    "title": "Vue实例挂载的过程中发生了什么？",
    "desc": null,
    "options": null,
    "explanation": "## 一、思考\n\n我们都听过知其然知其所以然这句话\n\n那么不知道大家是否思考过`new Vue()`这个过程中究竟做了些什么？\n\n过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等\n\n## 一、分析\n\n首先找到`vue`的构造函数\n\n源码位置：src\\core\\instance\\index.js\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n`options`是用户传递过来的配置项，如`data、methods`等常用的方法\n\n`vue`构建函数调用`_init`方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法\n\n```js\ninitMixin(Vue);     // 定义 _init\nstateMixin(Vue);    // 定义 $set $get $delete $watch 等\neventsMixin(Vue);   // 定义事件  $on  $once $off $emit\nlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy\nrenderMixin(Vue);   // 定义 _render 返回虚拟dom\n```\n\n首先可以看`initMixin`方法，发现该方法在`Vue`原型上定义了`_init`方法\n\n源码位置：src\\core\\instance\\init.js\n\n```js\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else { // 合并vue属性\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      // 初始化proxy拦截器\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    // 初始化组件生命周期标志位\n    initLifecycle(vm)\n    // 初始化组件事件侦听\n    initEvents(vm)\n    // 初始化渲染方法\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    // 初始化依赖注入内容，在初始化data、props之前\n    initInjections(vm) // resolve injections before data/props\n    // 初始化props/data/method/watch/methods\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n    // 挂载元素\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n仔细阅读上面的代码，我们得到以下结论：\n\n- 在调用`beforeCreate`之前，数据初始化并未完成，像`data`、`props`这些属性无法访问到\n\n- 到了`created`的时候，数据已经初始化完成，能够访问`data`、`props`这些属性，但这时候并未完成`dom`的挂载，因此无法访问到`dom`元素\n- 挂载方法是调用`vm.$mount`方法\n\n`initState`方法是完成`props/data/method/watch/methods`的初始化\n\n源码位置：src\\core\\instance\\state.js\n\n```js\nexport function initState (vm: Component) {\n  // 初始化组件的watcher列表\n  vm._watchers = []\n  const opts = vm.$options\n  // 初始化props\n  if (opts.props) initProps(vm, opts.props)\n  // 初始化methods方法\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    // 初始化data  \n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\n\n我们和这里主要看初始化`data`的方法为`initData`，它与`initState`在同一文件上\n\n```js\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  // 获取到组件上的data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      // 属性名不能与方法名重复\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    // 属性名不能与state名称重复\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) { // 验证key值的合法性\n      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  // 响应式监听data是数据的变化\n  observe(data, true /* asRootData */)\n}\n```\n\n仔细阅读上面的代码，我们可以得到以下结论：\n\n- 初始化顺序：`props`、`methods`、`data`\n\n- `data`定义的时候可选择函数形式或者对象形式（组件只能为函数形式）\n\n关于数据响应式在这就不展开详细说明\n\n上文提到挂载方法是调用`vm.$mount`方法\n\n源码位置：\n\n```js\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 获取或查询元素\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  // vue 不允许直接挂载到body或页面文档上\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    // 存在template模板，解析vue模板文件\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      // 通过选择器获取元素内容\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n      /**\n       *  1.将temmplate解析ast tree\n       *  2.将ast tree转换成render语法字符串\n       *  3.生成render方法\n       */\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n```\n\n阅读上面代码，我们能得到以下结论：\n\n- 不要将根元素放到`body`或者`html`上\n\n- 可以在对象中定义`template/render`或者直接使用`template`、`el`表示元素选择器\n\n- 最终都会解析成`render`函数，调用`compileToFunctions`，会将`template`解析成`render`函数\n\n对`template`的解析步骤大致分为以下几步：\n\n- 将`html`文档片段解析成`ast`描述符\n\n- 将`ast`描述符解析成字符串\n\n- 生成`render`函数\n\n\n\n生成`render`函数，挂载到`vm`上后，会再次调用`mount`方法\n\n源码位置：src\\platforms\\web\\runtime\\index.js\n\n```js\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  // 渲染组件\n  return mountComponent(this, el, hydrating)\n}\n```\n\n调用`mountComponent`渲染组件\n\n```js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  // 如果没有获取解析的render函数，则会抛出警告\n  // render是解析模板文件生成的\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        // 没有获取到vue的模板文件\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  // 执行beforeMount钩子\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    // 定义更新函数\n    updateComponent = () => {\n      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render\n      vm._update(vm._render(), hydrating)\n    }\n  }\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  // 监听当前组件状态，当有数据变化时，更新组件\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        // 数据更新引发的组件更新\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n阅读上面代码，我们得到以下结论：\n\n- 会触发`boforeCreate`钩子\n- 定义`updateComponent`渲染页面视图的方法\n- 监听组件数据，一旦发生变化，触发`beforeUpdate`生命钩子\n\n`updateComponent`方法主要执行在`vue`初始化时声明的`render`，`update`方法\n\n`render`的作用主要是生成`vnode`\n\n源码位置：src\\core\\instance\\render.js\n\n```js\n// 定义vue 原型上的render方法\nVue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // render函数来自于组件的option\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n            _parentVnode.data.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n        )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm\n        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode\n        vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n        handleError(e, vm, `render`)\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n            try {\n                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n            } catch (e) {\n                handleError(e, vm, `renderError`)\n                vnode = vm._vnode\n            }\n        } else {\n            vnode = vm._vnode\n        }\n    } finally {\n        currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n        if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n            warn(\n                'Multiple root nodes returned from render function. Render function ' +\n                'should return a single root node.',\n                vm\n            )\n        }\n        vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n}\n```\n\n`_update`主要功能是调用`patch`，将`vnode`转换为真实`DOM`，并且更新到页面中\n\n源码位置：src\\core\\instance\\lifecycle.js\n\n```js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    // 设置当前激活的作用域\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      // 执行具体的挂载逻辑\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    restoreActiveInstance()\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  }\n```\n\n\n\n## 三、结论\n\n- `new Vue`的时候调用会调用`_init`方法\n  - 定义 `$set`、` $get` 、`$delete`、`$watch` 等方法\n  - 定义 `$on`、`$off`、`$emit`、`$off `等事件\n  - 定义 `_update`、`$forceUpdate`、`$destroy`生命周期\n\n- 调用`$mount`进行页面的挂载\n- 挂载的时候主要是通过`mountComponent`方法\n- 定义`updateComponent`更新函数\n- 执行`render`生成虚拟`DOM`\n- `_update`将虚拟`DOM`生成真实`DOM`结构，并且渲染到页面中\n\n\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 2,
    "appId": 7,
    "createAt": "2021-07-04T03:31:18.000Z",
    "updateAt": "2024-08-10T17:04:38.000Z",
    "isCollected": false,
    "currentIndex": 1272,
    "filterTotalNum": 1487,
    "prev": "cf1e843f-9005-42dc-b204-194dd3d1fc42",
    "next": "db22b09c-fdbb-4a6c-8fdd-2ad65bb11846"
  },
  "post": {
    "exerciseKey": "41132096-4901-45d1-a453-6119931a083e",
    "category": "QA",
    "title": "Vue实例挂载的过程中发生了什么？",
    "level": 2,
    "createAt": "2021-07-04T03:31:18+00:00",
    "updateAt": "2024-08-10T17:04:38+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 97
  }
}