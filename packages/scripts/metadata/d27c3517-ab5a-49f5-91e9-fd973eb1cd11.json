{
  "data": {
    "id": 1940,
    "exerciseKey": "d27c3517-ab5a-49f5-91e9-fd973eb1cd11",
    "category": "QA",
    "renderType": "md",
    "title": "react 中怎么捕获异常？",
    "desc": null,
    "options": null,
    "explanation": "## ErrorBoundary   \n\n`EerrorBoundary` 是16版本出来的，之前的 15 版本有`unstable_handleError`。    \n\n关于 `ErrorBoundary` 官网介绍比较详细，它能捕捉以下异常：\n\n* 子组件的渲染\n* 生命周期函数\n* 构造函数\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error, info) {\n    // Display fallback UI\n    this.setState({ hasError: true });\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n可以考虑直接使用开源库：[react-error-boundary](https://www.npmjs.com/package/react-error-boundary)，对开发者来说，只需要关心出现错误后的处理。\n\n```js\nimport {ErrorBoundary} from 'react-error-boundary'\n\nfunction ErrorFallback({error, resetErrorBoundary}) {\n  return (\n    <div role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  )\n}\n\nconst ui = (\n  <ErrorBoundary\n    FallbackComponent={ErrorFallback}\n    onReset={() => {\n      // reset the state of your app so the error doesn't happen again\n    }}\n  >\n    <ComponentThatMayError />\n  </ErrorBoundary>\n)\n```\n\n遗憾的是，`error boundaries` 并不会捕捉这些错误：\n\n* 事件处理程序\n* 异步代码 (e.g. setTimeout or requestAnimationFrame callbacks)\n* 服务端的渲染代码\n* error boundaries自己抛出的错误\n\n原文可见参见官网[introducing-error-boundaries](https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries)\n\n其实官方也有解决方案：[how-about-event-handlers](https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers)， 就是 try catch.    \n\n```js\n  handleClick() {\n    try {\n      // Do something that could throw\n    } catch (error) {\n      this.setState({ error });\n    }\n  }\n```\n\n## Error Boundary 之外\n\n我们先看看一张表格，罗列了我们能捕获异常的手段和范围。\n\n| 异常类型                | 同步方法 | 异步方法 | 资源加载 | Promise |  async/await    \n| ---                    | :---:   |:---:    |:---:    |:---:    |:---: |\n| try/catch              | √       |         |         |         |     √|\n| window.onerror         | √       | √       |         |         |      |\n| error             | √       | √       | √       |         |      |\n| unhandledrejection |         |         |         |√        | √    |\n\n ### try/catch\n \n 可以捕获同步和async/await的异常。 \n \n ### window.onerror , error事件 \n \n ```js\n     window.addEventListener('error', this.onError, true);\n     window.onerror = this.onError\n ```\n `window.addEventListener('error')` 这种可以比 `window.onerror` 多捕获资源记载异常.\n \n 请注意最后一个参数是 `true`, `false`的话可能就不如你期望。   \n \n 当然你如果问题这第三个参数的含义，我就有点不想理你了。拜。\n \n ### unhandledrejection\n \n 请注意最后一个参数是 `true`。\n \n ```js\n window.removeEventListener('unhandledrejection', this.onReject, true)\n ```\n \n其捕获未被捕获的Promise的异常。\n\n### XMLHttpRequest 与 fetch\n\n`XMLHttpRequest` 很好处理，自己有onerror事件。\n\n当然你99.99%也不会自己基于`XMLHttpRequest`封装一个库， `axios` 真香，有这完毕的错误处理机制。\n\n至于`fetch`, 自己带着catch跑，不处理就是你自己的问题了。\n\n其实有一个库 [react-error-catch](https://www.npmjs.com/package/react-error-catch) 是基于ErrorBoudary,error与unhandledrejection封装的一个组件。  \n\n其核心如下\n\n```js\n   ErrorBoundary.prototype.componentDidMount = function () {\n        // event catch\n        window.addEventListener('error', this.catchError, true);\n        // async code\n        window.addEventListener('unhandledrejection', this.catchRejectEvent, true);\n    };\n```\n\n使用：\n\n```js\nimport ErrorCatch from 'react-error-catch'\n\nconst App = () => {\n  return (\n  <ErrorCatch\n      app=\"react-catch\"\n      user=\"cxyuns\"\n      delay={5000}\n      max={1}\n      filters={[]}\n      onCatch={(errors) => {\n        console.log('报错咯');\n        // 上报异常信息到后端，动态创建标签方式\n        new Image().src = `http://localhost:3000/log/report?info=${JSON.stringify(errors)}`\n      }}\n    >\n      <Main />\n    </ErrorCatch>)\n}\n\nexport default \n```\n\n利用error捕获的错误，其最主要的是提供了错误堆栈信息，对于分析错误相当不友好，尤其打包之后。\n\n## 事件处理程序的异常捕获\n\n### 示例\n\n使用[decorator](http://es6.ruanyifeng.com/#docs/decorator)来重写原来的方法。\n\n先看一下使用：\n\n```js\n\n   @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n        \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       Toast.success(\"创建订单成功\");\n    }\n```\n\n注意四个参数：\n* message： 出现错误时，打印的错误\n* toast： 出现错误，是否Toast\n* report: 出现错误，是否上报\n* log: 使用使用console.error打印\n\n再看一段代码\n\n```js\n  @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n       \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       throw new CatchError(\"创建订单失败了，请联系管理员\", {\n           toast: true,\n           report: true,\n           log: false\n       })\n       \n       Toast.success(\"创建订单成功\");\n\n    }\n```\n\n是都，没错，你可以通过抛出 自定义的`CatchError`来覆盖之前的默认选项。  \n\n这个`methodCatch`可以捕获，同步和异步的错误，我们来一起看看全部的代码。\n\n### 类型定义\n```typescript\nexport interface CatchOptions {\n    report?: boolean;\n    message?: string;\n    log?: boolean;\n    toast?: boolean;\n}\n\n// 这里写到 const.ts更合理\nexport const DEFAULT_ERROR_CATCH_OPTIONS: CatchOptions = {\n    report: true,\n    message: \"未知异常\",\n    log: true,\n    toast: false\n}\n```\n### 自定义的CatchError\n```typescript\nimport { CatchOptions, DEFAULT_ERROR_CATCH_OPTIONS } from \"@typess/errorCatch\";\n\nexport class CatchError extends Error {\n\n    public __type__ = \"__CATCH_ERROR__\";\n    /**\n     * 捕捉到的错误\n     * @param message 消息\n     * @options 其他参数\n     */\n    constructor(message: string, public options: CatchOptions = DEFAULT_ERROR_CATCH_OPTIONS) {\n        super(message);\n    }\n}\n\n```\n\n### 装饰器\n```typescript\nimport Toast from \"@components/Toast\";\nimport { CatchOptions, DEFAULT_ERROR_CATCH_OPTIONS } from \"@typess/errorCatch\";\nimport { CatchError } from \"@util/error/CatchError\";\n\n\nconst W_TYPES = [\"string\", \"object\"];\nexport function methodCatch(options: string | CatchOptions = DEFAULT_ERROR_CATCH_OPTIONS) {\n\n    const type = typeof options;\n\n    let opt: CatchOptions;\n\n    \n    if (options == null || !W_TYPES.includes(type)) { // null 或者 不是字符串或者对象\n        opt = DEFAULT_ERROR_CATCH_OPTIONS;\n    } else if (typeof options === \"string\") {  // 字符串\n        opt = {\n            ...DEFAULT_ERROR_CATCH_OPTIONS,\n            message: options || DEFAULT_ERROR_CATCH_OPTIONS.message,\n        }\n    } else { // 有效的对象\n        opt = { ...DEFAULT_ERROR_CATCH_OPTIONS, ...options }\n    }\n\n    return function (_target: any, _name: string, descriptor: PropertyDescriptor): any {\n\n        const oldFn = descriptor.value;\n\n        Object.defineProperty(descriptor, \"value\", {\n            get() {\n                async function proxy(...args: any[]) {\n                    try {\n                        const res = await oldFn.apply(this, args);\n                        return res;\n                    } catch (err) {\n                        // if (err instanceof CatchError) {\n                        if(err.__type__ == \"__CATCH_ERROR__\"){\n                            err = err as CatchError;\n                            const mOpt = { ...opt, ...(err.options || {}) };\n\n                            if (mOpt.log) {\n                                console.error(\"asyncMethodCatch:\", mOpt.message || err.message , err);\n                            }\n\n                            if (mOpt.report) {\n                                // TODO::\n                            }\n\n                            if (mOpt.toast) {\n                                Toast.error(mOpt.message);\n                            }\n\n                        } else {\n                            \n                            const message = err.message || opt.message;\n                            console.error(\"asyncMethodCatch:\", message, err);\n\n                            if (opt.toast) {\n                                Toast.error(message);\n                            }\n                        }\n                    }\n                }\n                proxy._bound = true;\n                return proxy;\n            }\n        })\n        return descriptor;\n    }\n}\n```\n\n## 总结一下\n\n1. 利用装饰器重写原方法，达到捕获错误的目的\n2. 自定义错误类，抛出它，就能达到覆盖默认选项的目的。增加了灵活性。\n\n```js\n  @methodCatch({ message: \"创建订单失败\", toast: true, report:true, log:true })\n    async createOrder() {\n        const data = {...};\n        const res = await createOrder();\n        if (!res || res.errCode !== 0) {\n            return Toast.error(\"创建订单失败\");\n        }\n       Toast.success(\"创建订单成功\");\n       \n        .......\n        其他可能产生异常的代码\n        .......\n        \n       throw new CatchError(\"创建订单失败了，请联系管理员\", {\n           toast: true,\n           report: true,\n           log: false\n       })\n    }\n```\n\n## 下一步\n\n1. 扩大成果，支持更多类型，以及hooks版本。\n\n```typescript\n\n@XXXCatch\nclasss AAA{\n    @YYYCatch\n    method = ()=> {\n    }\n}\n```\n2. 抽象，再抽象，再抽象\n\n**当前方案存在的问题:**   \n1. 功能局限\n2. 抽象不够    \n    获取选项,代理函数, 错误处理函数完全可以分离，变成通用方法。\n3. 同步方法经过转换后会变为异步方法。     \n    所以理论上，要区分同步和异步方案。\n4. 错误处理函数再异常怎么办\n\n之后，我们会围绕着这些问题，继续展开。\n\n\n## Hooks版本\n\nHook的名字就叫useCatch\n\n```typescript\n\nconst TestView: React.FC<Props> = function (props) {\n\n    const [count, setCount] = useState(0);\n\n    \n    const doSomething  = useCatch(async function(){\n        console.log(\"doSomething: begin\");\n        throw new CatchError(\"doSomething error\")\n        console.log(\"doSomething: end\");\n    }, [], {\n        toast: true\n    })\n\n    const onClick = useCatch(async (ev) => {\n        console.log(ev.target);\n        setCount(count + 1);\n\n        doSomething();\n\n        const d = delay(3000, () => {\n            setCount(count => count + 1);\n            console.log()\n        });\n        console.log(\"delay begin:\", Date.now())\n\n        await d.run();\n        \n        console.log(\"delay end:\", Date.now())\n        console.log(\"TestView\", this)\n        throw new CatchError(\"自定义的异常，你知道不\")\n    },\n        [count],\n        {\n            message: \"I am so sorry\",\n            toast: true\n        });\n\n    return <div>\n        <div><button onClick={onClick}>点我</button></div>\n        <div>{count}</div>\n    </div>\n}\n\nexport default React.memo(TestView);\n```\n\n至于思路，基于`useMemo`,可以先看一下代码：\n\n```typescript\nexport function useCatch<T extends (...args: any[]) => any>(callback: T, deps: DependencyList, options: CatchOptions =DEFAULT_ERRPR_CATCH_OPTIONS): T {    \n\n    const opt =  useMemo( ()=> getOptions(options), [options]);\n    \n    const fn = useMemo((..._args: any[]) => {\n        const proxy = observerHandler(callback, undefined, function (error: Error) {\n            commonErrorHandler(error, opt)\n        });\n        return proxy;\n\n    }, [callback, deps, opt]) as T;\n\n    return fn;\n}\n\n```",
    "pivot": "",
    "vipLimit": 0,
    "level": 3,
    "appId": 7,
    "createAt": "2023-02-19T07:36:21.000Z",
    "updateAt": "2024-08-10T17:07:08.000Z",
    "isCollected": false,
    "currentIndex": 449,
    "filterTotalNum": 1487,
    "prev": "d66f9477-309f-4af7-b667-d39ad3525a5b",
    "next": "b68ef5ec-9d4c-4702-b7f7-33917340b6eb"
  },
  "post": {
    "exerciseKey": "d27c3517-ab5a-49f5-91e9-fd973eb1cd11",
    "category": "QA",
    "title": "react 中怎么捕获异常？",
    "level": 3,
    "createAt": "2023-02-19T07:36:21+00:00",
    "updateAt": "2024-08-10T17:07:08+00:00"
  },
  "tag": {
    "id": 13,
    "tagName": "React.js",
    "type": "1",
    "exerciseCount": 129
  }
}