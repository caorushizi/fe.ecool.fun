{
  "data": {
    "id": 244,
    "exerciseKey": "7d27dc57-5d95-4e3f-88a7-eb685b7c21e4",
    "category": "QA",
    "renderType": "md",
    "title": "说说vue中的diff算法",
    "desc": null,
    "options": null,
    "explanation": "## 一、是什么\n\n`diff` 算法是一种通过同层的树节点进行比较的高效算法\n\n其有两个特点：\n- 比较只会在同层级进行, 不会跨层级比较\n- 在diff比较的过程中，循环从两边向中间比较\n\n`diff` 算法的在很多场景下都有应用，在 `vue` 中，作用于虚拟 `dom` 渲染成真实 `dom` 的新旧 `VNode` 节点比较\n\n## 二、比较方式\n\n`diff`整体策略为：深度优先，同层比较\n\n1. 比较只会在同层级进行, 不会跨层级比较\n\n![](https://static.ecool.fun//article/6366ea3c-b5f9-4add-a1d9-8fb1e7b6c726.png)\n\n2. 比较的过程中，循环从两边向中间收拢\n\n![](https://static.ecool.fun//article/66a1b47c-6fd5-4a1a-80a9-a7bbfdf30022.png)\n\n下面举个`vue`通过`diff`算法更新的例子：\n\n新旧`VNode`节点如下图所示：\n\n![](https://static.ecool.fun//article/d64ad3e5-4892-415d-92ce-e5556dd0548e.png)\n\n第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为`diff`后的第一个真实节点，同时旧节点`endIndex`移动到C，新节点的 `startIndex` 移动到了 C\n\n![](https://static.ecool.fun//article/5ff039e0-4bb9-49ee-9921-85a11476131b.png)\n\n第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，`diff` 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 `endIndex` 移动到了 B，新节点的 `startIndex` 移动到了 E\n\n![](https://static.ecool.fun//article/5d753795-ae75-441e-9f57-cc55a62a1a6d.png)\n\n第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 `startIndex` 移动到了 A。旧节点的 `startIndex` 和 `endIndex` 都保持不动\n\n![](https://static.ecool.fun//article/4b863487-0c0b-4993-9222-cc5ce85c4a7b.png)\n\n第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 `diff` 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 `startIndex` 移动到了 B，新节点的` startIndex` 移动到了 B\n\n![](https://static.ecool.fun//article/e88197ab-c05d-4e10-98e9-bf35d87e3ebc.png)\n\n第五次循环中，情形同第四次循环一样，因此 `diff` 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 `startIndex `移动到了 C，新节点的 startIndex 移动到了 F\n\n![](https://static.ecool.fun//article/53b186bb-dde2-424b-b331-bfe72e63da8c.png)\n\n新节点的 `startIndex` 已经大于 `endIndex` 了，需要创建 `newStartIdx` 和 `newEndIdx` 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面\n\n![](https://static.ecool.fun//article/08429a13-7804-4a75-a0e9-4073600676a4.png)\n\n## 三、原理分析\n\n当数据发生改变时，`set`方法会调用`Dep.notify`通知所有订阅者`Watcher`，订阅者就会调用`patch`给真实的`DOM`打补丁，更新相应的视图\n\n源码位置：src/core/vdom/patch.js\n\n```js\nfunction patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) { // 没有新节点，直接执行destory钩子函数\n        if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n        return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    if (isUndef(oldVnode)) {\n        isInitialPatch = true\n        createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素\n    } else {\n        const isRealElement = isDef(oldVnode.nodeType)\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n            // 判断旧节点和新节点自身一样，一致执行patchVnode\n            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)\n        } else {\n            // 否则直接销毁及旧节点，根据新节点生成dom元素\n            if (isRealElement) {\n\n                if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n                    oldVnode.removeAttribute(SSR_ATTR)\n                    hydrating = true\n                }\n                if (isTrue(hydrating)) {\n                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                        invokeInsertHook(vnode, insertedVnodeQueue, true)\n                        return oldVnode\n                    }\n                }\n                oldVnode = emptyNodeAt(oldVnode)\n            }\n            return vnode.elm\n        }\n    }\n}\n```\n\n`patch`函数前两个参数位为`oldVnode` 和 `Vnode` ，分别代表新的节点和之前的旧节点，主要做了四个判断：\n\n- 没有新节点，直接触发旧节点的`destory`钩子\n- 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 `createElm`\n- 旧节点和新节点自身一样，通过 `sameVnode` 判断节点是否一样，一样时，直接调用 `patchVnode `去处理这两个节点\n- 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点\n\n下面主要讲的是`patchVnode`部分\n\n```js\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    // 如果新旧节点一致，什么都不做\n    if (oldVnode === vnode) {\n      return\n    }\n\n    // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化\n    const elm = vnode.elm = oldVnode.elm\n\n    // 异步占位符\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n      } else {\n        vnode.isAsyncPlaceholder = true\n      }\n      return\n    }\n    // 如果新旧都是静态节点，并且具有相同的key\n    // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上\n    // 也不用再有其他操作\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance\n      return\n    }\n\n    let i\n    const data = vnode.data\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode)\n    }\n\n    const oldCh = oldVnode.children\n    const ch = vnode.children\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n      if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\n    }\n    // 如果vnode不是文本节点或者注释节点\n    if (isUndef(vnode.text)) {\n      // 并且都有子节点\n      if (isDef(oldCh) && isDef(ch)) {\n        // 并且子节点不完全一致，则调用updateChildren\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n\n        // 如果只有新的vnode有子节点\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n        // elm已经引用了老的dom节点，在老的dom节点上添加子节点\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n\n        // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n\n        // 如果老节点是文本节点\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '')\n      }\n\n      // 如果新vnode和老vnode是文本节点或注释节点\n      // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text)\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)\n    }\n  }\n```\n\n`patchVnode`主要做了几个判断：\n\n- 新节点是否是文本节点，如果是，则直接更新`dom`的文本内容为新节点的文本内容\n- 新节点和旧节点如果都有子节点，则处理比较更新子节点\n- 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新`DOM`，并且添加进父节点\n- 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把`DOM` 删除\n\n子节点不完全一致，则调用`updateChildren`\n\n```js\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0 // 旧头索引\n    let newStartIdx = 0 // 新头索引\n    let oldEndIdx = oldCh.length - 1 // 旧尾索引\n    let newEndIdx = newCh.length - 1 // 新尾索引\n    let oldStartVnode = oldCh[0] // oldVnode的第一个child\n    let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child\n    let newStartVnode = newCh[0] // newVnode的第一个child\n    let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      // 如果oldVnode的第一个child不存在\n      if (isUndef(oldStartVnode)) {\n        // oldStart索引右移\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n\n      // 如果oldVnode的最后一个child不存在\n      } else if (isUndef(oldEndVnode)) {\n        // oldEnd索引左移\n        oldEndVnode = oldCh[--oldEndIdx]\n\n      // oldStartVnode和newStartVnode是同一个节点\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        // patch oldStartVnode和newStartVnode， 索引左移，继续循环\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n\n      // oldEndVnode和newEndVnode是同一个节点\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        // patch oldEndVnode和newEndVnode，索引右移，继续循环\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n\n      // oldStartVnode和newEndVnode是同一个节点\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        // patch oldStartVnode和newEndVnode\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        // oldStart索引右移，newEnd索引左移\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n\n      // 如果oldEndVnode和newStartVnode是同一个节点\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        // patch oldEndVnode和newStartVnode\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        // oldEnd索引左移，newStart索引右移\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n\n      // 如果都不匹配\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n\n        // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n\n        // 如果未找到，说明newStartVnode是一个新的节点\n        if (isUndef(idxInOld)) { // New element\n          // 创建一个新Vnode\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n\n        // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !vnodeToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            )\n          }\n\n          // 比较两个具有相同的key的新节点是否是同一个节点\n          //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            // patch vnodeToMove和newStartVnode\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n            // 清除\n            oldCh[idxInOld] = undefined\n            // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm\n            // 移动到oldStartVnode.elm之前\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n\n          // 如果key相同，但是节点不相同，则创建一个新的节点\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          }\n        }\n\n        // 右移\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n```\n\n`while`循环主要处理了以下五种情景：\n\n- 当新老 `VNode` 节点的 `start` 相同时，直接 `patchVnode` ，同时新老 `VNode` 节点的开始索引都加 1\n- 当新老 `VNode` 节点的 `end`相同时，同样直接 `patchVnode` ，同时新老 `VNode` 节点的结束索引都减 1\n- 当老 `VNode` 节点的 `start` 和新 `VNode` 节点的 `end` 相同时，这时候在 `patchVnode` 后，还需要将当前真实 `dom` 节点移动到 `oldEndVnode` 的后面，同时老 `VNode` 节点开始索引加 1，新 `VNode` 节点的结束索引减 1\n- 当老 `VNode` 节点的 `end` 和新 `VNode` 节点的 `start` 相同时，这时候在 `patchVnode` 后，还需要将当前真实 `dom` 节点移动到 `oldStartVnode` 的前面，同时老 `VNode` 节点结束索引减 1，新 `VNode` 节点的开始索引加 1\n- 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：\n  - 从旧的 `VNode` 为 `key` 值，对应 `index` 序列为 `value` 值的哈希表中找到与 `newStartVnode` 一致 `key` 的旧的 `VNode` 节点，再进行`patchVnode `，同时将这个真实 `dom `移动到 `oldStartVnode` 对应的真实 `dom` 的前面\n  - 调用 `createElm` 创建一个新的 `dom` 节点放到当前 `newStartIdx` 的位置\n\n\n\n### 小结\n\n- 当数据发生改变时，订阅者`watcher`就会调用`patch`给真实的`DOM`打补丁\n- 通过`isSameVnode`进行判断，相同则调用`patchVnode`方法\n- `patchVnode`做了以下操作：\n  - 找到对应的真实`dom`，称为`el`\n  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点\n  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点\n  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`\n  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点\n- `updateChildren`主要做了以下操作：\n  - 设置新旧`VNode`的头尾指针\n  - 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作\n\n\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 3,
    "appId": 7,
    "createAt": "2021-07-04T03:44:57.000Z",
    "updateAt": "2024-08-10T17:04:45.000Z",
    "isCollected": false,
    "currentIndex": 1255,
    "filterTotalNum": 1487,
    "prev": "71d2fd07-2629-4ffd-a9ea-750ee912f912",
    "next": "d5acd6cf-38c3-4afb-965d-be79f03cd045"
  },
  "post": {
    "exerciseKey": "7d27dc57-5d95-4e3f-88a7-eb685b7c21e4",
    "category": "QA",
    "title": "说说vue中的diff算法",
    "level": 3,
    "createAt": "2021-07-04T03:44:57+00:00",
    "updateAt": "2024-08-10T17:04:45+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 97
  }
}