{
  "data": {
    "id": 253,
    "exerciseKey": "0cc5abe2-7798-40a6-b930-7dacdb404b8d",
    "category": "QA",
    "renderType": "md",
    "title": "你是怎么处理vue项目中的错误的？",
    "desc": null,
    "options": null,
    "explanation": "## 一、错误类型\n\n任何一个框架，对于错误的处理都是一种必备的能力\n\n在`Vue` 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。\n\n主要的错误来源包括：\n\n- 后端接口错误\n- 代码中本身逻辑错误\n\n\n\n## 二、如何处理\n\n### 后端接口错误\n\n通过`axios`的`interceptor`实现网络请求的`response`先进行一层拦截\n\n```js\napiClient.interceptors.response.use(\n  response => {\n    return response;\n  },\n  error => {\n    if (error.response.status == 401) {\n      router.push({ name: \"Login\" });\n    } else {\n      message.error(\"出错了\");\n      return Promise.reject(error);\n    }\n  }\n);\n```\n\n\n\n### 代码逻辑问题\n\n#### 全局设置错误处理\n\n设置全局错误处理函数\n\n```js\nVue.config.errorHandler = function (err, vm, info) {\n  // handle error\n  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n  // 只在 2.2.0+ 可用\n}\n```\n\n`errorHandler`指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 `Vue` 实例\n\n不过值得注意的是，在不同` Vue` 版本中，该全局 `API` 作用的范围会有所不同：\n\n> 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 `undefined` 时，被捕获的错误会通过 `console.error` 输出而避免应用崩\n\n> 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了\n\n> 从 2.6.0 起，这个钩子也会捕获 `v-on` DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理\n\n\n\n#### 生命周期钩子\n\n`errorCaptured`是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用\n\n基本类型\n\n```js\n(err: Error, vm: Component, info: string) => ?boolean\n```\n\n此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播\n\n参考官网，错误传播规则如下：\n\n- 默认情况下，如果全局的 `config.errorHandler` 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报\n- 如果一个组件的继承或父级从属链路中存在多个 `errorCaptured` 钩子，则它们将会被相同的错误逐个唤起。\n- 如果此 `errorCaptured` 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 `config.errorHandler`\n- 一个 `errorCaptured` 钩子能够返回 `false` 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 `errorCaptured` 钩子和全局的 `config.errorHandler`\n\n下面来看个例子\n\n定义一个父组件`cat`\n\n```js\nVue.component('cat', {\n    template:`\n        <div>\n\t\t\t<h1>Cat: </h1>\n        \t<slot></slot>\n        </div>`,\n    props:{\n        name:{\n            required:true,\n            type:String\n        }\n    },\n    errorCaptured(err,vm,info) {\n        console.log(`cat EC: ${err.toString()}\\ninfo: ${info}`); \n        return false;\n    }\n\n});\n```\n\n定义一个子组件`kitten`，其中`dontexist()`并没有定义，存在错误\n\n```js\nVue.component('kitten', {\n    template:'<div><h1>Kitten: {{ dontexist() }}</h1></div>',\n    props:{\n        name:{\n            required:true,\n            type:String\n        }\n    }\n});\n```\n\n页面中使用组件\n\n```html\n<div id=\"app\" v-cloak>\n    <cat name=\"my cat\">\n        <kitten></kitten>\n    </cat>\n</div>\n```\n\n在父组件的`errorCaptured`则能够捕获到信息\n\n```js\ncat EC: TypeError: dontexist is not a function\ninfo: render\n```\n\n\n\n### 三、源码分析\n\n异常处理源码\n\n源码位置：/src/core/util/error.js\n\n```js\n// Vue 全局配置,也就是上面的Vue.config\nimport config from '../config'\nimport { warn } from './debug'\n// 判断环境\nimport { inBrowser, inWeex } from './env'\n// 判断是否是Promise，通过val.then === 'function' && val.catch === 'function', val ！=== null && val !== undefined\nimport { isPromise } from 'shared/util'\n// 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering\n// 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题\nimport { pushTarget, popTarget } from '../observer/dep'\n\nexport function handleError (err: Error, vm: any, info: string) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    pushTarget()\n    try {\n        // vm指当前报错的组件实例\n        if (vm) {\n            let cur = vm\n            // 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。\n            // 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法\n            while ((cur = cur.$parent)) {\n                const hooks = cur.$options.errorCaptured\n                // 判断是否存在errorCaptured钩子函数\n                if (hooks) {\n                    // 选项合并的策略，钩子函数会被保存在一个数组中\n                    for (let i = 0; i < hooks.length; i++) {\n                        // 如果errorCaptured 钩子执行自身抛出了错误，\n                        // 则用try{}catch{}捕获错误，将这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler\n                        // 调用globalHandleError方法\n                        try {\n                            // 当前errorCaptured执行，根据返回是否是false值\n                            // 是false，capture = true，阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler\n                            // 是true capture = fale，组件的继承或父级从属链路中存在的多个 errorCaptured 钩子，会被相同的错误逐个唤起\n                            // 调用对应的钩子函数，处理错误\n                            const capture = hooks[i].call(cur, err, vm, info) === false\n                            if (capture) return\n                        } catch (e) {\n                            globalHandleError(e, cur, 'errorCaptured hook')\n                        }\n                    }\n                }\n            }\n        }\n        // 除非禁止错误向上传播，否则都会调用全局的错误处理函数\n        globalHandleError(err, vm, info)\n    } finally {\n        popTarget()\n    }\n}\n// 异步错误处理函数\nexport function invokeWithErrorHandling (\nhandler: Function,\n context: any,\n args: null | any[],\n    vm: any,\n        info: string\n        ) {\n            let res\n            try {\n                // 根据参数选择不同的handle执行方式\n                res = args ? handler.apply(context, args) : handler.call(context)\n                // handle返回结果存在\n                // res._isVue an flag to avoid this being observed，如果传入值的_isVue为ture时(即传入的值是Vue实例本身)不会新建observer实例\n                // isPromise(res) 判断val.then === 'function' && val.catch === 'function', val ！=== null && val !== undefined\n                // !res._handled  _handle是Promise 实例的内部变量之一，默认是false，代表onFulfilled,onRejected是否被处理\n                if (res && !res._isVue && isPromise(res) && !res._handled) {\n                    res.catch(e => handleError(e, vm, info + ` (Promise/async)`))\n                    // avoid catch triggering multiple times when nested calls\n                    // 避免嵌套调用时catch多次的触发\n                    res._handled = true\n                }\n            } catch (e) {\n                // 处理执行错误\n                handleError(e, vm, info)\n            }\n            return res\n        }\n\n//全局错误处理\nfunction globalHandleError (err, vm, info) {\n    // 获取全局配置，判断是否设置处理函数，默认undefined\n    // 已配置\n    if (config.errorHandler) {\n        // try{}catch{} 住全局错误处理函数\n        try {\n            // 执行设置的全局错误处理函数，handle error 想干啥就干啥💗\n            return config.errorHandler.call(null, err, vm, info)\n        } catch (e) {\n            // 如果开发者在errorHandler函数中手动抛出同样错误信息throw err\n            // 判断err信息是否相等，避免log两次\n            // 如果抛出新的错误信息throw err Error('你好毒')，将会一起log输出\n            if (e !== err) {\n                logError(e, null, 'config.errorHandler')\n            }\n        }\n    }\n    // 未配置常规log输出\n    logError(err, vm, info)\n}\n\n// 错误输出函数\nfunction logError (err, vm, info) {\n    if (process.env.NODE_ENV !== 'production') {\n        warn(`Error in ${info}: \"${err.toString()}\"`, vm)\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n        console.error(err)\n    } else {\n        throw err\n    }\n}\n```\n\n### 小结\n\n- `handleError`在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用`errorCaptured` 方法，在遍历调用完所有 `errorCaptured` 方法或 `errorCaptured` 方法有报错时，调用 `globalHandleError` 方法\n- `globalHandleError `调用全局的 `errorHandler` 方法，再通过`logError`判断环境输出错误信息\n- `invokeWithErrorHandling`更好的处理异步错误信息\n- `logError`判断环境，选择不同的抛错方式。非生产环境下，调用`warn`方法处理错误\n\n\n",
    "level": 2,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-04T03:52:25.000Z",
    "updateAt": "2024-01-25T17:37:52.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 121,
    "prev": "ca63a7ef-8e3d-4fe4-b697-28138bd96f74",
    "next": "252525e4-0c4c-4e41-9279-41bc59f06f85"
  },
  "post": {
    "exerciseKey": "0cc5abe2-7798-40a6-b930-7dacdb404b8d",
    "category": "QA",
    "title": "你是怎么处理vue项目中的错误的？",
    "level": 2,
    "updateAt": "2024-01-25T17:37:52+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 68
  }
}
