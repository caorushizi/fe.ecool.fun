{
  "data": {
    "id": 1866,
    "exerciseKey": "e9a726d4-0ce9-4e04-88c3-9e42bad984f7",
    "category": "QA",
    "renderType": "md",
    "title": "说说你的ES6-ES12的了解",
    "desc": null,
    "options": null,
    "explanation": "### ES6（2015）\n\n#### 1\\. 类（class）\n\n```bash\nclass Man {\n  constructor(name) {\n    this.name = '小豪';\n  }\n  console() {\n    console.log(this.name);\n  }\n}\nconst man = new Man('小豪');\nman.console(); // 小豪\n```\n\n#### 2\\. 模块化(ES Module)\n\n```bash\n// 模块 A 导出一个方法\nexport const sub = (a, b) => a + b;\n// 模块 B 导入使用\nimport { sub } from './A';\nconsole.log(sub(1, 2)); // 3\n```\n\n#### 3\\. 箭头（Arrow）函数\n\n```bash\nconst func = (a, b) => a + b;\nfunc(1, 2); // 3\n```\n\n#### 4\\. 函数参数默认值\n\n```bash\nfunction foo(age = 25,){ // ...}\n```\n\n#### 5\\. 模板字符串\n\n```bash\nconst name = '小豪';\nconst str = `Your name is ${name}`;\n```\n\n#### 6\\. 解构赋值\n\n```bash\nlet a = 1, b= 2;\n[a, b] = [b, a]; // a 2  b 1\n```\n\n#### 7\\. 延展操作符\n\n```bash\nlet a = [...'hello world']; // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\n```\n\n#### 8\\. 对象属性简写\n\n```bash\nconst name='小豪',\nconst obj = { name };\n```\n\n#### 9\\. Promise\n\n```bash\nPromise.resolve().then(() => { console.log(2); });\nconsole.log(1);\n// 先打印 1 ，再打印 2\n```\n\n#### 10\\. let和const\n\n```bash\nlet name = '小豪'；\nconst arr = [];\n```\n\n### ES7（2016）\n\n#### 1\\. Array.prototype.includes()\n\n```bash\n[1].includes(1); // true\n```\n\n#### 2\\. 指数操作符\n\n```bash\n2**10; // 1024\n```\n\n### ES8（2017）\n\n#### 1\\. async/await\n\n异步终极解决方案\n\n```bash\nasync getData(){\n    const res = await api.getTableData(); // await 异步任务\n    // do something    \n}\n```\n\n#### 2\\. Object.values()\n\n```bash\nObject.values({a: 1, b: 2, c: 3}); // [1, 2, 3]\n```\n\n#### 3\\. Object.entries()\n\n```bash\nObject.entries({a: 1, b: 2, c: 3}); // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```\n\n#### 4\\. String padding\n\n```bash\n// padStart\n'hello'.padStart(10); // \"     hello\"\n// padEnd\n'hello'.padEnd(10) \"hello     \"\n```\n\n#### 5\\. 函数参数列表结尾允许逗号\n\n#### 6\\. Object.getOwnPropertyDescriptors()\n\n> 获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。\n\n#### 7\\. SharedArrayBuffer对象\n\n> SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，\n\n```bash\n/**\n * \n * @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。  \n * @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。\n */\nnew SharedArrayBuffer(10)\n```\n\n#### 8\\. Atomics对象\n\n> Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。\n\n### ES9（2018）\n\n#### 1\\. 异步迭代\n\nawait可以和for...of循环一起使用，以串行的方式运行异步操作\n\n```bash\nasync function process(array) {\n  for await (let i of array) {\n    // doSomething(i);\n  }\n}\n```\n\n#### 2\\. Promise.finally()\n\n```bash\nPromise.resolve().then().catch(e => e).finally();\n```\n\n#### 3\\. Rest/Spread 属性\n\n```bash\nconst values = [1, 2, 3, 5, 6];\nconsole.log( Math.max(...values) ); // 6\n```\n\n#### 4\\. 正则表达式命名捕获组\n\n```bash\nconst reg = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\nconst match = reg.exec('2021-02-23');\n```\n\n#### 5\\. 正则表达式反向断言\n\n```bash\n(?=p)、(?<=p)  p 前面(位置)、p 后面(位置)\n(?!p)、(?<!p>) 除了 p 前面(位置)、除了 p 后面(位置)\n```\n\n#### 6\\. 正则表达式dotAll模式\n\n> 正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现\n\n```bash\n/hello.world/.test('hello\\nworld');  // false\n```\n\n### ES10（2019）\n\n#### 1\\. Array.flat()和Array.flatMap()\n\nflat()\n\n```bash\n[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]\n```\n\nflatMap()\n\n```bash\n[1, 2, 3, 4].flatMap(a => [a**2]); // [1, 4, 9, 16]\n```\n\n#### 2\\. String.trimStart()和String.trimEnd()\n\n去除字符串首尾空白字符\n\n#### 3\\. String.prototype.matchAll\n\n> matchAll（）为所有匹配的匹配对象返回一个迭代器\n\n```bash\nconst raw_arr = 'test1  test2  test3'.matchAll((/t(e)(st(\\d?))/g));\nconst arr = [...raw_arr];\n```\n\n#### 4\\. Symbol.prototype.description\n\n> 只读属性，回 Symbol 对象的可选描述的字符串。\n\n```bash\nSymbol('description').description; // 'description'\n```\n\n#### 5\\. Object.fromEntries()\n\n> 返回一个给定对象自身可枚举属性的键值对数组\n\n```bash\n// 通过 Object.fromEntries， 可以将 Map 转化为 Object:\nconst map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\nconsole.log(Object.fromEntries(map)); // { foo: \"bar\", baz: 42 }\n```\n\n#### 6\\. 可选 Catch\n\n### ES11（2020）\n\n#### 1\\. Nullish coalescing Operator(空值处理)\n\n表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。\n\n```bash\nlet user = {\n    u1: 0,\n    u2: false,\n    u3: null,\n    u4: undefined\n    u5: '',\n}\nlet u2 = user.u2 ?? '用户2'  // false\nlet u3 = user.u3 ?? '用户3'  // 用户3\nlet u4 = user.u4 ?? '用户4'  // 用户4\nlet u5 = user.u5 ?? '用户5'  // ''\n```\n\n#### 2\\. Optional chaining（可选链）\n\n?.用户检测不确定的中间节点\n\n```bash\nlet user = {}\nlet u1 = user.childer.name // TypeError: Cannot read property 'name' of undefined\nlet u1 = user.childer?.name // undefined\n```\n\n#### 3\\. Promise.allSettled\n\n> 返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果\n\n```bash\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => reject('我是失败的Promise_1'));\nconst promise4 = new Promise((resolve, reject) => reject('我是失败的Promise_2'));\nconst promiseList = [promise1,promise2,promise3, promise4]\nPromise.allSettled(promiseList)\n.then(values=>{\n  console.log(values)\n});\n```\n\n#### 4\\. import()\n\n按需导入\n\n#### 5\\. 新基本数据类型BigInt\n\n> 任意精度的整数\n\n#### 6\\. globalThis\n\n-   浏览器：window\n-   worker：self\n-   node：global\n\n### ES12（2021）\n\n#### 1\\. replaceAll\n\n> 返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉\n\n```bash\nconst str = 'hello world';\nstr.replaceAll('l', ''); // \"heo word\"\n```\n\n#### 2\\. Promise.any\n\n> Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise\n\n```bash\nconst promise1 = new Promise((resolve, reject) => reject('我是失败的Promise_1'));\nconst promise2 = new Promise((resolve, reject) => reject('我是失败的Promise_2'));\nconst promiseList = [promise1, promise2];\nPromise.any(promiseList)\n.then(values=>{\n  console.log(values);\n})\n.catch(e=>{\n  console.log(e);\n});\n```\n\n#### 3\\. WeakRefs\n\n> 使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)\n\n#### 4\\. 逻辑运算符和赋值表达式\n\n> 逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&&，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有：\n\n```bash\na ||= b\n//等价于\na = a || (a = b)\n\na &&= b\n//等价于\na = a && (a = b)\n\na ??= b\n//等价于\na = a ?? (a = b)\n```\n\n#### 5\\. 数字分隔符\n\n> 数字分隔符，可以在数字之间创建可视化分隔符，通过\\_下划线来分割数字，使数字更具可读性\n\n```bash\nconst money = 1_000_000_000;\n//等价于\nconst money = 1000000000;\n\n1_000_000_000 === 1000000000; // true\n```",
    "pivot": "",
    "vipLimit": 0,
    "level": 4,
    "appId": 7,
    "createAt": "2022-07-24T04:23:51.000Z",
    "updateAt": "2024-08-10T17:06:52.000Z",
    "isCollected": false,
    "currentIndex": 523,
    "filterTotalNum": 1487,
    "prev": "696a79c6-1e6d-4e66-ad11-2e072c9c62d7",
    "next": "0b096e94-b846-448b-ae4b-b4f500e96bf1"
  },
  "post": {
    "exerciseKey": "e9a726d4-0ce9-4e04-88c3-9e42bad984f7",
    "category": "QA",
    "title": "说说你的ES6-ES12的了解",
    "level": 4,
    "createAt": "2022-07-24T04:23:51+00:00",
    "updateAt": "2024-08-10T17:06:52+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 379
  }
}