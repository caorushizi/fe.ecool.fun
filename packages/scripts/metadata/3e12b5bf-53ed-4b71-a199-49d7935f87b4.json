{
  "data": {
    "id": 1806,
    "exerciseKey": "3e12b5bf-53ed-4b71-a199-49d7935f87b4",
    "category": "QA",
    "renderType": "md",
    "title": "说说 Vue 中 CSS scoped 的原理",
    "desc": null,
    "options": null,
    "explanation": "## 前言\n\n在日常的Vue项目开发过程中，为了让项目更好的维护一般都会使用模块化开发的方式进行。也就是每个组件维护独立的`template`，`script`，`style`。今天主要介绍一下使用`<style scoped>`为什么在页面渲染完后样式之间并不会造成污染。\n\n## 示例\n\n搭建一个简单的Vue项目测试一下：\n\n![](https://static.ecool.fun//article/a05b22d7-2657-486f-a20c-896b7f1b54b2.jpeg)\n\n给个目录结构吧，代码并不是我们讲解的重点，如果需要源码测试的话后续我放到github上去。  \n终端执行`npx webpack`输出dist目录，我们在浏览器打开index.html调试一下看看现象：\n\n![](https://static.ecool.fun//article/5150ea02-e887-4120-9e29-8a57fe9c0223.jpeg)\n\n1. 每个组件都会拥有一个`[data-v-hash:8]`插入HTML标签，子组件标签上也具体父组件`[data-v-hash:8]`;\n2. 如果style标签加了`scoped属性`，里面的选择器都会变成`(Attribute Selector) [data-v-hash:8]`;\n3. 如果子组件选择器跟父组件选择器完全一样，那么就会出现子组件样式被父组件覆盖，因为`子组件会优先于父组件mounted`，有兴趣可以测试一下哦。\n\n## webpack.config.js配置\n\n我们先看看在`webpack.config.js`中的配置：\n\n![](https://static.ecool.fun//article/7d7879fb-5772-4ede-b015-8bc9ccc832ee.jpeg)\n\n## vue-loader工作流\n\n以下就是vue-loader工作大致的处理流程：\n\n![](https://static.ecool.fun//article/1148995d-c04f-49bf-a353-f7090a0554ca.jpeg)\n\n开启`node调试模式`进行查看阅读，package.json中配置如下：\n\n```\n\"scripts\": {  \n    \"debug\": \"node --inspect-brk ./node_modules/webpack/bin/webpack.js\"  \n },\n\n```\n\n## VueLoaderPlugin\n\n先从入口文件`lib/index.js`开始分析，因为我的Webpack是4.x版本，所以`VueLoaderPlugin = require('./plugin-webpack4')`，重点来看看这个`lib/plugin-webpack4.js`文件:\n\n```\nconst qs = require('querystring')\nconst RuleSet = require('webpack/lib/RuleSet')\n\nconst id = 'vue-loader-plugin'\nconst NS = 'vue-loader'\n// 很明显这就是一个webpack插件写法\nclass VueLoaderPlugin {\n  apply (compiler) {\n    if (compiler.hooks) {\n      // 编译创建之后，执行插件\n      compiler.hooks.compilation.tap(id, compilation => {\n        const normalModuleLoader = compilation.hooks.normalModuleLoader\n        normalModuleLoader.tap(id, loaderContext => {\n          loaderContext[NS] = true\n        })\n      })\n    } else {\n      // webpack < 4\n      compiler.plugin('compilation', compilation => {\n        compilation.plugin('normal-module-loader', loaderContext => {\n          loaderContext[NS] = true\n        })\n      })\n    }\n\n    // webpack.config.js 中配置好的 module.rules\n    const rawRules = compiler.options.module.rules\n    // 对 rawRules 做 normlized\n    const { rules } = new RuleSet(rawRules)\n\n    // 从 rawRules 中检查是否有规则去匹配 .vue 或 .vue.html \n    let vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue`))\n    if (vueRuleIndex < 0) {\n      vueRuleIndex = rawRules.findIndex(createMatcher(`foo.vue.html`))\n    }\n    const vueRule = rules[vueRuleIndex]\n    if (!vueRule) {\n      throw new Error(\n        `[VueLoaderPlugin Error] No matching rule for .vue files found.\\n` +\n        `Make sure there is at least one root-level rule that matches .vue or .vue.html files.`\n      )\n    }\n    if (vueRule.oneOf) {\n      throw new Error(\n        `[VueLoaderPlugin Error] vue-loader 15 currently does not support vue rules with oneOf.`\n      )\n    }\n\n    // 检查 normlized rawRules 中 .vue 规则中是否具有 vue-loader\n    const vueUse = vueRule.use\n    const vueLoaderUseIndex = vueUse.findIndex(u => {\n      return /^vue-loader|(\\/|\\\\|@)vue-loader/.test(u.loader)\n    })\n\n    if (vueLoaderUseIndex < 0) {\n      throw new Error(\n        `[VueLoaderPlugin Error] No matching use for vue-loader is found.\\n` +\n        `Make sure the rule matching .vue files include vue-loader in its use.`\n      )\n    }\n\n    // make sure vue-loader options has a known ident so that we can share\n    // options by reference in the template-loader by using a ref query like\n    // template-loader??vue-loader-options\n    const vueLoaderUse = vueUse[vueLoaderUseIndex]\n    vueLoaderUse.ident = 'vue-loader-options'\n    vueLoaderUse.options = vueLoaderUse.options || {}\n\n    // 过滤出 .vue 规则，其他规则调用 cloneRule 方法重写了 resource 和 resourceQuery 配置\n    // 用于编译vue文件后匹配依赖路径 query 中需要的loader\n    const clonedRules = rules\n      .filter(r => r !== vueRule)\n      .map(cloneRule)\n\n    // 加入全局 pitcher-loader，路径query有vue字段就给loader添加pitch方法\n    const pitcher = {\n      loader: require.resolve('./loaders/pitcher'),\n      resourceQuery: query => {\n        const parsed = qs.parse(query.slice(1))\n        return parsed.vue != null\n      },\n      options: {\n        cacheDirectory: vueLoaderUse.options.cacheDirectory,\n        cacheIdentifier: vueLoaderUse.options.cacheIdentifier\n      }\n    }\n\n    // 修改原始的 module.rules 配置\n    compiler.options.module.rules = [\n      pitcher,\n      ...clonedRules,\n      ...rules\n    ]\n  }\n}\n\n```\n\n以上大概就是`VueLoaderPlugin`所做的事情。也就是说`VueLoaderPlugin`主要就是修改module.rules的配置。总的来说就是对vue单文件编写做的一个扩展(比如我们可以写less文件，在vue style中也可以写less)\n\n## vue-loader\n\n继续来看看`vue-loader`是如何操作.vue文件的，目前只关心`style`部分，逻辑在`lib/index.js`：\n\n### vue文件解析\n\n```\n// 很明显这就是一个loader写法\nmodule.exports = function (source) {\n    const loaderContext = this\n    // ...\n    const {\n        target,\n        request, // 请求资源路径\n        minimize,\n        sourceMap, \n        rootContext, // 根路径\n        resourcePath, // vue文件的路径\n        resourceQuery // vue文件的路径 query 参数\n      } = loaderContext\n    // ...\n    \n    // 解析 vue 文件，descriptor 是AST抽象语法树的描述\n    const descriptor = parse({\n        source,\n        compiler: options.compiler || loadTemplateCompiler(loaderContext),\n        filename,\n        sourceRoot,\n        needMap: sourceMap\n    })\n    /**\n    *\n    */\n    // hash(文件路径 + 开发环境 ？文件内容 : \"\")生成 id\n    const id = hash(\n        isProduction\n          ? (shortFilePath + '\\n' + source)\n          : shortFilePath\n    )\n    // descriptor.styles 解析后是否具有 attrs: {scoped: true}\n    const hasScoped = descriptor.styles.some(s => s.scoped)\n    /**\n    *\n    */\n    let stylesCode = ``\n    if (descriptor.styles.length) {\n        // 最终生成一个import依赖请求\n        stylesCode = genStylesCode(\n            loaderContext,\n            descriptor.styles,\n            id,\n            resourcePath,\n            stringifyRequest,\n            needsHotReload,\n            isServer || isShadow // needs explicit injection?\n        )\n    }\n}\n\n```\n\n可以看到解析完vue文件的结果大概就是这样的：\n\n![](https://static.ecool.fun//article/27e47892-fad8-4f98-bfa2-899428688dbb.jpeg)\n\n### 依赖解析\n\nvue文件解析完之后template，script，style等都有个依赖的路径，后续可以通过配置的loader进行解析了，因为我们已经在`VuePluginLoader`中修改了module.rules的配置，而且依赖的路径中query中都拥有vue字段，所以会先走到pitcher-loader,现在来分析`lib/loaders/pitcher.js`中的逻辑：\n\n```\n/**\n *\n*/\nmodule.exports = code => code\n\nmodule.exports.pitch = function (remainingRequest) {\n    const options = loaderUtils.getOptions(this)\n    const { cacheDirectory, cacheIdentifier } = options\n    const query = qs.parse(this.resourceQuery.slice(1))\n\n    let loaders = this.loaders\n    if (query.type) {\n        if (/\\.vue$/.test(this.resourcePath)) {\n            // 过滤eslint-loader\n            loaders = loaders.filter(l => !isESLintLoader(l))\n        } else {\n            loaders = dedupeESLintLoader(loaders)\n        }\n    }\n    // 过滤pitcher-loader\n    loaders = loaders.filter(isPitcher)\n    \n    const genRequest = loaders => {\n        const seen = new Map()\n        const loaderStrings = []\n\n        loaders.forEach(loader => {\n          const identifier = typeof loader === 'string'\n            ? loader\n            : (loader.path + loader.query)\n          const request = typeof loader === 'string' ? loader : loader.request\n          if (!seen.has(identifier)) {\n            seen.set(identifier, true)\n            // loader.request contains both the resolved loader path and its options\n            // query (e.g. ??ref-0)\n            loaderStrings.push(request)\n          }\n        })\n\n        return loaderUtils.stringifyRequest(this, '-!' + [\n          ...loaderStrings,\n          this.resourcePath + this.resourceQuery\n        ].join('!'))\n    }\n    \n    \n    if (query.type === `style`) {\n        const cssLoaderIndex = loaders.findIndex(isCSSLoader)\n        // 调整loader执行顺序\n        if (cssLoaderIndex > -1) {\n            const afterLoaders = loaders.slice(0, cssLoaderIndex + 1)\n            const beforeLoaders = loaders.slice(cssLoaderIndex + 1)\n            const request = genRequest([\n                ...afterLoaders, // [style-loader,css-loader]\n                stylePostLoaderPath, // style-post-loader\n                ...beforeLoaders // [vue-loader]\n            ])\n            return `import mod from ${request}; export default mod; export * from ${request}`\n        }\n   }\n   /**\n   *\n   */\n   const request = genRequest(loaders)\n   return `import mod from ${request}; export default mod; export * from ${request}`\n}\n\n```\n\n可以看到解析带scoped属性的style的结果大概就是这样的：\n\n![](https://static.ecool.fun//article/67b0bf0e-cf0f-4d2b-bc90-89213de288e1.jpeg)\n\n### 新的依赖解析\n\n分析`{tyep：style}`的处理流程顺序：\n\n* vue-loader、style-post-loader、css-loader、style-loader。\n\n处理资源的时候先走的是`vue-loader`，这时vue-loader中的处理逻辑与第一次解析vue文件不一样了：\n\n```\nconst incomingQuery = qs.parse(rawQuery)\n// 拥有{type:style}\nif (incomingQuery.type) {\n    return selectBlock(\n      descriptor,\n      loaderContext,\n      incomingQuery,\n      !!options.appendExtension\n    )\n }\n \n \n // lib/select.js\n module.exports = function selectBlock (\n  descriptor,\n  loaderContext,\n  query,\n  appendExtension\n) {\n   // ...\n  if (query.type === `style` && query.index != null) {\n    const style = descriptor.styles[query.index]\n    if (appendExtension) {\n      loaderContext.resourcePath += '.' + (style.lang || 'css')\n    }\n    loaderContext.callback(\n      null,\n      style.content,\n      style.map\n    )\n    return\n  }\n\n```\n\n> **可以看到vue-loader处理完后返回的就是style.content，也就是style标签下的内容，然后交给后续的loader继续处理**\n\n再来看一下`style-post-loader`是如何生成`data-v-hash:8`的,逻辑主要在`lib/loaders/stylePostLoaders.js`中：\n\n```\nconst qs = require('querystring')\nconst { compileStyle } = require('@vue/component-compiler-utils')\n\nmodule.exports = function (source, inMap) {\n  const query = qs.parse(this.resourceQuery.slice(1))\n  const { code, map, errors } = compileStyle({\n    source,\n    filename: this.resourcePath,\n    id: `data-v-${query.id}`,\n    map: inMap,\n    scoped: !!query.scoped,\n    trim: true\n  })\n\n  if (errors.length) {\n    this.callback(errors[0])\n  } else {\n    this.callback(null, code, map)\n  }\n}\n\n```\n\n处理最终返回的code是这样的：\n\n![](https://static.ecool.fun//article/021f3c9e-2b42-4398-98e0-cffafaf70ce4.jpeg)",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2022-05-16T04:51:34.000Z",
    "updateAt": "2024-01-24T17:24:33.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 190,
    "prev": "418ef81f-96c6-4c4e-b218-df29be84890d",
    "next": "54891e04-5769-477b-8687-f55cf18feae2"
  },
  "post": {
    "exerciseKey": "3e12b5bf-53ed-4b71-a199-49d7935f87b4",
    "category": "QA",
    "title": "说说 Vue 中 CSS scoped 的原理",
    "level": 3.5,
    "updateAt": "2024-01-24T17:24:33+00:00"
  },
  "tag": {
    "id": 11,
    "tagName": "CSS",
    "type": "1",
    "exerciseCount": 90
  }
}