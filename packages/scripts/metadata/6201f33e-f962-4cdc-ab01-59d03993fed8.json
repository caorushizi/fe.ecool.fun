{
  "data": {
    "id": 1730,
    "exerciseKey": "6201f33e-f962-4cdc-ab01-59d03993fed8",
    "category": "QA",
    "renderType": "md",
    "title": "说说Vue 页面渲染流程",
    "desc": null,
    "options": null,
    "explanation": "## 前言\n\n在 `Vue` 核心中除了响应式原理外，视图渲染也是重中之重。我们都知道每次更新数据，都会走视图渲染的逻辑，而这当中牵扯的逻辑也是十分繁琐。\n\n本文主要解析的是初始化视图渲染流程，你将会了解到从挂载组件开始，`Vue` 是如何构建 `VNode`，又是如何将 `VNode` 转为真实节点并挂载到页面。\n\n## 挂载组件($mount)\n\n`Vue` 是一个构造函数，通过 `new` 关键字进行实例化。\n\n```js\n// src/core/instance/index.js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n在实例化时，会调用 `_init` 进行初始化。\n\n```js\n// src/core/instance/init.js\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // ...\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n```\n\n`_init` 内会调用 `$mount` 来挂载组件，而 `$mount` 方法实际调用的是 `mountComponent`。\n\n```js\n// src/core/instance/lifecycle.js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  // ...\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    // ...\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)  // 渲染页面函数\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, { //  渲染watcher\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n`mountComponent` 除了调用一些生命周期的钩子函数外，最主要是 `updateComponent`，它就是负责渲染视图的核心方法，其只有一行核心代码：\n\n```js\nvm._update(vm._render(), hydrating)\n```\n\n`vm._render` 创建并返回 `VNode`，`vm._update` 接受 `VNode` 将其转为真实节点。\n\n`updateComponent` 会被传入 `渲染Watcher`，每当数据变化触发 `Watcher` 更新就会执行该函数，重新渲染视图。`updateComponent` 在传入 `渲染Watcher` 后会被执行一次进行初始化页面渲染。\n\n所以我们着重分析的是 `vm._render` 和 `vm._update` 两个方法，这也是本文主要了解的原理——`Vue` 视图渲染流程。\n\n## 构建VNode(_render)\n\n首先是 `_render` 方法，它用来构建组件的 `VNode`。\n\n```js\n// src/core/instance/render.js\nVue.prototype._render = function () {\n    const { render, _parentVnode } = vm.$options\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n    return vnode\n}\n```\n\n`_render` 内部会执行 `render` 方法并返回构建好的 `VNode`。`render` 一般是模板编译后生成的方法，也有可能是用户自定义。\n\n```js\n// src/core/instance/render.js\nexport function initRender (vm) {\n    vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n    vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n}\n```\n\n`initRender` 在初始化就会执行为实例上绑定两个方法，分别是 `vm._c` 和 `vm.$createElement`。它们两者都是调用 `createElement` 方法，它是创建 `VNode` 的核心方法，最后一个参数用于区别是否为用户自定义。\n\n`vm._c` 应用场景是在编译生成的 `render` 函数中调用，`vm.$createElement` 则用于用户自定义 `render` 函数的场景。就像上面 `render` 在调用时会传入参数 `vm.$createElement`，我们在自定义 `render` 函数接收到的参数就是它。\n\n### createElement\n\n```js\n// src/core/vdom/create-elemenet.js\nexport function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode | Array<VNode> {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n```\n\n`createElement` 方法实际上是对 `_createElement` 方法的封装，它允许传入的参数更加灵活。\n\n```js\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n```\n\n`_createElement` 参数中会接收 `children`，它表示当前 `VNode` 的子节点，因为它是任意类型的，所以接下来需要将其规范为标准的 `VNode` 数组；\n\n```js\n// 这里规范化 children\nif (normalizationType === ALWAYS_NORMALIZE) {\n  children = normalizeChildren(children)\n} else if (normalizationType === SIMPLE_NORMALIZE) {\n  children = simpleNormalizeChildren(children)\n}\n```\n\n`simpleNormalizeChildren` 和 `normalizeChildren`   均用于规范化 `children`。由 `normalizationType` 判断 `render` 函数是编译生成的还是用户自定义的。\n\n```js\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nexport function simpleNormalizeChildren (children: any) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nexport function normalizeChildren (children: any): ?Array<VNode> {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n```\n\n`simpleNormalizeChildren` 方法调用场景是 render 函数当函数是编译生成的。`normalizeChildren` 方法的调用场景主要是 render 函数是用户手写的。\n\n经过对 `children` 的规范化，`children` 变成了一个类型为 `VNode` 的数组。之后就是创建 `VNode` 的逻辑。\n\n```js\n// src/core/vdom/patch.js\nlet vnode, ns\nif (typeof tag === 'string') {\n  let Ctor\n  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n  if (config.isReservedTag(tag)) {\n    // platform built-in elements\n    vnode = new VNode(\n      config.parsePlatformTagName(tag), data, children,\n      undefined, undefined, context\n    )\n  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n    // component\n    vnode = createComponent(Ctor, data, context, children, tag)\n  } else {\n    // unknown or unlisted namespaced elements\n    // check at runtime because it may get assigned a namespace when its\n    // parent normalizes children\n    vnode = new VNode(\n      tag, data, children,\n      undefined, undefined, context\n    )\n  }\n} else {\n  // direct component options / constructor\n  vnode = createComponent(tag, data, context, children)\n}\n```\n\n如果 `tag` 是 `string` 类型，则接着判断如果是内置的一些节点，创建一个普通 `VNode`；如果是为已注册的组件名，则通过 `createComponent` 创建一个组件类型的 `VNode`；否则创建一个未知的标签的 `VNode`。 \n\n如果 `tag` 不是 `string` 类型，那就是 `Component` 类型, 则直接调用 `createComponent` 创建一个组件类型的 `VNode` 节点。\n\n最后 `_createElement` 会返回一个 `VNode`，也就是调用 `vm._render` 时创建得到的`VNode`。之后 `VNode` 会传递给 `vm._update` 函数，用于生成真实dom。\n\n## 生成真实dom(_update)\n\n```js\n// src/core/instance/lifecycle.js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  const prevEl = vm.$el\n  const prevVnode = vm._vnode\n  const prevActiveInstance = activeInstance\n  activeInstance = vm\n  vm._vnode = vnode\n  // Vue.prototype.__patch__ is injected in entry points\n  // based on the rendering backend used.\n  if (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  activeInstance = prevActiveInstance\n  // update __vue__ reference\n  if (prevEl) {\n    prevEl.__vue__ = null\n  }\n  if (vm.$el) {\n    vm.$el.__vue__ = vm\n  }\n  // if parent is an HOC, update its $el as well\n  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n    vm.$parent.$el = vm.$el\n  }\n  // updated hook is called by the scheduler to ensure that children are\n  // updated in a parent's updated hook.\n}\n```\n\n`_update` 里最核心的方法就是 `vm.__patch__` 方法，不同平台的 `__patch__` 方法的定义会稍有不同，在 web 平台中它是这样定义的：\n\n```js\n// src/platforms/web/runtime/index.js\nimport { patch } from './patch'\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n```\n\n可以看到 `__patch__` 实际调用的是 `patch` 方法。\n\n```js\n// src/platforms/web/runtime/patch.js\nimport * as nodeOps from 'web/runtime/node-ops'\nimport { createPatchFunction } from 'core/vdom/patch'\nimport baseModules from 'core/vdom/modules/index'\nimport platformModules from 'web/runtime/modules/index'\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nconst modules = platformModules.concat(baseModules)\n\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n```\n\n而 `patch` 方法是由 `createPatchFunction` 方法创建返回出来的函数。\n\n```js\n// src/core/vdom/patch.js\nconst hooks = ['create', 'activate', 'update', 'remove', 'destroy']\n\nexport function createPatchFunction (backend) {\n  let i, j\n  const cbs = {}\n  const { modules, nodeOps } = backend\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = []\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]])\n      }\n    }\n  }\n  \n  // ...\n  return function patch (oldVnode, vnode, hydrating, removeOnly){}\n}\n```\n\n这里有两个比较重要的对象 `nodeOps` 和 `modules`。`nodeOps` 是封装的原生dom操作方法，在生成真实节点树的过程中，dom相关操作都是调用 `nodeOps` 内的方法。\n\n`modules` 是待执行的钩子函数。在进入函数时，会将不同模块的钩子函数分类放置到 `cbs` 中，其中包括自定义指令钩子函数，ref 钩子函数。在 `patch` 阶段，会根据操作节点的行为取出对应类型进行调用。\n\n### patch\n\n```js\n// initial render\nvm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n```\n\n在首次渲染时，`vm.$el` 对应的是根节点 dom 对象，也就是我们熟知的 id 为 app 的 div。它作为 `oldVNode` 参数传入 `patch`：\n\n```js\nreturn function patch (oldVnode, vnode, hydrating, removeOnly) {\n  if (isUndef(vnode)) {\n    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n    return\n  }\n\n  let isInitialPatch = false\n  const insertedVnodeQueue = []\n\n  if (isUndef(oldVnode)) {\n    // empty mount (likely as component), create new root element\n    isInitialPatch = true\n    createElm(vnode, insertedVnodeQueue)\n  } else {\n    const isRealElement = isDef(oldVnode.nodeType)\n    if (!isRealElement && sameVnode(oldVnode, vnode)) {\n      // patch existing root node\n      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)\n    } else {\n      if (isRealElement) {\n        // mounting to a real element\n        // check if this is server-rendered content and if we can perform\n        // a successful hydration.\n        if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n          oldVnode.removeAttribute(SSR_ATTR)\n          hydrating = true\n        }\n        if (isTrue(hydrating)) {\n          if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n            invokeInsertHook(vnode, insertedVnodeQueue, true)\n            return oldVnode\n          } else if (process.env.NODE_ENV !== 'production') {\n            warn(\n              'The client-side rendered virtual DOM tree is not matching ' +\n              'server-rendered content. This is likely caused by incorrect ' +\n              'HTML markup, for example nesting block-level elements inside ' +\n              '<p>, or missing <tbody>. Bailing hydration and performing ' +\n              'full client-side render.'\n            )\n          }\n        }\n        // either not server-rendered, or hydration failed.\n        // create an empty node and replace it\n        oldVnode = emptyNodeAt(oldVnode)\n      }\n\n      // replacing existing element\n      const oldElm = oldVnode.elm\n      const parentElm = nodeOps.parentNode(oldElm)\n\n      // create new node\n      createElm(\n        vnode,\n        insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm,\n        nodeOps.nextSibling(oldElm)\n      )\n\n      // update parent placeholder node element, recursively\n      if (isDef(vnode.parent)) {\n        let ancestor = vnode.parent\n        const patchable = isPatchable(vnode)\n        while (ancestor) {\n          for (let i = 0; i < cbs.destroy.length; ++i) {\n            cbs.destroy[i](ancestor)\n          }\n          ancestor.elm = vnode.elm\n          if (patchable) {\n            for (let i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, ancestor)\n            }\n            // #6513\n            // invoke insert hooks that may have been merged by create hooks.\n            // e.g. for directives that uses the \"inserted\" hook.\n            const insert = ancestor.data.hook.insert\n            if (insert.merged) {\n              // start at index 1 to avoid re-invoking component mounted hook\n              for (let i = 1; i < insert.fns.length; i++) {\n                insert.fns[i]()\n              }\n            }\n          } else {\n            registerRef(ancestor)\n          }\n          ancestor = ancestor.parent\n        }\n      }\n\n      // destroy old node\n      if (isDef(parentElm)) {\n        removeVnodes([oldVnode], 0, 0)\n      } else if (isDef(oldVnode.tag)) {\n        invokeDestroyHook(oldVnode)\n      }\n    }\n  }\n\n  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n  return vnode.elm\n}\n```\n\n通过检查属性 `nodeType`（真实节点才有的属性）， 判断 `oldVnode` 是否为真实节点。\n\n```js\nconst isRealElement = isDef(oldVnode.nodeType)\nif (isRealElement) {\n  // ...\n  oldVnode = emptyNodeAt(oldVnode)\n}\n```\n\n很明显第一次的 `isRealElement` 是为 `true`，因此会调用 `emptyNodeAt` 将其转为 `VNode`：\n\n```js\nfunction emptyNodeAt (elm) {\n  return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n}\n```\n\n接着会调用 `createElm` 方法，它就是将 `VNode` 转为真实dom 的核心方法：\n\n```js\nfunction createElm (\n  vnode,\n  insertedVnodeQueue,\n  parentElm,\n  refElm,\n  nested,\n  ownerArray,\n  index\n) {\n  if (isDef(vnode.elm) && isDef(ownerArray)) {\n    // This vnode was used in a previous render!\n    // now it's used as a new node, overwriting its elm would cause\n    // potential patch errors down the road when it's used as an insertion\n    // reference node. Instead, we clone the node on-demand before creating\n    // associated DOM element for it.\n    vnode = ownerArray[index] = cloneVNode(vnode)\n  }\n\n  vnode.isRootInsert = !nested // for transition enter check\n  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n    return\n  }\n\n  const data = vnode.data\n  const children = vnode.children\n  const tag = vnode.tag\n  if (isDef(tag)) {\n    vnode.elm = vnode.ns\n      ? nodeOps.createElementNS(vnode.ns, tag)\n      : nodeOps.createElement(tag, vnode)\n    setScope(vnode)\n\n    /* istanbul ignore if */\n    if (__WEEX__) {\n      // ...\n    } else {\n      createChildren(vnode, children, insertedVnodeQueue)\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue)\n      }\n      insert(parentElm, vnode.elm, refElm)\n    }\n\n    if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n      creatingElmInVPre--\n    }\n  } else if (isTrue(vnode.isComment)) {\n    vnode.elm = nodeOps.createComment(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n  } else {\n    vnode.elm = nodeOps.createTextNode(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n  }\n}\n```\n\n一开始会调用 `createComponent` 尝试创建组件类型的节点，如果成功会返回 `true`。在创建过程中也会调用 `$mount` 进行组件范围内的挂载，所以走的还是 `patch` 这套流程。\n\n```js\nif (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n  return\n}\n```\n\n如果没有完成创建，代表该 `VNode` 对应的是真实节点，往下继续创建真实节点的逻辑。 \n\n```js\nvnode.elm = vnode.ns\n    ? nodeOps.createElementNS(vnode.ns, tag)\n    : nodeOps.createElement(tag, vnode)\n```\n\n根据 `tag` 创建对应类型真实节点，赋值给 `vnode.elm`，它作为父节点容器，创建的子节点会被放到里面。\n\n然后调用 `createChildren` 创建子节点：\n\n```js\nfunction createChildren (vnode, children, insertedVnodeQueue) {\n  if (Array.isArray(children)) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(children)\n    }\n    for (let i = 0; i < children.length; ++i) {\n      createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)\n    }\n  } else if (isPrimitive(vnode.text)) {\n    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))\n  }\n}\n```\n\n内部进行遍历子节点数组，再次调用 `createElm` 创建节点，而上面创建的 `vnode.elm` 作为父节点传入。如此循环，直到没有子节点，就会创建文本节点插入到 `vnode.elm` 中。\n\n执行完成后出来，会调用 `invokeCreateHooks`，它负责执行 dom 操作时的 `create` 钩子函数，同时将 `VNode` 加入到 `insertedVnodeQueue` 中：\n\n```js\nfunction invokeCreateHooks (vnode, insertedVnodeQueue) {\n  for (let i = 0; i < cbs.create.length; ++i) {\n    cbs.create[i](emptyNode, vnode)\n  }\n  i = vnode.data.hook // Reuse variable\n  if (isDef(i)) {\n    if (isDef(i.create)) i.create(emptyNode, vnode)\n    if (isDef(i.insert)) insertedVnodeQueue.push(vnode)\n  }\n}\n```\n\n最后一步就是调用 `insert` 方法将节点插入到父节点：\n\n```js\nfunction insert (parent, elm, ref) {\n  if (isDef(parent)) {\n    if (isDef(ref)) {\n      if (nodeOps.parentNode(ref) === parent) {\n        nodeOps.insertBefore(parent, elm, ref)\n      }\n    } else {\n      nodeOps.appendChild(parent, elm)\n    }\n  }\n}\n```\n\n可以看到 `Vue` 是通过递归调用 `createElm` 来创建节点树的。同时也说明最深的子节点会先调用 `insert` 插入节点。所以整个节点树的插入顺序是“先子后父”。插入节点方法就是原生dom的方法 `insertBefore` 和 `appendChild`。\n\n\n```js\nif (isDef(parentElm)) {\n  removeVnodes([oldVnode], 0, 0)\n}\n```\n\n`createElm` 流程走完后，构建完成的节点树已经插入到页面上了。其实 `Vue` 在初始化渲染页面时，并不是把原来的根节点 `app` 给真正替换掉，而是在其后面插入一个新的节点，接着再把旧节点给移除掉。\n\n所以在 `createElm` 之后会调用 `removeVnodes` 来移除旧节点，它里面同样是调用的原生dom方法 `removeChild`。\n\n\n```js\ninvokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n```\n\n```js\nfunction invokeInsertHook (vnode, queue, initial) {\n  // delay insert hooks for component root nodes, invoke them after the\n  // element is really inserted\n  if (isTrue(initial) && isDef(vnode.parent)) {\n    vnode.parent.data.pendingInsert = queue\n  } else {\n    for (let i = 0; i < queue.length; ++i) {\n      queue[i].data.hook.insert(queue[i])\n    }\n  }\n}\n```\n\n在 `patch` 的最后就是调用 `invokeInsertHook` 方法，触发节点插入的钩子函数。\n\n至此整个页面渲染的流程完毕~\n\n## 总结\n\n![](https://static.ecool.fun//article/9f3602e1-b65b-4bc0-bdff-d226d4575634.png)\n\n初始化调用 `$mount` 挂载组件。\n\n`_render` 开始构建 `VNode`，核心方法为 `createElement`，一般会创建普通的 `VNode` ，遇到组件就创建组件类型的 `VNode`，否则就是未知标签的 `VNode`，构建完成传递给 `_update`。\n\n`patch` 阶段根据 `VNode` 创建真实节点树，核心方法为 `createElm`，首先遇到组件类型的 `VNode`，内部会执行 `$mount`，再走一遍相同的流程。普通节点类型则创建一个真实节点，如果它有子节点开始递归调用 `createElm`，使用 `insert` 插入子节点，直到没有子节点就填充内容节点。最后递归完成后，同样也是使用 `insert` 将整个节点树插入到页面中，再将旧的根节点移除。\n\n\n",
    "level": 4,
    "status": 2,
    "appId": 7,
    "createAt": "2022-04-05T07:51:16.000Z",
    "updateAt": "2024-01-25T19:47:39.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 37,
    "prev": "26f1a1e7-1bfd-4a0c-91b1-4e1c8455f60a",
    "next": "9b19862a-b226-4a56-95d4-5ab4b05024bb"
  },
  "post": {
    "exerciseKey": "6201f33e-f962-4cdc-ab01-59d03993fed8",
    "category": "QA",
    "title": "说说Vue 页面渲染流程",
    "level": 4,
    "updateAt": "2024-01-25T19:47:39+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 68
  }
}
