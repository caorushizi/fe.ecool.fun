{
  "data": {
    "id": 2872,
    "exerciseKey": "d0fd3a52-1ddf-42b2-b9d8-f36fc885d237",
    "category": "QA",
    "renderType": "md",
    "title": "说说你对 Promise 的了解？",
    "desc": "",
    "options": "",
    "explanation": "# Promise 对象\n\n### 1、Promise 的含义\nPromise 是异步编程的一种解决方案，比传统的解决方案 —— 回调函数和事件 —— 更合理和更强大。它由社区最早提出和实现， ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n\nPromise对象有以下两个特点。           \n\n**（ 1 ）对象的状态不受外界影响。**\nPromise对象代表一个异步操作，**有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled ）和Rejected（已失败）**。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是 “ 承诺 ” ，表示其他手段无法改变。      \n     \n**（ 2 ）一旦状态改变，就不会再变，任何时候都可以得到这个结果。**\nPromise对象的状态改变，**只有两种可能：从Pending变为Resolved和从Pending变为Rejected**。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（ Event ）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。             \n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。         \nPromise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。            \n\n### 2、基本用法\n\n实例1：基本用法        \n```javascript\n    var promise = new Promise(function(resolve, reject) {\n    \t// ... some code\n        if (/*  异步操作成功 */){\n            resolve(value);\n        } else {\n            reject(error);\n        }\n    });\n```\n\n实例2：只要一new Promise后就会立即执行。          \n```javascript\n    let promise = new Promise(function(resolve, reject) {\n        console.log('Promise');\n        resolve();\n    });\n    promise.then(function() {\n        console.log('Resolved.');\n    });\n    console.log('Hi!');\n    // Promise\n    // Hi!\n    // Resolved\n```\n\n实例3：下面是一个用 Promise 对象实现的 Ajax 操作的例子。（非常经典）          \n```javascript\n    var getJSON = function (url) {\n        var promise = new Promise(function (resolve, reject) {\n            var client = new XMLHttpRequest();\n            client.open(\"GET\", url);\n            client.onreadystatechange = handler;\n            client.responseType = \"json\";\n            client.setRequestHeader(\"Accept\", \"application/json\");\n            client.send();\n    \n            function handler() {\n                if (this.readyState !== 4) {\n                    return;\n                }\n                if (this.status === 200) {\n                    resolve(this.response);\n                } else {\n                    reject(new Error(this.statusText));\n                }\n            };\n        });\n        return promise;\n    };\n    \n    getJSON(\"/posts.json\").then(function (json) {\n        console.log('Contents: ' + json);\n    }, function (error) {\n        console.error(' 出错了 ', error);\n    });\n```\n\n### 3、Promise.prototype.then()\n\nPromise 实例具有then方法，也就是说，then方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数。          \nthen方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。           \n```javascript\n    getJSON(\"/posts.json\").then(function(json) {\n        return json.post;\n    }).then(function(post) {\n        // ...\n    });\n```\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。           \n```javascript\n    getJSON(\"/post/1.json\").then(function (post) {\n        return getJSON(post.commentURL);\n    }).then(function funcA(comments) {\n        console.log(\"Resolved: \", comments);\n    }, function funcB(err) {\n        console.log(\"Rejected: \", err);\n    });\n```\n\n上面代码中，第一个then方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个then方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 Resolved ，就调用funcA，如果状态变为 Rejected ，就调用funcB。              \n\n\n### 4、Promise.prototype.catch()     \nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。         \n实例：     \n```javascript\n    getJSON(\"/posts.json\").then(function (posts) {\n        // ...\n    }).catch(function (error) {\n        //  处理 getJSON  和 前一个回调函数运行时发生的错误\n        console.log(' 发生错误！ ', error);\n    });\n```\n\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数， Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。           \n```javascript\n    var someAsyncThing = function () {\n        return new Promise(function (resolve, reject) {\n        //  下面一行会报错，因为 x 没有声明\n            resolve(x + 2);\n        });\n    };\n    someAsyncThing().then(function () {\n        console.log('everything is great');\n    });\n```\n\n### 5、Promise.all()     \nPromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。           \nvar p = Promise.all([p1, p2, p3]);          \n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 对象的实例。             \n\n实例：         \n```javascript\n    Promise.all([checkLogin(),getUserInfo()]).then(([res1,res2])=>{\n        console.log(`result1:${res1.result}, result2:${res2.userID}`)\n    });\n```\n\n### 6、Promise.race()            \nPromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。\n\n\n### 7、Promise.resolve()         \n有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。        \n```javascript\n    var jsPromise = Promise.resolve($.ajax('/whatever.json'));  \n```\n\n### 8、Promise.reject()          \nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。               \n\n\n### 9、两个有用的附加方法         \nES6 的 Promise API 提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在 ES6 之中、但很有用的方法。          \n#### 9.1、done()     \nPromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。              \n```javascript\n    asyncFunc()\n        .then(f1)\n        .catch(r1)\n        .then(f2)\n        .done();\n```\n\n#### 9.2、finally()      \nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。               \n```javascript\n    server.listen(0)\n        .then(function () {\n    // run test\n        })\n        .finally(server.stop);\n```\n\n### 10、Promise的使用           \n使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。          \n```javascript\n    function getFoo() {\n        return new Promise(function (resolve, reject) {\n            resolve('foo');\n        });\n    }\n    \n    var g = function* () {\n        try {\n            var foo = yield getFoo();\n            console.log(foo);\n        } catch (e) {\n            console.log(e);\n        }\n    };\n    \n    function run(generator) {\n        var it = generator();\n    \n        function go(result) {\n            if (result.done) return result.value;\n            return result.value.then(function (value) {\n                return go(it.next(value));\n            }, function (error) {\n                return go(it.throw(error));\n            });\n        }\n    \n        go(it.next());\n    }\n    \n    run(g);\n```",
    "pivot": "",
    "vipLimit": 1,
    "level": 2,
    "appId": 7,
    "createAt": "2024-08-13T08:30:45.000Z",
    "updateAt": "2024-08-14T12:01:15.000Z",
    "isCollected": false,
    "currentIndex": 14,
    "filterTotalNum": 1487,
    "prev": "b7e5c9a8-6756-4c79-9b75-a3cb680e12b4",
    "next": "abdeb82d-40b0-495f-9e06-093d1b74ea65"
  },
  "post": {
    "exerciseKey": "d0fd3a52-1ddf-42b2-b9d8-f36fc885d237",
    "category": "QA",
    "title": "说说你对 Promise 的了解？",
    "level": 2,
    "createAt": "2024-08-13T08:30:45+00:00",
    "updateAt": "2024-08-14T12:01:15+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 379
  }
}