{
  "data": {
    "id": 186,
    "exerciseKey": "70db8e81-b858-4f3a-8bf9-d2bd1eb142e2",
    "category": "QA",
    "renderType": "md",
    "title": "你是怎么理解ES6中Proxy的？使用场景有哪些?",
    "desc": null,
    "options": null,
    "explanation": "## 一、介绍\n\n**定义：** 用于定义基本操作的自定义行为\n\n**本质：** 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程`(meta programming)`\n\n元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作\n\n一段代码来理解\n```bash\n#!/bin/bash\n# metaprogram\necho '#!/bin/bash' >program\nfor ((I=1; I<=1024; I++)) do\n    echo \"echo $I\" >>program\ndone\nchmod +x program\n```\n这段程序每执行一次能帮我们生成一个名为`program`的文件，文件内容为1024行`echo`，如果我们手动来写1024行代码，效率显然低效\n\n- 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译\n\n`Proxy` 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）\n\n\n## 二、用法\n\n`Proxy`为 构造函数，用来生成 `Proxy `实例\n\n```javascript\nvar proxy = new Proxy(target, handler)\n```\n\n### 参数\n\n`target`表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））\n\n`handler`通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为\n\n\n\n### handler解析\n\n关于`handler`拦截属性，有如下：\n\n- get(target,propKey,receiver)：拦截对象属性的读取\n- set(target,propKey,value,receiver)：拦截对象属性的设置\n- has(target,propKey)：拦截`propKey in proxy`的操作，返回一个布尔值\n- deleteProperty(target,propKey)：拦截`delete proxy[propKey]`的操作，返回一个布尔值\n- ownKeys(target)：拦截`Object.keys(proxy)`、`for...in`等循环，返回一个数组\n- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象\n- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc）`，返回一个布尔值\n- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值\n- getPrototypeOf(target)：拦截`Object.getPrototypeOf(proxy)`，返回一个对象\n- isExtensible(target)：拦截`Object.isExtensible(proxy)`，返回一个布尔值\n- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值\n- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作\n- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作\n\n\n\n\n\n### Reflect\n\n若需要在`Proxy`内部调用对象的默认行为，建议使用`Reflect`，其是`ES6`中操作对象而提供的新 `API`\n\n基本特点：\n\n- 只要`Proxy`对象具有的代理方法，`Reflect`对象全部具有，以静态方法的形式存在\n- 修改某些`Object`方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回`false`）\n- 让`Object`操作都变成函数行为      \n\n\n\n下面我们介绍`proxy`几种用法：\n\n### get()\n\n`get`接受三个参数，依次为目标对象、属性名和 `proxy` 实例本身，最后一个参数可选\n\n```javascript\nvar person = {\n  name: \"张三\"\n};\n\nvar proxy = new Proxy(person, {\n  get: function(target, propKey) {\n    return Reflect.get(target,propKey)\n  }\n});\n\nproxy.name // \"张三\"\n```\n\n`get`能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引\n\n```js\nfunction createArray(...elements) {\n  let handler = {\n    get(target, propKey, receiver) {\n      let index = Number(propKey);\n      if (index < 0) {\n        propKey = String(target.length + index);\n      }\n      return Reflect.get(target, propKey, receiver);\n    }\n  };\n\n  let target = [];\n  target.push(...elements);\n  return new Proxy(target, handler);\n}\n\nlet arr = createArray('a', 'b', 'c');\narr[-1] // c\n```\n\n注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错\n\n```js\nconst target = Object.defineProperties({}, {\n  foo: {\n    value: 123,\n    writable: false,\n    configurable: false\n  },\n});\n\nconst handler = {\n  get(target, propKey) {\n    return 'abc';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.foo\n// TypeError: Invariant check failed\n```\n\n\n\n### set()\n\n`set`方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 `Proxy` 实例本身\n\n假定`Person`对象有一个`age`属性，该属性应该是一个不大于 200 的整数，那么可以使用`Proxy`保证`age`的属性值符合要求\n\n```js\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    obj[prop] = value;\n  }\n};\n\nlet person = new Proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n```\n\n如果目标对象自身的某个属性，不可写且不可配置，那么`set`方法将不起作用\n\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'foo', {\n  value: 'bar',\n  writable: false,\n});\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = 'baz';\n  }\n};\n\nconst proxy = new Proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n```\n\n注意，严格模式下，`set`代理如果没有返回`true`，就会报错\n\n```javascript\n'use strict';\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    // 无论有没有下面这一行，都会报错\n    return false;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\n// TypeError: 'set' on proxy: trap returned falsish for property 'foo'\n```\n\n\n\n### deleteProperty()\n\n`deleteProperty`方法用于拦截`delete`操作，如果这个方法抛出错误或者返回`false`，当前属性就无法被`delete`命令删除\n\n```javascript\nvar handler = {\n  deleteProperty (target, key) {\n    invariant(key, 'delete');\n    Reflect.deleteProperty(target,key)\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`无法删除私有属性`);\n  }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n// Error: 无法删除私有属性\n```\n\n注意，目标对象自身的不可配置（configurable）的属性，不能被`deleteProperty`方法删除，否则报错\n\n\n\n### 取消代理\n\n```\nProxy.revocable(target, handler);\n```\n\n## 三、使用场景\n\n`Proxy`其功能非常类似于设计模式中的代理模式，常用功能如下：\n\n- 拦截和监视外部对对象的访问\n- 降低函数或类的复杂度\n- 在复杂操作前对操作进行校验或对所需资源进行管理\n\n\n\n使用 `Proxy` 保障数据类型的准确性\n\n```js\nlet numericDataStore = { count: 0, amount: 1234, total: 14 };\nnumericDataStore = new Proxy(numericDataStore, {\n    set(target, key, value, proxy) {\n        if (typeof value !== 'number') {\n            throw Error(\"属性只能是number类型\");\n        }\n        return Reflect.set(target, key, value, proxy);\n    }\n});\n\nnumericDataStore.count = \"foo\"\n// Error: 属性只能是number类型\n\nnumericDataStore.count = 333\n// 赋值成功\n```\n\n声明了一个私有的 `apiKey`，便于 `api` 这个对象内部的方法调用，但不希望从外部也能够访问 `api._apiKey`\n\n```js\nlet api = {\n    _apiKey: '123abc456def',\n    getUsers: function(){ },\n    getUser: function(userId){ },\n    setUser: function(userId, config){ }\n};\nconst RESTRICTED = ['_apiKey'];\napi = new Proxy(api, {\n    get(target, key, proxy) {\n        if(RESTRICTED.indexOf(key) > -1) {\n            throw Error(`${key} 不可访问.`);\n        } return Reflect.get(target, key, proxy);\n    },\n    set(target, key, value, proxy) {\n        if(RESTRICTED.indexOf(key) > -1) {\n            throw Error(`${key} 不可修改`);\n        } return Reflect.get(target, key, value, proxy);\n    }\n});\n\nconsole.log(api._apiKey)\napi._apiKey = '987654321'\n// 上述都抛出错误\n```\n\n还能通过使用`Proxy`实现观察者模式\n\n观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\n\n`observable`函数返回一个原始对象的 `Proxy` 代理，拦截赋值操作，触发充当观察者的各个函数\n\n```javascript\nconst queuedObservers = new Set();\n\nconst observe = fn => queuedObservers.add(fn);\nconst observable = obj => new Proxy(obj, {set});\n\nfunction set(target, key, value, receiver) {\n  const result = Reflect.set(target, key, value, receiver);\n  queuedObservers.forEach(observer => observer());\n  return result;\n}\n```\n\n观察者函数都放进`Set`集合，当修改`obj`的值，在会`set`函数中拦截，自动执行`Set`所有的观察者\n",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-03T13:37:50.000Z",
    "updateAt": "2024-01-24T17:32:06.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 173,
    "prev": "c9d672a0-9abe-46ec-812b-fd198f1e79f4",
    "next": "6b4f3ad8-5cd8-49f3-941c-c916615546d0"
  },
  "post": {
    "exerciseKey": "70db8e81-b858-4f3a-8bf9-d2bd1eb142e2",
    "category": "QA",
    "title": "你是怎么理解ES6中Proxy的？使用场景有哪些?",
    "level": 3.5,
    "updateAt": "2024-01-24T17:32:06+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}