{
  "data": {
    "id": 183,
    "exerciseKey": "4232c372-316f-4a53-99b9-6d9299b7e91f",
    "category": "QA",
    "renderType": "md",
    "title": "ES6中新增的Set、Map两种数据结构怎么理解?",
    "desc": null,
    "options": null,
    "explanation": "如果要用一句来描述，我们可以说\n\n`Set`是一种叫做集合的数据结构，`Map`是一种叫做字典的数据结构\n\n什么是集合？什么又是字典？\n\n- 集合  \n是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合\n\n- 字典   \n是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同\n\n区别？\n\n- 共同点：集合、字典都可以存储不重复的值\n- 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储\n\n## 一、Set\n\n` Set`是`es6`新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合\n\n`Set`本身是一个构造函数，用来生成 Set 数据结构\n\n```js\nconst s = new Set();\n```\n\n\n\n### 增删改查\n\n`Set`的实例关于增删改查的方法：\n\n- add()\n- delete()\n\n- has()\n- clear()\n\n### add()\n\n添加某个值，返回 `Set` 结构本身\n\n当添加实例中已经存在的元素，`set`不会进行处理添加\n\n```js\ns.add(1).add(2).add(2); // 2只被添加了一次\n```\n\n### delete()\n\n删除某个值，返回一个布尔值，表示删除是否成功\n\n```js\ns.delete(1)\n```\n\n### has()\n\n返回一个布尔值，判断该值是否为`Set`的成员\n\n```js\ns.has(2)\n```\n\n### clear()\n\n清除所有成员，没有返回值\n\n```js\ns.clear()\n```\n\n\n\n### 遍历\n\n`Set`实例遍历的方法有如下：\n\n关于遍历的方法，有如下：\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n`Set`的遍历顺序就是插入顺序\n\n`keys`方法、`values`方法、`entries`方法返回的都是遍历器对象\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n```\n\n`forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this`\n\n```javascript\nlet set = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n```\n\n扩展运算符和` Set` 结构相结合实现数组或字符串去重\n\n```javascript\n// 数组\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)]; // [3, 5, 2]\n\n// 字符串\nlet str = \"352255\";\nlet unique = [...new Set(str)].join(\"\"); // \"352\"\n```\n\n实现并集、交集、和差集\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n\n\n## 二、Map\n\n`Map`类型是键值对的有序列表，而键和值都可以是任意类型\n\n`Map`本身是一个构造函数，用来生成 `Map` 数据结构\n\n```js\nconst m = new Map()\n```\n\n\n\n### 增删改查\n\n`Map` 结构的实例针对增删改查有以下属性和操作方法：\n\n- size 属性\n- set()\n- get()\n- has()\n- delete()\n- clear()\n\n### size\n\n`size`属性返回 Map 结构的成员总数。\n\n```javascript\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n```\n\n\n\n### set()\n\n设置键名`key`对应的键值为`value`，然后返回整个 Map 结构\n\n如果`key`已经有值，则键值会被更新，否则就新生成该键\n\n同时返回的是当前`Map`对象，可采用链式写法\n\n```javascript\nconst m = new Map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\nm.set(1, 'a').set(2, 'b').set(3, 'c') // 链式操作\n```\n\n\n\n### get()\n\n`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`\n\n```javascript\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n```\n\n\n\n### has()\n\n`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n```javascript\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n```\n\n\n\n### delete()\n\n`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`\n\n```javascript\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n```\n\n### clear()\n\n`clear`方法清除所有成员，没有返回值\n\n```javascript\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n```\n\n\n\n### 遍历\n\n`Map `结构原生提供三个遍历器生成函数和一个遍历方法：\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：遍历 Map 的所有成员\n\n遍历顺序就是插入顺序\n\n```javascript\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n```\n\n## 三、WeakSet 和 WeakMap\n\n### WeakSet\n\n创建`WeakSet`实例\n\n```js\nconst ws = new WeakSet();\n```\n\n`WeakSet `可以接受一个具有 `Iterable `接口的对象作为参数\n\n```js\nconst a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n```\n\n在`API`中`WeakSet`与`Set`有两个区别：\n\n- 没有遍历操作的`API`\n- 没有`size`属性\n\n`WeakSet`只能成员只能是引用类型，而不能是其他类型的值\n\n```js\nlet ws=new WeakSet();\n\n// 成员不是引用类型\nlet weakSet=new WeakSet([2,3]);\nconsole.log(weakSet) // 报错\n\n// 成员为引用类型\nlet obj1={name:1}\nlet obj2={name:1}\nlet ws=new WeakSet([obj1,obj2]); \nconsole.log(ws) //WeakSet {{…}, {…}}\n```\n\n`WeakSet `里面的引用只要在外部消失，它在 `WeakSet `里面的引用就会自动消失\n\n\n\n### WeakMap\n\n`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合\n\n在`API`中`WeakMap`与`Map`有两个区别：\n\n- 没有遍历操作的`API`\n- 没有`clear`清空方法\n\n```javascript\n// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);\nwm2.get(k2) // \"bar\"\n```\n\n`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名\n\n```javascript\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\nmap.set(null, 2)\n// TypeError: Invalid value used as weak map key\n```\n\n`WeakMap`的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用\n\n举个场景例子：\n\n在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构，当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除\n\n```javascript\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n```\n\n注意：`WeakMap` 弱引用的只是键名，而不是键值。键值依然是正常引用\n\n下面代码中，键值`obj`会在`WeakMap`产生新的引用，当你修改`obj`不会影响到内部\n\n```js\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n```\n\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 2,
    "appId": 7,
    "createAt": "2021-07-03T13:36:29.000Z",
    "updateAt": "2024-07-20T09:48:07.000Z",
    "isCollected": false,
    "currentIndex": 1316,
    "filterTotalNum": 1487,
    "prev": "34d5eef9-20cb-4aac-b34b-87ab513456a7",
    "next": "9cf9cb30-8864-4823-bf2d-d30b5f079f45"
  },
  "post": {
    "exerciseKey": "4232c372-316f-4a53-99b9-6d9299b7e91f",
    "category": "QA",
    "title": "ES6中新增的Set、Map两种数据结构怎么理解?",
    "level": 2,
    "createAt": "2021-07-03T13:36:29+00:00",
    "updateAt": "2024-07-20T09:48:07+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 379
  }
}