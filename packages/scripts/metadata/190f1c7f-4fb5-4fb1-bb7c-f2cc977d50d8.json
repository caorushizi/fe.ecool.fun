{
  "data": {
    "id": 650,
    "exerciseKey": "190f1c7f-4fb5-4fb1-bb7c-f2cc977d50d8",
    "category": "QA",
    "renderType": "md",
    "title": "说说React服务端渲染怎么做？原理是什么？",
    "desc": null,
    "options": null,
    "explanation": "## 一、是什么\n\n服务端渲染（`Server-Side Rendering` ，简称`SSR`），指由服务侧完成页面的 `HTML` 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程\n\n ![](https://static.ecool.fun//article/27578d0b-7e0c-445e-8dab-7e3b19c5b9e6.png)\n\n其解决的问题主要有两个：\n\n- SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面\n- 加速首屏加载，解决首屏白屏问题\n\n\n## 二、如何做\n\n在`react`中，实现`SSR`主要有两种形式：\n\n- 手动搭建一个 SSR 框架\n- 使用成熟的SSR 框架，如 Next.JS\n\n\n这里主要以手动搭建一个`SSR`框架进行实现\n\n首先通过`express`启动一个`app.js`文件，用于监听3000端口的请求，当请求根目录时，返回`HTML`，如下：\n\n```js\nconst express = require('express')\nconst app = express()\napp.get('/', (req,res) => res.send(`\n<html>\n   <head>\n       <title>ssr demo</title>\n   </head>\n   <body>\n       Hello world\n   </body>\n</html>\n`))\n\napp.listen(3000, () => console.log('Exampleapp listening on port 3000!'))\n```\n\n然后再服务器中编写`react`代码，在`app.js`中进行应引用\n\n```jsx\nimport React from 'react'\n\nconst Home = () =>{\n\n    return <div>home</div>\n\n}\n\nexport default Home\n```\n\n为了让服务器能够识别`JSX`，这里需要使用`webpakc`对项目进行打包转换，创建一个配置文件`webpack.server.js`并进行相关配置，如下：\n\n```js\nconst path = require('path')    //node的path模块\nconst nodeExternals = require('webpack-node-externals')\n\nmodule.exports = {\n    target:'node',\n    mode:'development',           //开发模式\n    entry:'./app.js',             //入口\n    output: {                     //打包出口\n        filename:'bundle.js',     //打包后的文件名\n        path:path.resolve(__dirname,'build')    //存放到根目录的build文件夹\n    },\n    externals: [nodeExternals()],  //保持node中require的引用方式\n    module: {\n        rules: [{                  //打包规则\n           test:   /\\.js?$/,       //对所有js文件进行打包\n           loader:'babel-loader',  //使用babel-loader进行打包\n           exclude: /node_modules/,//不打包node_modules中的js文件\n           options: {\n               presets: ['react','stage-0',['env', { \n                                  //loader时额外的打包规则,对react,JSX，ES6进行转换\n                    targets: {\n                        browsers: ['last 2versions']   //对主流浏览器最近两个版本进行兼容\n                    }\n               }]]\n           }\n       }]\n    }\n}\n```\n\n接着借助`react-dom`提供了服务端渲染的 `renderToString`方法，负责把`React`组件解析成`html`\n\n```js\nimport express from 'express'\nimport React from 'react'//引入React以支持JSX的语法\nimport { renderToString } from 'react-dom/server'//引入renderToString方法\nimport Home from'./src/containers/Home'\n\nconst app= express()\nconst content = renderToString(<Home/>)\napp.get('/',(req,res) => res.send(`\n<html>\n   <head>\n       <title>ssr demo</title>\n   </head>\n   <body>\n        ${content}\n   </body>\n</html>\n`))\n\napp.listen(3001, () => console.log('Exampleapp listening on port 3001!'))\n```\n\n上面的过程中，已经能够成功将组件渲染到了页面上\n\n但是像一些事件处理的方法，是无法在服务端完成，因此需要将组件代码在浏览器中再执行一遍，这种服务器端和客户端共用一套代码的方式就称之为**同构**\n\n通俗讲，“同构”就是一套React代码在服务器上运行一遍，到达浏览器又运行一遍：\n\n- 服务端渲染完成页面结构\n- 浏览器端渲染完成事件绑定\n\n浏览器实现事件绑定的方式为让浏览器去拉取`JS`文件执行，让`JS`代码来控制，因此需要引入`script`标签\n\n通过`script`标签为页面引入客户端执行的`react`代码，并通过`express`的`static`中间件为`js`文件配置路由，修改如下：\n\n```js\nimport express from 'express'\nimport React from 'react'//引入React以支持JSX的语法\nimport { renderToString } from'react-dom/server'//引入renderToString方法\nimport Home from './src/containers/Home'\n \nconst app = express()\napp.use(express.static('public'));\n//使用express提供的static中间件,中间件会将所有静态文件的路由指向public文件夹\n const content = renderToString(<Home/>)\n \napp.get('/',(req,res)=>res.send(`\n<html>\n   <head>\n       <title>ssr demo</title>\n   </head>\n   <body>\n        ${content}\n   <script src=\"/index.js\"></script>\n   </body>\n</html>\n`))\n\n app.listen(3001, () =>console.log('Example app listening on port 3001!'))\n```\n\n然后再客户端执行以下`react`代码，新建`webpack.client.js`作为客户端React代码的`webpack`配置文件如下：\n\n```js\nconst path = require('path')                    //node的path模块\n\nmodule.exports = {\n    mode:'development',                         //开发模式\n    entry:'./src/client/index.js',              //入口\n    output: {                                   //打包出口\n        filename:'index.js',                    //打包后的文件名\n        path:path.resolve(__dirname,'public')   //存放到根目录的build文件夹\n    },\n    module: {\n        rules: [{                               //打包规则\n           test:   /\\.js?$/,                    //对所有js文件进行打包\n           loader:'babel-loader',               //使用babel-loader进行打包\n           exclude: /node_modules/,             //不打包node_modules中的js文件\n           options: {\n               presets: ['react','stage-0',['env', {     \n                    //loader时额外的打包规则,这里对react,JSX进行转换\n                    targets: {\n                        browsers: ['last 2versions']   //对主流浏览器最近两个版本进行兼容\n                    }\n               }]]\n           }\n       }]\n    }\n}\n```\n\n这种方法就能够简单实现首页的`react`服务端渲染，过程对应如下图：\n\n ![](https://static.ecool.fun//article/98837f11-c0c1-4ca8-9db9-4e742a146785.png)\n\n在做完初始渲染的时候，一个应用会存在路由的情况，配置信息如下：\n\n```js\nimport React from 'react'                   //引入React以支持JSX\nimport { Route } from 'react-router-dom'    //引入路由\nimport Home from './containers/Home'        //引入Home组件\n\nexport default (\n    <div>\n        <Route path=\"/\" exact component={Home}></Route>\n    </div>\n)\n```\n\n然后可以通过`index.js`引用路由信息，如下：\n\n```js\nimport React from 'react'\nimport ReactDom from 'react-dom'\nimport { BrowserRouter } from'react-router-dom'\nimport Router from'../Routers'\n\nconst App= () => {\n    return (\n        <BrowserRouter>\n           {Router}\n        </BrowserRouter>\n    )\n}\n\nReactDom.hydrate(<App/>, document.getElementById('root'))\n```\n\n这时候控制台会存在报错信息，原因在于每个`Route`组件外面包裹着一层`div`，但服务端返回的代码中并没有这个`div`\n\n解决方法只需要将路由信息在服务端执行一遍，使用使用`StaticRouter`来替代`BrowserRouter`，通过`context`进行参数传递\n\n```js\nimport express from 'express'\nimport React from 'react'//引入React以支持JSX的语法\nimport { renderToString } from 'react-dom/server'//引入renderToString方法\nimport { StaticRouter } from 'react-router-dom'\nimport Router from '../Routers'\n \nconst app = express()\napp.use(express.static('public'));\n//使用express提供的static中间件,中间件会将所有静态文件的路由指向public文件夹\n\napp.get('/',(req,res)=>{\n    const content  = renderToString((\n        //传入当前path\n        //context为必填参数,用于服务端渲染参数传递\n        <StaticRouter location={req.path} context={{}}>\n           {Router}\n        </StaticRouter>\n    ))\n    res.send(`\n   <html>\n       <head>\n           <title>ssr demo</title>\n       </head>\n       <body>\n       <div id=\"root\">${content}</div>\n       <script src=\"/index.js\"></script>\n       </body>\n   </html>\n    `)\n})\n\n\napp.listen(3001, () => console.log('Exampleapp listening on port 3001!'))\n```\n\n这样也就完成了路由的服务端渲染\n\n\n\n## 三、原理\n\n整体`react`服务端渲染原理并不复杂，具体如下：\n\n`node server` 接收客户端请求，得到当前的请求`url` 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 `props`、`context`或者`store` 形式传入组件\n\n然后基于 `react` 内置的服务端渲染方法 `renderToString()`把组件渲染为 `html`字符串在把最终的 `html `进行输出前需要将数据注入到浏览器端\n\n浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 `html` 节点，整个流程结束\n\n",
    "level": 2,
    "status": 2,
    "appId": 7,
    "createAt": "2021-10-24T04:17:51.000Z",
    "updateAt": "2024-01-25T19:25:20.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 65,
    "prev": "6515d22e-88eb-4a3f-9d02-2950cf35cb85",
    "next": "0b048b9b-0531-4a93-b6e7-b0254393abaa"
  },
  "post": {
    "exerciseKey": "190f1c7f-4fb5-4fb1-bb7c-f2cc977d50d8",
    "category": "QA",
    "title": "说说React服务端渲染怎么做？原理是什么？",
    "level": 2,
    "updateAt": "2024-01-25T19:25:20+00:00"
  },
  "tag": {
    "id": 13,
    "tagName": "React.js",
    "type": "1",
    "exerciseCount": 101
  }
}
