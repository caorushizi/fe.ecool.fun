{
  "data": {
    "id": 1807,
    "exerciseKey": "54891e04-5769-477b-8687-f55cf18feae2",
    "category": "QA",
    "renderType": "md",
    "title": "webpack loader 和 plugin 实现原理",
    "desc": null,
    "options": null,
    "explanation": "本文讨论的核心内容如下：\n\n1. `webpack`进行打包的基本原理\n2. 如何自己实现一个`loader`和`plugin`\n\n注： 本文使用的`webpack`版本是`v4.43.0`, `webpack-cli`版本是`v3.3.11`，`node`版本是`v12.14.1`，`npm`版本`v6.13.4`(如果你喜欢`yarn`也是可以的)，演示用的`chrome`浏览器版本`81.0.4044.129（正式版本） （64 位）`\n\n# 1\\. webpack打包基本原理\n\nwebpack的一个核心功能就是把我们写的模块化的代码，打包之后，生成可以在浏览器中运行的代码，我们这里也是从简单开始，一步步探索webpack的打包原理\n\n## 1.1 一个简单的需求\n\n我们首先建立一个空的项目，使用`npm init -y`快速初始化一个`package.json`，然后安装`webpack webpack-cli`\n\n接下来，在根目录下创建`src`目录，`src`目录下创建`index.js`，`add.js`，`minus.js`，根目录下创建`index.html`，其中`index.html`引入`index.js`，在`index.js`引入`add.js`，`minus.js`，\n\n目录结构如下：\n\n![](https://static.ecool.fun//article/aabca737-06a0-46fd-a28b-384c6a9a81ae.jpeg)\n\n文件内容如下：\n\n```\n// add.js\nexport default (a, b) => {\n    return a + b\n}\n// minus.js\nexport const minus = (a, b) => {\n    return a - b\n}\n// index.js\nimport add from './add.js'\nimport { minus } from './minus.js'\n\nconst sum = add(1, 2)\nconst division = minus(2, 1)\nconsole.log('sum>>>>>', sum)\nconsole.log('division>>>>>', division)\n\n```\n\n```\n<!--index.html-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>demo</title>\n</head>\n<body>\n    <script src=\"./src/index.js\"></script>\n</body>\n</html>\n\n```\n\n这样直接在`index.html`引入`index.js`的代码，在浏览器中显然是不能运行的，你会看到这样的错误\n\n```\nUncaught SyntaxError: Cannot use import statement outside a module\n\n```\n\n是的，我们不能在`script`引入的`js`文件里，使用`es6`模块化语法\n\n## 1.2 实现webpack打包核心功能\n\n我们首先在项目根目录下再建立一个bundle.js，这个文件用来对我们刚刚写的模块化`js`代码文件进行打包\n\n我们首先来看webpack官网对于其打包流程的描述：\n\n`it internally builds a dependency graph which maps every module your project needs and generates one or more bundles（webpack会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle）`\n\n在正式开始之前，结合上面`webpack`官网说明进行分析，明确我们进行打包工作的基本流程如下：\n\n1. 首先，我们需要读到入口文件里的内容（也就是index.js的内容）\n2. 其次，分析入口文件，递归的去读取模块所依赖的文件内容，生成依赖图\n3. 最后，根据依赖图，生成浏览器能够运行的最终代码\n\n### 1\\. 处理单个模块（以入口为例）\n\n#### 1.1 获取模块内容\n\n既然要读取文件内容，我们需要用到`node.js`的核心模块`fs`，我们首先来看读到的内容是什么：\n\n```\n// bundle.js\nconst fs = require('fs')\nconst getModuleInfo = file => {\n    const body = fs.readFileSync(file, 'utf-8')\n    console.log(body)\n}\ngetModuleInfo('./src/index.js')\n\n```\n\n我们定义了一个方法`getModuleInfo`，这个方法里我们读出文件内容，打印出来，输出的结果如下图：\n\n![](https://static.ecool.fun//article/7f31f863-538b-4b30-a018-e6a00113de58.jpeg)\n\n我们可以看到，入口文件`index.js`的所有内容都以字符串形式输出了，我们接下来可以用正则表达式或者其它一些方法，从中提取到`import`以及`export`的内容以及相应的路径文件名，来对入口文件内容进行分析，获取有用的信息。但是如果`import`和`export`的内容非常多，这会是一个很麻烦的过程，这里我们借助`babel`提供的功能，来完成入口文件的分析 \n\n#### 1.2 分析模块内容\n\n我们安装`@babel/parser`，演示时安装的版本号为`^7.9.6`\n\n这个babel模块的作用，就是把我们js文件的代码内容，转换成js对象的形式，这种形式的js对象，称做`抽象语法树(Abstract Syntax Tree, 以下简称AST)`\n\n```\n// bundle.js\nconst fs = require('fs')\nconst parser = require('@babel/parser')\nconst getModuleInfo = file => {\n    const body = fs.readFileSync(file, 'utf-8')\n    const ast = parser.parse(body, {\n        // 表示我们要解析的是es6模块\n       sourceType: 'module' \n    })\n    console.log(ast)\n    console.log(ast.program.body)\n}\ngetModuleInfo('./src/index.js')\n\n```\n\n使用`@babel/parser`的`parse`方法把入口文件转化称为了`AST`，我们打印出了`ast`，注意文件内容是在`ast.program.body`中，如下图所示：\n\n![](https://static.ecool.fun//article/252929a2-25c9-471a-81b8-aaf1e7348c81.jpeg)\n\n入口文件内容被放到一个数组中，总共有六个`Node`节点，我们可以看到，每个节点有一个`type`属性，其中前两个的`type`属性是`ImportDeclaration`，这对应了我们入口文件的两条`import`语句，并且，每一个`type`属性是`ImportDeclaration`的节点，其`source.value`属性是引入这个模块的相对路径，这样我们就得到了入口文件中对打包有用的重要信息了。 \n\n接下来要对得到的ast做处理，返回一份结构化的数据，方便后续使用。\n\n#### 1.3 对模块内容做处理\n\n对`ast.program.body`部分数据的获取和处理，本质上就是对这个数组的遍历，在循环中做数据处理，这里同样引入一个babel的模块`@babel/traverse`来完成这项工作。\n\n安装`@babel/traverse`，演示时安装的版本号为`^7.9.6`\n\n```\nconst fs = require('fs')\nconst path = require('path')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\n\nconst getModuleInfo = file => {\n    const body = fs.readFileSync(file, 'utf-8')\n    const ast = parser.parse(body, {\n       sourceType: 'module' \n    })\n    const deps = {}\n    traverse(ast, {\n        ImportDeclaration({ node }) {\n            const dirname = path.dirname(file);\n            const absPath = './' + path.join(dirname, node.source.value)\n            deps[node.source.value] = absPath\n        }\n    })\n    console.log(deps)\n}\ngetModuleInfo('./src/index.js')\n\n```\n\n创建一个对象`deps`，用来收集模块自身引入的依赖，使用`traverse`遍历`ast`，我们只需要对`ImportDeclaration`的节点做处理，注意我们做的处理实际上就是把相对路径转化为绝对路径，这里我使用的是`Mac`系统，如果是`windows`系统,注意斜杠的区别\n\n获取依赖之后，我们需要对`ast`做语法转换，把`es6`的语法转化为`es5`的语法，使用`babel`核心模块`@babel/core`以及`@babel/preset-env`完成\n\n安装`@babel/core @babel/preset-env`，演示时安装的版本号均为`^7.9.6`\n\n```\nconst fs = require('fs')\nconst path = require('path')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst babel = require('@babel/core')\n\nconst getModuleInfo = file => {\n    const body = fs.readFileSync(file, 'utf-8')\n    const ast = parser.parse(body, {\n       sourceType: 'module' \n    })\n    const deps = {}\n    traverse(ast, {\n        ImportDeclaration({ node }) {\n            const dirname = path.dirname(file);\n            const absPath = './' + path.join(dirname, node.source.value)\n            deps[node.source.value] = absPath\n        }\n    })\n    const { code } = babel.transformFromAst(ast, null, {\n        presets: [\"@babel/preset-env\"]\n    })\n    const moduleInfo = { file, deps, code }\n    console.log(moduleInfo)\n    return moduleInfo\n}\ngetModuleInfo('./src/index.js')\n\n```\n\n如下图所示，我们最终把一个模块的代码，转化为一个对象形式的信息，这个对象包含文件的绝对路径，文件所依赖模块的信息，以及模块内部经过`babel`转化后的代码\n\n![](https://static.ecool.fun//article/ce3989c8-c1ef-4510-b8ad-7c446fb0ffd8.jpeg)\n\n### 2\\. 递归的获取所有模块的信息\n\n这个过程，也就是获取`依赖图(dependency graph)`的过程，这个过程就是从入口模块开始，对每个模块以及模块的依赖模块都调用`getModuleInfo`方法就行分析，最终返回一个包含所有模块信息的对象\n\n```\nconst parseModules = file => {\n    // 定义依赖图\n    const depsGraph = {}\n    // 首先获取入口的信息\n    const entry = getModuleInfo(file)\n    const temp = [entry]\n    for (let i = 0; i < temp.length; i++) {\n        const item = temp[i]\n        const deps = item.deps\n        if (deps) {\n            // 遍历模块的依赖，递归获取模块信息\n            for (const key in deps) {\n                if (deps.hasOwnProperty(key)) {\n                    temp.push(getModuleInfo(deps[key]))\n                }\n            }\n        }\n    }\n    temp.forEach(moduleInfo => {\n        depsGraph[moduleInfo.file] = {\n            deps: moduleInfo.deps,\n            code: moduleInfo.code\n        }\n    })\n    console.log(depsGraph)\n    return depsGraph\n}\nparseModules('./src/index.js')\n\n```\n\n获得的depsGraph对象如下图：\n\n![](https://static.ecool.fun//article/51a19b0a-fe81-4b74-b17e-9b196c273804.jpeg)\n\n我们最终得到的模块分析数据如上图所示，接下来，我们就要根据这里获得的模块分析数据，来生产最终浏览器运行的代码。\n\n### 3\\. 生成最终代码\n\n在我们实现之前，观察上一节最终得到的依赖图，可以看到，最终的code里包含exports以及require这样的语法，所以，我们在生成最终代码时，要对exports和require做一定的实现和处理\n\n我们首先调用之前说的parseModules方法，获得整个应用的依赖图对象：\n\n```\nconst bundle = file => {\n    const depsGraph = JSON.stringify(parseModules(file))\n}\n\n```\n\n接下来我们应该把依赖图对象中的内容，转换成能够执行的代码，以字符串形式输出。 我们把整个代码放在自执行函数中，参数是依赖图对象\n\n```\nconst bundle = file => {\n    const depsGraph = JSON.stringify(parseModules(file))\n    return `(function(graph){\n        function require(file) {\n            var exports = {};\n            return exports\n        }\n        require('${file}')\n    })(${depsGraph})`\n}\n\n```\n\n接下来内容其实很简单，就是我们取得入口文件的code信息，去执行它就好了，使用eval函数执行，初步写出代码如下：\n\n```\nconst bundle = file => {\n    const depsGraph = JSON.stringify(parseModules(file))\n    return `(function(graph){\n        function require(file) {\n            var exports = {};\n            (function(code){\n                eval(code)\n            })(graph[file].code)\n            return exports\n        }\n        require('${file}')\n    })(${depsGraph})`\n}\n\n```\n\n上面的写法是有问题的，我们需要对file做绝对路径转化，否则`graph[file].code`是获取不到的，定义adsRequire方法做相对路径转化为绝对路径\n\n```\nconst bundle = file => {\n    const depsGraph = JSON.stringify(parseModules(file))\n    return `(function(graph){\n        function require(file) {\n            var exports = {};\n            function absRequire(relPath){\n                return require(graph[file].deps[relPath])\n            }\n            (function(require, exports, code){\n                eval(code)\n            })(absRequire, exports, graph[file].code)\n            return exports\n        }\n        require('${file}')\n    })(${depsGraph})`\n}\n\n```\n\n接下来，我们只需要执行bundle方法，然后把生成的内容写入一个JavaScript文件即可\n\n```\nconst content = bundle('./src/index.js')\n// 写入到dist/bundle.js\nfs.mkdirSync('./dist')\nfs.writeFileSync('./dist/bundle.js', content)\n\n```\n\n最后，我们在index.html引入这个`./dist/bundle.js`文件，我们可以看到控制台正确输出了我们想要的结果\n\n![](https://static.ecool.fun//article/5fde42e6-235c-42b0-9909-0c1849415833.jpeg)\n\n### 4\\. bundle.js的完整代码\n\n```\nconst fs = require('fs')\nconst path = require('path')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst babel = require('@babel/core')\n\nconst getModuleInfo = file => {\n    const body = fs.readFileSync(file, 'utf-8')\n    console.log(body)\n    const ast = parser.parse(body, {\n       sourceType: 'module' \n    })\n    // console.log(ast.program.body)\n    const deps = {}\n    traverse(ast, {\n        ImportDeclaration({ node }) {\n            const dirname = path.dirname(file);\n            const absPath = './' + path.join(dirname, node.source.value)\n            deps[node.source.value] = absPath\n        }\n    })\n    const { code } = babel.transformFromAst(ast, null, {\n        presets: [\"@babel/preset-env\"]\n    })\n    const moduleInfo = { file, deps, code }\n    return moduleInfo\n}\n\nconst parseModules = file => {\n    // 定义依赖图\n    const depsGraph = {}\n    // 首先获取入口的信息\n    const entry = getModuleInfo(file)\n    const temp = [entry]\n    for (let i = 0; i < temp.length; i++) {\n        const item = temp[i]\n        const deps = item.deps\n        if (deps) {\n            // 遍历模块的依赖，递归获取模块信息\n            for (const key in deps) {\n                if (deps.hasOwnProperty(key)) {\n                    temp.push(getModuleInfo(deps[key]))\n                }\n            }\n        }\n    }\n    temp.forEach(moduleInfo => {\n        depsGraph[moduleInfo.file] = {\n            deps: moduleInfo.deps,\n            code: moduleInfo.code\n        }\n    })\n    // console.log(depsGraph)\n    return depsGraph\n}\n\n\n// 生成最终可以在浏览器运行的代码\nconst bundle = file => {\n    const depsGraph = JSON.stringify(parseModules(file))\n    return `(function(graph){\n        function require(file) {\n            var exports = {};\n            function absRequire(relPath){\n                return require(graph[file].deps[relPath])\n            }\n            (function(require, exports, code){\n                eval(code)\n            })(absRequire, exports, graph[file].code)\n            return exports\n        }\n        require('${file}')\n    })(${depsGraph})`\n}\n\n\nconst build = file => {\n    const content = bundle(file)\n    // 写入到dist/bundle.js\n    fs.mkdirSync('./dist')\n    fs.writeFileSync('./dist/bundle.js', content)\n}\n\nbuild('./src/index.js')\n\n```\n\n# 2\\. 手写`loader`和`plugin`\n\n## 2.1 如何自己实现一个`loader`\n\nloader本质上就是一个函数，这个函数会在我们在我们加载一些文件时执行\n\n### 2.1.1 如何实现一个同步`loader`\n\n首先我们初始化一个项目，项目结构如图所示：\n\n![](https://static.ecool.fun//article/18c26a1f-df42-4f60-a571-94716c74dd8c.jpeg)\n\n其中index.js和webpack.config.js的文件内容如下： \n\n```\n// index.js\nconsole.log('我要学好前端，因为学好前端可以： ')\n\n// webpack.config.js\nconst path = require('path')\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    }\n}\n\n```\n\n我们在根目录下创建`syncLoader.js`，用来实现一个同步的loader，注意这个函数必须返回一个`buffer`或者`string`\n\n```\n// syncloader.ja\nmodule.exports = function (source) {\n    console.log('source>>>>', source)\n    return source\n}\n\n```\n\n同时，我们在`webpack.config.js`中使用这个`loader`，我们这里使用`resolveLoader`配置项，指定`loader`查找文件路径，这样我们使用`loader`时候可以直接指定`loader`的名字\n\n```\nconst path = require('path')\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    resolveLoader: {\n        // loader路径查找顺序从左往右\n        modules: ['node_modules', './']\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: 'syncLoader'\n            }\n        ]\n    }\n}\n\n```\n\n接下来我们运行打包命令，可以看到命令行输出了source内容，也就是loader作用文件的内容。\n\n![](https://static.ecool.fun//article/6ca1a81f-8045-45ce-997c-8122389a5de6.jpeg)\n\n接着我们改造我们的loader: \n\n```\nmodule.exports = function (source) {\n    source += '升值加薪'\n    return source\n}\n\n```\n\n我们再次运行打包命令，去观察打包后的代码：\n\n![](https://static.ecool.fun//article/f1f07c5f-6a88-4628-9ab3-fdea84fe4535.jpeg)\n\n这样，我们就实现了一个简单的loader，为我们的文件增加一条信息。 我们可以尝试在`loader`的函数里打印`this`，发现输出结果是非常长的一串内容，`this`上有很多我们可以在`loader`中使用的有用信息，所以，对于`loader`的编写，一定不要使用箭头函数，那样会改变`this`的指向。 \n\n一般来说，我们会去使用官方推荐的`loader-utils`包去完成更加复杂的`loader`的编写\n\n我们继续安装`loader-utils`，版本是`^2.0.0`\n\n我们首先改造`webpack.config.js`：\n\n```\nconst path = require('path')\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    resolveLoader: {\n        // loader路径查找顺序从左往右\n        modules: ['node_modules', './']\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: {\n                    loader: 'syncLoader',\n                    options: {\n                        message: '升值加薪'\n                    }\n                }\n            }\n        ]\n    }\n}\n\n```\n\n注意到，我们为我们的`loader`增加了`options`配置项，接下来在loader函数里使用loader-utils获取配置项内容，拼接内容，我们依然可以得到与之前一样的打包结果\n\n```\n// syncLoader.js\nconst loaderUtils = require('loader-utils')\nmodule.exports = function (source) {\n    const options = loaderUtils.getOptions(this)\n    console.log(options)\n    source += options.message\n    // 可以传递更详细的信息\n    this.callback(null, source)\n}\n\n```\n\n![](https://static.ecool.fun//article/14123f33-ca14-4696-ac68-743355da36ce.jpeg)\n\n![](https://static.ecool.fun//article/7425047a-ab6c-46e1-999b-43fbffc05b32.jpeg)\n\n这样，我们就完成了一个简单的同步`loader`的编写\n\n### 2.1.2 如何实现一个异步`loader`\n\n和同步loader的编写方式非常相似，我们在根目录下建立一个asyncLoader.js的文件，内容如下：\n\n```\nconst loaderUtils = require('loader-utils')\nmodule.exports = function (source) {\n    const options = loaderUtils.getOptions(this)\n    const asyncfunc = this.async()\n    setTimeout(() => {\n        source += '走上人生颠覆'\n        asyncfunc(null, res)\n    }, 200)\n}\n\n```\n\n注意这里的`this.async()`，用官方的话来说就是`Tells the loader-runner that the loader intends to call back asynchronously. Returns this.callback.`也就是让webpack知道这个loader是异步运行，返回的是和同步使用时一致的`this.callback`\n\n接下来我们修改webpack.config.js\n\n```\nconst path = require('path')\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    resolveLoader: {\n        // loader路径查找顺序从左往右\n        modules: ['node_modules', './']\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: [\n                    {\n                        loader: 'syncLoader',\n                        options: {\n                            message: '走上人生巅峰'\n                        }\n                    },\n                    {\n                        loader: 'asyncLoader'\n                    }\n                ]\n            }\n        ]\n    }\n}\n\n```\n\n注意loader执行顺序是从下网上的，所以首先为文本写入‘升值加薪’，然后写入‘走上人生巅峰’\n\n![](https://static.ecool.fun//article/031be6f9-79d8-44c2-8bf8-fb6b23272991.jpeg)\n\n到此，我们简单介绍了如何手写一个`loader`，在实际项目中，可以考虑一部分公共的简单逻辑，可以通过编写一个`loader`来完成(比如国际化文本替换)\n\n## 2.2 如何自己实现一个`plugin`\n\n`plugin`通常是在`webpack`在打包的某个时间节点做一些操作，我们使用`plugin`的时候，一般都是`new Plugin()`这种形式使用，所以，首先应该明确的是，`plugin`应该是一个类。\n\n我们初始化一个与上一接实现loader时候一样的项目，根目录下创建一个`demo-webpack-plugin.js`的文件，我们首先在`webpack.config.js`中使用它\n\n```\nconst path = require('path')\nconst DemoWebpackPlugin = require('./demo-webpack-plugin')\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    plugins: [\n        new DemoWebpackPlugin()\n    ]\n}\n\n```\n\n再来看`demo-webpack-plugin.js`的实现\n\n```\nclass DemoWebpackPlugin {\n    constructor () {\n        console.log('plugin init')\n    }\n    apply (compiler) {\n\n    }\n}\n\nmodule.exports = DemoWebpackPlugin\n\n```\n\n我们在`DemoWebpackPlugin`的构造函数打印一条信息，当我们执行打包命令时，这条信息就会输出，`plugin`类里面需要实现一个`apply`方法，`webpack`打包时候，会调用`plugin`的`aplly`方法来执行`plugin`的逻辑，这个方法接受一个`compiler`作为参数，这个`compiler`是`webpack`实例\n\nplugin的核心在于，apply方法执行时，可以操作webpack本次打包的各个时间节点（hooks，也就是生命周期勾子），在不同的时间节点做一些操作\n\n关于webpack编译过程的各个生命周期勾子，可以参考[Compiler Hooks](https://v4.webpack.js.org/api/compiler-hooks/)\n\n同样，这些hooks也有同步和异步之分，下面演示`compiler hooks`的写法，一些重点内容可以参考注释：\n\n```\nclass DemoWebpackPlugin {\n    constructor () {\n        console.log('plugin init')\n    }\n    // compiler是webpack实例\n    apply (compiler) {\n        // 一个新的编译(compilation)创建之后（同步）\n        // compilation代表每一次执行打包，独立的编译\n        compiler.hooks.compile.tap('DemoWebpackPlugin', compilation => {\n            console.log(compilation)\n        })\n        // 生成资源到 output 目录之前（异步）\n        compiler.hooks.emit.tapAsync('DemoWebpackPlugin', (compilation, fn) => {\n            console.log(compilation)\n            compilation.assets['index.md'] = {\n                // 文件内容\n                source: function () {\n                    return 'this is a demo for plugin'\n                },\n                // 文件尺寸\n                size: function () {\n                    return 25\n                }\n            }\n            fn()\n        })\n    }\n}\n\nmodule.exports = DemoWebpackPlugin\n\n```\n\n我们的这个`plugin`的作用就是，打包时候自动生成一个`md`文档，文档内容是很简单的一句话\n\n上述异步hooks的写法也可以是以下两种：\n\n```\n// 第二种写法(promise)\ncompiler.hooks.emit.tapPromise('DemoWebpackPlugin', (compilation) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve()\n        }, 1000)\n    }).then(() => {\n        console.log(compilation.assets)\n        compilation.assets['index.md'] = {\n            // 文件内容\n            source: function () {\n                return 'this is a demo for plugin'\n            },\n            // 文件尺寸\n            size: function () {\n                return 25\n            }\n        }\n    })\n})\n// 第三种写法(async await)\ncompiler.hooks.emit.tapPromise('DemoWebpackPlugin', async (compilation) => {\n    await new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve()\n        }, 1000)\n    })\n    console.log(compilation.assets)\n    compilation.assets['index.md'] = {\n        // 文件内容\n        source: function () {\n            return 'this is a demo for plugin'\n        },\n        // 文件尺寸\n        size: function () {\n            return 25\n        }\n    }\n})\n\n```\n\n最终的输出结果都是一样的，在每次打包时候生成一个md文档\n\n![](https://static.ecool.fun//article/d06f45f0-0878-4121-a97b-1e89fda7ee70.jpeg)\n",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2022-05-16T04:56:31.000Z",
    "updateAt": "2024-01-24T17:23:54.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 191,
    "prev": "3e12b5bf-53ed-4b71-a199-49d7935f87b4",
    "next": "9eebcbe5-2c34-482e-9198-36f750aa3555"
  },
  "post": {
    "exerciseKey": "54891e04-5769-477b-8687-f55cf18feae2",
    "category": "QA",
    "title": "webpack loader 和 plugin 实现原理",
    "level": 3.5,
    "updateAt": "2024-01-24T17:23:54+00:00"
  },
  "tag": {
    "id": 28,
    "tagName": "工程化",
    "type": "1",
    "exerciseCount": 33
  }
}
