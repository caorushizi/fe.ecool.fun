{
  "data": {
    "id": 1755,
    "exerciseKey": "ea676360-c8f5-4ce4-bc66-5c3e4f7eddb6",
    "category": "QA",
    "renderType": "md",
    "title": "说说 vue3 中的响应式设计原理",
    "desc": null,
    "options": null,
    "explanation": "Vue 3 中的响应式原理可谓是非常之重要，通过学习 Vue3 的响应式原理，不仅能让我们学习到 Vue.js 的一些设计模式和思想，还能**帮助我们提高项目开发效率和代码调试能力**。  \n\n## 一、Vue 3 响应式使用\n\n### 1. Vue 3 中的使用\n\n当我们在学习 Vue 3 的时候，可以通过一个简单示例，看看什么是 Vue 3 中的响应式：\n\n```html\n<!-- HTML 内容 -->\n<div id=\"app\">\n    <div>Price: {{price}}</div>\n    <div>Total: {{price * quantity}}</div>\n    <div>getTotal: {{getTotal}}</div>\n</div>\n```\n\n```javascript\nconst app = Vue.createApp({ // ① 创建 APP 实例\n    data() {\n        return {\n            price: 10,\n            quantity: 2\n        }\n    },\n    computed: {\n        getTotal() {\n            return this.price * this.quantity * 1.1\n        }\n    }\n})\napp.mount('#app')  // ② 挂载 APP 实例\n```\n\n通过创建 APP 实例和挂载 APP 实例即可，这时可以看到页面中分别显示对应数值：\n![image.png](https://static.ecool.fun//article/614ad328-3096-4f32-bbb7-8373f950ed1d.jpeg)\n\n当我们修改 `price` 或 `quantity` 值的时候，页面上引用它们的地方，内容也能正常展示变化后的结果。这时，我们会好奇为何数据发生变化后，相关的数据也会跟着变化，那么我们接着往下看。\n\n### 2. 实现单个值的响应式\n\n在普通 JS 代码执行中，并不会有响应式变化，比如在控制台执行下面代码：\n\n```javascript\nlet price = 10, quantity = 2;\nconst total = price * quantity;\nconsole.log(`total: ${total}`); // total: 20\nprice = 20;\nconsole.log(`total: ${total}`); // total: 20\n```\n\n从这可以看出，在修改 `price` 变量的值后， `total` 的值并没有发生改变。\n\n那么如何修改上面代码，让 `total` 能够自动更新呢？我们其实可以将修改 `total` 值的方法保存起来，等到与 `total` 值相关的变量（如 `price` 或 `quantity` 变量的值）发生变化时，触发该方法，更新 `total` 即可。我们可以这么实现：\n\n```javascript\nlet price = 10, quantity = 2, total = 0;\nconst dep = new Set(); // ① \nconst effect = () => { total = price * quantity };\nconst track = () => { dep.add(effect) };  // ②\nconst trigger = () => { dep.forEach( effect => effect() )};  // ③\n\ntrack();\nconsole.log(`total: ${total}`); // total: 0\ntrigger();\nconsole.log(`total: ${total}`); // total: 20\nprice = 20;\ntrigger();\nconsole.log(`total: ${total}`); // total: 40\n```\n\n上面代码通过 3 个步骤，实现对 `total` 数据进行响应式变化：\n\n① 初始化一个 `Set` 类型的 `dep` 变量，用来存放需要执行的副作用（ `effect` 函数），这边是修改 `total` 值的方法；\n\n② 创建 `track()` 函数，用来将需要执行的副作用保存到 `dep` 变量中（也称收集副作用）；\n\n③ 创建 `trigger()` 函数，用来执行 `dep` 变量中的所有副作用；\n\n在每次修改 `price` 或 `quantity` 后，调用 `trigger()` 函数执行所有副作用后， `total` 值将自动更新为最新值。\n![image.png](https://static.ecool.fun//article/098e3ad6-2db4-440a-b0a6-7e20c36479c1.jpeg)\n\n（图片来源：Vue Mastery）\n\n### 3. 实现单个对象的响应式\n\n通常，**我们的对象具有多个属性，并且每个属性都需要自己的 `dep`。我们如何存储这些？比如：**\n\n```javascript\nlet product = { price: 10, quantity: 2 };\n```\n\n从前面介绍我们知道，我们将所有副作用保存在一个 `Set` 集合中，而该集合不会有重复项，这里我们引入一个 `Map` 类型集合（即 `depsMap` ），其 `key` 为对象的属性（如： `price` 属性）， `value` 为前面保存副作用的 `Set` 集合（如： `dep` 对象），大致结构如下图：\n\n![image.png](https://static.ecool.fun//article/a658efdb-5daa-45ef-bcce-6647bc29021e.jpeg)\n（图片来源：Vue Mastery）\n\n实现代码：\n\n```javascript\nlet product = { price: 10, quantity: 2 }, total = 0;\nconst depsMap = new Map(); // ① \nconst effect = () => { total = product.price * product.quantity };\nconst track = key => {     // ②\n  let dep = depsMap.get(key);\n  if(!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  dep.add(effect);\n}\n\nconst trigger = key => {  // ③\n  let dep = depsMap.get(key);\n  if(dep) {\n    dep.forEach( effect => effect() );\n  }\n};\n\ntrack('price');\nconsole.log(`total: ${total}`); // total: 0\neffect();\nconsole.log(`total: ${total}`); // total: 20\nproduct.price = 20;\ntrigger('price');\nconsole.log(`total: ${total}`); // total: 40\n```\n\n上面代码通过 3 个步骤，实现对 `total` 数据进行响应式变化：\n\n① 初始化一个 `Map` 类型的 `depsMap` 变量，用来保存每个需要响应式变化的对象属性（`key` 为对象的属性， `value` 为前面 `Set` 集合）；\n\n② 创建 `track()` 函数，用来将需要执行的副作用保存到 `depsMap` 变量中对应的对象属性下（也称收集副作用）；\n\n③ 创建 `trigger()` 函数，用来执行 `dep` 变量中指定对象属性的所有副作用；\n\n这样就实现监听对象的响应式变化，在 `product` 对象中的属性值发生变化， `total` 值也会跟着更新。\n\n### 4. 实现多个对象的响应式\n\n如果我们有多个响应式数据，比如同时需要观察对象 `a` 和对象 `b`  的数据，那么又要如何跟踪每个响应变化的对象？\n\n这里我们引入一个 [WeakMap 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)的对象，将需要观察的对象作为 `key` ，值为前面用来保存对象属性的 Map 变量。代码如下：\n\n```javascript\nlet product = { price: 10, quantity: 2 }, total = 0;\nconst targetMap = new WeakMap();     // ① 初始化 targetMap，保存观察对象\nconst effect = () => { total = product.price * product.quantity };\nconst track = (target, key) => {     // ② 收集依赖\n  let depsMap = targetMap.get(target);\n  if(!depsMap){\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if(!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  dep.add(effect);\n}\n\nconst trigger = (target, key) => {  // ③ 执行指定对象的指定属性的所有副作用\n  const depsMap = targetMap.get(target);\n  if(!depsMap) return;\n    let dep = depsMap.get(key);\n  if(dep) {\n    dep.forEach( effect => effect() );\n  }\n};\n\ntrack(product, 'price');\nconsole.log(`total: ${total}`); // total: 0\neffect();\nconsole.log(`total: ${total}`); // total: 20\nproduct.price = 20;\ntrigger(product, 'price');\nconsole.log(`total: ${total}`); // total: 40\n```\n\n上面代码通过 3 个步骤，实现对 `total` 数据进行响应式变化：\n\n① 初始化一个 `WeakMap` 类型的 `targetMap` 变量，用来要观察每个响应式对象；\n\n② 创建 `track()` 函数，用来将需要执行的副作用保存到指定对象（ `target` ）的依赖中（也称收集副作用）；\n\n③ 创建 `trigger()` 函数，用来执行指定对象（ `target` ）中指定属性（ `key` ）的所有副作用；\n\n这样就实现监听对象的响应式变化，在 `product` 对象中的属性值发生变化， `total` 值也会跟着更新。\n\n大致流程如下图：\n\n![image.png](https://static.ecool.fun//article/4ca05d1f-3d74-4d3a-a716-1a54bc6c7ac4.jpeg)\n（图片来源：Vue Mastery）\n\n## 二、Proxy 和 Reflect\n\n在上一节内容中，介绍了如何在数据发生变化后，自动更新数据，但存在的问题是，每次需要手动通过触发 `track()` 函数搜集依赖，通过 `trigger()` 函数执行所有副作用，达到数据更新目的。\n\n这一节将来解决这个问题，实现这两个函数自动调用。\n\n### 1. 如何实现自动操作\n\n这里我们引入 JS 对象访问器的概念，解决办法如下：\n\n- 在读取（GET 操作）数据时，自动执行 `track()` 函数自动收集依赖；\n- 在修改（SET 操作）数据时，自动执行 `trigger()` 函数执行所有副作用；\n\n那么如何拦截 GET 和 SET 操作？接下来看看 Vue2 和 Vue3 是如何实现的：\n\n- 在 Vue2 中，使用 ES5 的 [`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 函数实现；\n- 在 Vue3 中，使用 ES6 的 [`Proxy`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [`Reflect`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API 实现；\n\n需要注意的是：Vue3 使用的 `Proxy` 和 `Reflect` API 并不支持 IE。\n\n[`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 函数这边就不多做介绍，可以阅读文档，下文将主要介绍 [`Proxy`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [`Reflect`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API。\n\n### 2. 如何使用 Reflect\n\n通常我们有三种方法读取一个对象的属性：\n\n1. 使用 `.` 操作符：`leo.name` ；\n2. 使用 `[]` ： `leo['name']` ；\n3. 使用 `Reflect` API： `Reflect.get(leo, 'name')` 。\n\n这三种方式输出结果相同。\n\n### 3. 如何使用 Proxy\n\nProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。语法如下：\n\n```javascript\nconst p = new Proxy(target, handler)\n```\n\n参数如下：\n\n- target : 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n- handler : 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为。\n\n我们通过官方文档，体验一下 [Proxy API](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)：\n\n```javascript\nlet product = { price: 10, quantity: 2 };\nlet proxiedProduct = new Proxy(product, {\n    get(target, key){\n      console.log('正在读取的数据：',key);\n    return target[key];\n  }\n})\nconsole.log(proxiedProduct.price); \n// 正在读取的数据： price\n// 10\n```\n\n这样就保证我们每次在读取 `proxiedProduct.price` 都会执行到其中代理的 get 处理函数。其过程如下：\n\n![image.png](https://static.ecool.fun//article/c65b6a63-6e61-44e0-a56f-04c4eb63bf3e.jpeg)\n（图片来源：Vue Mastery）\n\n然后结合 Reflect 使用，只需修改 get 函数：\n\n```javascript\n    get(target, key, receiver){\n      console.log('正在读取的数据：',key);\n    return Reflect.get(target, key, receiver);\n  }\n```\n\n输出结果还是一样。\n\n接下来增加 set 函数，来拦截对象的修改操作：\n\n```javascript\nlet product = { price: 10, quantity: 2 };\nlet proxiedProduct = new Proxy(product, {\n  get(target, key, receiver){\n    console.log('正在读取的数据：',key);\n    return Reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver){\n    console.log('正在修改的数据：', key, ',值为：', value);\n    return Reflect.set(target, key, value, receiver);\n  }\n})\nproxiedProduct.price = 20;\nconsole.log(proxiedProduct.price); \n// 正在修改的数据： price ,值为： 20\n// 正在读取的数据： price\n// 20\n```\n\n这样便完成 get 和 set 函数来拦截对象的读取和修改的操作。为了方便对比 Vue 3 源码，我们将上面代码抽象一层，使它看起来更像 Vue3 源码：\n\n```javascript\nfunction reactive(target){\n  const handler = {  // ① 封装统一处理函数对象\n    get(target, key, receiver){\n      console.log('正在读取的数据：',key);\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, value, receiver){\n      console.log('正在修改的数据：', key, ',值为：', value);\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n  \n  return new Proxy(target, handler); // ② 统一调用 Proxy API\n}\n\nlet product = reactive({price: 10, quantity: 2}); // ③ 将对象转换为响应式对象\nproduct.price = 20;\nconsole.log(product.price); \n// 正在修改的数据： price ,值为： 20\n// 正在读取的数据： price\n// 20\n```\n\n这样输出结果仍然不变。\n\n### 4. 修改 track 和 trigger 函数\n\n通过上面代码，我们已经实现一个简单 `reactive()` 函数，用来**将普通对象转换为响应式对象**。但是还缺少自动执行 `track()` 函数和 `trigger()` 函数，接下来修改上面代码：\n\n```javascript\nconst targetMap = new WeakMap();\nlet total = 0;\nconst effect = () => { total = product.price * product.quantity };\nconst track = (target, key) => { \n  let depsMap = targetMap.get(target);\n  if(!depsMap){\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if(!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  dep.add(effect);\n}\n\nconst trigger = (target, key) => {\n  const depsMap = targetMap.get(target);\n  if(!depsMap) return;\n    let dep = depsMap.get(key);\n  if(dep) {\n    dep.forEach( effect => effect() );\n  }\n};\n\nconst reactive = (target) => {\n  const handler = {\n    get(target, key, receiver){\n      console.log('正在读取的数据：',key);\n      const result = Reflect.get(target, key, receiver);\n      track(target, key);  // 自动调用 track 方法收集依赖\n      return result;\n    },\n    set(target, key, value, receiver){\n      console.log('正在修改的数据：', key, ',值为：', value);\n      const oldValue = target[key];\n      const result = Reflect.set(target, key, value, receiver);\n      if(oldValue != result){\n         trigger(target, key);  // 自动调用 trigger 方法执行依赖\n      }\n      return result;\n    }\n  }\n  \n  return new Proxy(target, handler);\n}\n\nlet product = reactive({price: 10, quantity: 2}); \neffect();\nconsole.log(total); \nproduct.price = 20;\nconsole.log(total); \n// 正在读取的数据： price\n// 正在读取的数据： quantity\n// 20\n// 正在修改的数据： price ,值为： 20\n// 正在读取的数据： price\n// 正在读取的数据： quantity\n// 40\n```\n\n![image.png](https://static.ecool.fun//article/2a941233-fd37-4967-8ce3-3c14746580e2.jpeg)\n（图片来源：Vue Mastery）\n\n## 三、activeEffect 和 ref\n\n在上一节代码中，还存在一个问题： `track` 函数中的依赖（ `effect` 函数）是外部定义的，当依赖发生变化， `track` 函数收集依赖时都要手动修改其依赖的方法名。\n\n比如现在的依赖为 `foo` 函数，就要修改 `track` 函数的逻辑，可能是这样：\n\n```javascript\nconst foo = () => { /**/ };\nconst track = (target, key) => {     // ②\n  // ...\n  dep.add(foo);\n}\n```\n\n那么如何解决这个问题呢？\n\n### 1. 引入 activeEffect 变量\n\n接下来引入 `activeEffect` 变量，来保存当前运行的 effect 函数。\n\n```javascript\nlet activeEffect = null;\nconst effect = eff => {\n  activeEffect = eff; // 1. 将 eff 函数赋值给 activeEffect\n  activeEffect();     // 2. 执行 activeEffect\n  activeEffect = null;// 3. 重置 activeEffect\n}\n```\n\n然后在 `track` 函数中将 `activeEffect` 变量作为依赖：\n\n```javascript\nconst track = (target, key) => {\n    if (activeEffect) {  // 1. 判断当前是否有 activeEffect\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = new Set()));\n        }\n        dep.add(activeEffect);  // 2. 添加 activeEffect 依赖\n    }\n}\n```\n\n使用方式修改为：\n\n```javascript\neffect(() => {\n    total = product.price * product.quantity\n});\n```\n\n这样就可以解决手动修改依赖的问题，这也是 Vue3 解决该问题的方法。完善一下测试代码后，如下：\n\n```javascript\nconst targetMap = new WeakMap();\nlet activeEffect = null; // 引入 activeEffect 变量\n\nconst effect = eff => {\n  activeEffect = eff; // 1. 将副作用赋值给 activeEffect\n  activeEffect();     // 2. 执行 activeEffect\n  activeEffect = null;// 3. 重置 activeEffect\n}\n\nconst track = (target, key) => {\n    if (activeEffect) {  // 1. 判断当前是否有 activeEffect\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = new Set()));\n        }\n        dep.add(activeEffect);  // 2. 添加 activeEffect 依赖\n    }\n}\n\nconst trigger = (target, key) => {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) return;\n    let dep = depsMap.get(key);\n    if (dep) {\n        dep.forEach(effect => effect());\n    }\n};\n\nconst reactive = (target) => {\n    const handler = {\n        get(target, key, receiver) {\n            const result = Reflect.get(target, key, receiver);\n            track(target, key);\n            return result;\n        },\n        set(target, key, value, receiver) {\n            const oldValue = target[key];\n            const result = Reflect.set(target, key, value, receiver);\n            if (oldValue != result) {\n                trigger(target, key);\n            }\n            return result;\n        }\n    }\n\n    return new Proxy(target, handler);\n}\n\nlet product = reactive({ price: 10, quantity: 2 });\nlet total = 0, salePrice = 0;\n// 修改 effect 使用方式，将副作用作为参数传给 effect 方法\neffect(() => {\n    total = product.price * product.quantity\n});\neffect(() => {\n    salePrice = product.price * 0.9\n});\nconsole.log(total, salePrice);  // 20 9\nproduct.quantity = 5;\nconsole.log(total, salePrice);  // 50 9\nproduct.price = 20;\nconsole.log(total, salePrice);  // 100 18\n```\n\n思考一下，如果把第一个 `effect` 函数中 `product.price` 换成 `salePrice` 会如何：\n\n```javascript\neffect(() => {\n    total = salePrice * product.quantity\n});\neffect(() => {\n    salePrice = product.price * 0.9\n});\nconsole.log(total, salePrice);  // 0 9\nproduct.quantity = 5;\nconsole.log(total, salePrice);  // 45 9\nproduct.price = 20;\nconsole.log(total, salePrice);  // 45 18\n```\n\n得到的结果完全不同，因为 `salePrice` 并不是响应式变化，而是需要调用第二个 `effect` 函数才会变化，也就是 `product.price` 变量值发生变化。\n\n> 代码地址：\n> [https://github.com/Code-Pop/vue-3-reactivity/blob/master/05-activeEffect.js](https://github.com/Code-Pop/vue-3-reactivity/blob/master/05-activeEffect.js)\n\n### 2. 引入 ref 方法\n\n熟悉  Vue3 Composition API 的朋友可能会想到 Ref，它接收一个值，并返回一个响应式可变的[ Ref 对象](https://v3.cn.vuejs.org/api/refs-api.html)，其值可以通过 `value` 属性获取。\n\n> ref：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。\n\n官网的使用示例如下：\n\n```javascript\nconst count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n我们有 2 种方法实现 ref 函数：\n\n1. **使用 `reactive` 函数**\n\n```javascript\nconst ref = intialValue => reactive({value: intialValue});\n```\n\n这样是可以的，虽然 Vue3 不是这么实现。\n\n2. **使用对象的属性访问器（计算属性）**\n\n属性方式包括：[getter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get) 和 [setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set)。\n\n```javascript\nconst ref = raw => {\n  const r = {\n    get value(){\n      track(r, 'value');\n      return raw;\n    },\n    \n    set value(newVal){\n    \traw = newVal;\n      trigger(r, 'value');\n    }\n  }\n  return r;\n}\n```\n\n使用方式如下：\n\n```javascript\nlet product = reactive({ price: 10, quantity: 2 });\nlet total = 0, salePrice = ref(0);\neffect(() => {\n    salePrice.value = product.price * 0.9\n});\neffect(() => {\n    total = salePrice.value * product.quantity\n});\nconsole.log(total, salePrice.value); // 18 9\nproduct.quantity = 5;\nconsole.log(total, salePrice.value); // 45 9\nproduct.price = 20;\nconsole.log(total, salePrice.value); // 90 18\n```\n\n在 Vue3 中 ref 实现的核心也是如此。\n\n> 代码地址：\n> [https://github.com/Code-Pop/vue-3-reactivity/blob/master/06-ref.js](https://github.com/Code-Pop/vue-3-reactivity/blob/master/06-ref.js)\n\n## 四、实现简易 Computed 方法\n\n用过 Vue 的同学可能会好奇，上面的 `salePrice` 和 `total` 变量为什么不使用 `computed` 方法呢？\n\n没错，这个可以的，接下来一起实现个简单的 `computed` 方法。\n\n```javascript\nconst computed = getter => {\n    let result = ref();\n    effect(() => result.value = getter());\n    return result;\n}\n\nlet product = reactive({ price: 10, quantity: 2 });\nlet salePrice = computed(() => {\n    return product.price * 0.9;\n})\nlet total = computed(() => {\n    return salePrice.value * product.quantity;\n})\n\nconsole.log(total.value, salePrice.value);\nproduct.quantity = 5;\nconsole.log(total.value, salePrice.value);\nproduct.price = 20;\nconsole.log(total.value, salePrice.value);\n```\n\n这里我们将一个函数作为参数传入 `computed` 方法，`computed` 方法内通过 `ref` 方法构建一个 ref 对象，然后通过 `effct` 方法，将 `getter` 方法返回值作为 `computed` 方法的返回值。\n\n这样我们实现了个简单的 `computed` 方法，执行效果和前面一样。\n\n## 五、源码学习建议\n\n### 1. 构建 reactivity.cjs.js\n\n这一节介绍如何去从[ Vue 3 仓库](https://github.com/vuejs/vue-next)打包一个 Reactivity 包来学习和使用。\n\n准备流程如下：\n\n1. 从[ Vue 3 仓库](https://github.com/vuejs/vue-next)下载最新 Vue3 源码；\n\n```bash\ngit clone https://github.com/vuejs/vue-next.git\n```\n\n2. 安装依赖：\n\n```bash\nyarn install\n```\n\n3. 构建 Reactivity 代码：\n\n```bash\nyarn build reactivity\n```\n\n4. 复制 reactivity.cjs.js 到你的学习 demo 目录：\n\n上一步构建完的内容，会保存在 `packages/reactivity/dist`目录下，我们只要在自己的学习 demo 中引入该目录的  reactivity.cjs.js  文件即可。\n\n5. 学习 demo 中引入：\n\n```javascript\nconst { reactive, computed, effect } = require(\"./reactivity.cjs.js\");\n```\n\n### 2. Vue3 Reactivity 文件目录\n\n在源码的 `packages/reactivity/src`目录下，有以下几个主要文件：\n\n1. effect.ts：用来定义 `effect` / `track` / `trigger` ；\n1. baseHandlers.ts：定义 Proxy 处理器（ get 和 set）；\n1. reactive.ts：定义 `reactive` 方法并创建 ES6 Proxy；\n1. ref.ts：定义 reactive 的 ref 使用的对象访问器；\n1. computed.ts：定义计算属性的方法；\n\n![image.png](https://static.ecool.fun//article/53093dcc-fa06-464a-bb7c-72242bd868b0.jpeg)\n（图片来源：Vue Mastery）\n\n\n",
    "pivot": "",
    "vipLimit": 0,
    "level": 4,
    "appId": 7,
    "createAt": "2022-04-10T02:06:40.000Z",
    "updateAt": "2024-08-10T17:06:29.000Z",
    "isCollected": false,
    "currentIndex": 633,
    "filterTotalNum": 1487,
    "prev": "77ad8b60-34a2-4f8c-8fcf-c86db1a57e3b",
    "next": "18d460f5-630d-49f0-8a7b-ec7eefd95089"
  },
  "post": {
    "exerciseKey": "ea676360-c8f5-4ce4-bc66-5c3e4f7eddb6",
    "category": "QA",
    "title": "说说 vue3 中的响应式设计原理",
    "level": 4,
    "createAt": "2022-04-10T02:06:40+00:00",
    "updateAt": "2024-08-10T17:06:29+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 97
  }
}