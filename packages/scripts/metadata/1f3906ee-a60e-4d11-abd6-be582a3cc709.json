{
  "data": {
    "id": 1668,
    "exerciseKey": "1f3906ee-a60e-4d11-abd6-be582a3cc709",
    "category": "QA",
    "renderType": "md",
    "title": "如何理解 HTTP 代理？",
    "desc": null,
    "options": null,
    "explanation": "我们知道在 HTTP 是基于`请求-响应`模型的协议，一般由客户端发请求，服务器来进行响应。\n\n当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有`双重身份`。\n\n那代理服务器到底是用来做什么的呢？\n\n### 功能\n\n* `负载均衡`。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括`随机算法`、`轮询`、`一致性hash`、`LRU``(最近最少使用)`等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。\n* `保障安全`。利用`心跳`机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。\n* `缓存代理`。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。\n\n### 相关头部字段\n\n#### Via\n\n代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？\n\n通过`Via`字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:\n\n```\n客户端 -> 代理1 -> 代理2 -> 源服务器\n```\n\n在源服务器收到请求后，会在`请求头`拿到这个字段:\n\n```\nVia: proxy_server1, proxy_server2\n```\n\n而源服务器响应时，最终在客户端会拿到这样的`响应头`:\n\n```\nVia: proxy_server2, proxy_server1\n```\n\n可以看到，`Via`中代理的顺序即为在 HTTP 传输中报文传达的顺序。\n\n#### X-Forwarded-For\n\n字面意思就是`为谁转发`, 它记录的是`请求方`的`IP`地址(注意，和`Via`区分开，`X-Forwarded-For`记录的是请求方这一个IP)。\n\n#### X-Real-IP\n\n是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。\n\n相应的，还有`X-Forwarded-Host`和`X-Forwarded-Proto`，分别记录`客户端`(注意哦，不包括代理)的`域名`和`协议名`。\n\n### X-Forwarded-For产生的问题\n\n前面可以看到，`X-Forwarded-For`这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从`客户端`到`代理1`，这个字段是客户端的 IP，从`代理1`到`代理2`，这个字段就变为了代理1的 IP。\n\n但是这会产生两个问题:\n\n* 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。\n\n* 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。\n\n由此产生了`代理协议`，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:\n\n```\n// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口\nPROXY TCP4 1 2 1111 2222\nGET / HTTP/1\n...\n```\n\n这样就可以解决`X-Forwarded-For`带来的问题了。",
    "pivot": "",
    "vipLimit": 0,
    "level": 2.5,
    "appId": 7,
    "createAt": "2022-02-06T13:34:33.000Z",
    "updateAt": "2024-08-10T17:06:09.000Z",
    "isCollected": false,
    "currentIndex": 701,
    "filterTotalNum": 1487,
    "prev": "4a9fb879-6110-4b46-9c4a-abc068a27a09",
    "next": "596630fb-95e6-43c4-a1cc-48683233ae76"
  },
  "post": {
    "exerciseKey": "1f3906ee-a60e-4d11-abd6-be582a3cc709",
    "category": "QA",
    "title": "如何理解 HTTP 代理？",
    "level": 2.5,
    "createAt": "2022-02-06T13:34:33+00:00",
    "updateAt": "2024-08-10T17:06:09+00:00"
  },
  "tag": {
    "id": 16,
    "tagName": "计算机网络",
    "type": "1",
    "exerciseCount": 95
  }
}