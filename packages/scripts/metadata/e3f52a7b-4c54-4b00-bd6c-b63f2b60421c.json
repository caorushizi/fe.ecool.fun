{
  "data": {
    "id": 207,
    "exerciseKey": "e3f52a7b-4c54-4b00-bd6c-b63f2b60421c",
    "category": "QA",
    "renderType": "md",
    "title": "正则表达式是什么，有哪些应用场景？",
    "desc": null,
    "options": null,
    "explanation": "## 一、是什么\n\n正则表达式是一种用来匹配字符串的强有力的武器\n\n它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的\n\n在 `JavaScript`中，正则表达式也是对象，构建正则表达式有两种方式：\n\n1. 字面量创建，其由包含在斜杠之间的模式组成\n\n```js\nconst re = /\\d+/g;\n```\n\n2. 调用`RegExp`对象的构造函数\n\n```js\nconst re = new RegExp(\"\\\\d+\",\"g\");\n\nconst rul = \"\\\\d+\"\nconst re1 = new RegExp(rul,\"g\");\n```\n\n使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符`\\`需要使用`\\\\`进行转义\n\n\n\n## 二、匹配规则\n\n常见的校验规则如下：\n\n| 规则        | 描述                                                  |\n| ----------- | ----------------------------------------------------- |\n| \\           | 转义                                                  |\n| ^           | 匹配输入的开始                                        |\n| $           | 匹配输入的结束                                        |\n| *           | 匹配前一个表达式 0 次或多次                           |\n| +           | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`        |\n| ?           | 匹配前面一个表达式 0 次或者 1 次。等价于`{0,1}`       |\n| .           | 默认匹配除换行符之外的任何单个字符                    |\n| x(?=y)      | 匹配'x'仅仅当'x'后面跟着'y'。这种叫做先行断言         |\n| (?<=y)x     | 匹配'x'仅当'x'前面是'y'.这种叫做后行断言              |\n| x(?!y)      | 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找 |\n| (?<!*y*)*x* | 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找   |\n| x\\|y        | 匹配‘x’或者‘y’                                        |\n| {n}         | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次     |\n| {n,}        | n是一个正整数，匹配前一个字符至少出现了n次            |\n| {n,m}       | n 和 m 都是整数。匹配前面的字符至少n次，最多m次       |\n| [xyz\\]      | 一个字符集合。匹配方括号中的任意字符                  |\n| [^xyz\\]     | 匹配任何没有包含在方括号中的字符                      |\n| \\b          | 匹配一个词的边界，例如在字母和空格之间                |\n| \\B          | 匹配一个非单词边界                                    |\n| \\d          | 匹配一个数字                                          |\n| \\D          | 匹配一个非数字字符                                    |\n| \\f          | 匹配一个换页符                                        |\n| \\n          | 匹配一个换行符                                        |\n| \\r          | 匹配一个回车符                                        |\n| \\s          | 匹配一个空白字符，包括空格、制表符、换页符和换行符    |\n| \\S          | 匹配一个非空白字符                                    |\n| \\w          | 匹配一个单字字符（字母、数字或者下划线）              |\n| \\W          | 匹配一个非单字字符                                    |\n\n### 正则表达式标记\n\n| 标志 | 描述                                                      |\n| :--- | :-------------------------------------------------------- |\n| `g`  | 全局搜索。                                                |\n| `i`  | 不区分大小写搜索。                                        |\n| `m`  | 多行搜索。                                                |\n| `s`  | 允许 `.` 匹配换行符。                                     |\n| `u`  | 使用`unicode`码的模式进行匹配。                           |\n| `y`  | 执行“粘性(`sticky`)”搜索,匹配从目标字符串的当前位置开始。 |\n\n使用方法如下：\n\n```js\nvar re = /pattern/flags;\nvar re = new RegExp(\"pattern\", \"flags\");\n```\n\n在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性：\n\n### 贪婪模式\n\n在了解贪婪模式前，首先举个例子：\n\n```js\nconst reg = /ab{1,3}c/\n```\n\n在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试`bbb`，然后再看整个正则是否能匹配。不能匹配时，吐出一个`b`，即在`bb`的基础上，再继续尝试，以此重复\n\n如果多个贪婪量词挨着，则深度优先搜索\n\n```js\nconst string = \"12345\";\nconst regx = /(\\d{1,3})(\\d{1,3})/;\nconsole.log( string.match(reg) );\n// => [\"12345\", \"123\", \"45\", index: 0, input: \"12345\"]\n```\n\n其中，前面的`\\d{1,3}`匹配的是\"123\"，后面的`\\d{1,3}`匹配的是\"45\"\n\n### 懒惰模式\n\n惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配\n\n```js\nvar string = \"12345\";\nvar regex = /(\\d{1,3}?)(\\d{1,3})/;\nconsole.log( string.match(regex) );\n// => [\"1234\", \"1\", \"234\", index: 0, input: \"12345\"]\n```\n\n其中`\\d{1,3}?`只匹配到一个字符\"1\"，而后面的`\\d{1,3}`匹配了\"234\"\n\n### 分组\n\n分组主要是用过`()`进行实现，比如`beyond{3}`，是匹配`d`字母3次。而`(beyond){3}`是匹配`beyond`三次\n\n在`()`内使用`|`达到或的效果，如`(abc | xxx)`可以匹配`abc`或者`xxx`\n\n反向引用，巧用`$`分组捕获\n\n```js\nlet str = \"John Smith\";\n\n// 交换名字和姓氏\nconsole.log(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John\n```\n\n\n\n\n\n## 三、匹配方法\n\n正则表达式常被用于某些方法，我们可以分成两类：\n\n- 字符串（str）方法：`match`、`matchAll`、`search`、`replace`、`split`\n- 正则对象下（regexp）的方法：`test`、`exec`\n\n| 方法     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| exec     | 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 |\n| test     | 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 |\n| match    | 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 |\n| matchAll | 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 |\n| search   | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 |\n| replace  | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 |\n| split    | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 `String` 方法。 |\n\n\n\n### str.match(regexp)\n\n`str.match(regexp)` 方法在字符串 `str` 中找到匹配 `regexp` 的字符\n\n如果 `regexp` 不带有 `g` 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 `index`（匹配项的位置）、`input`（输入字符串，等于 `str`）\n\n```js\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/Java(Script)/);\n\nconsole.log( result[0] );     // JavaScript（完全匹配）\nconsole.log( result[1] );     // Script（第一个分组）\nconsole.log( result.length ); // 2\n\n// 其他信息：\nconsole.log( result.index );  // 7（匹配位置）\nconsole.log( result.input );  // I love JavaScript（源字符串）\n```\n\n如果 `regexp` 带有 `g` 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息\n\n```js\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/Java(Script)/g);\n\nconsole.log( result[0] ); // JavaScript\nconsole.log( result.length ); // 1\n```\n\n如果没有匹配项，则无论是否带有标记 `g` ，都将返回 `null`\n\n```js\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/HTML/);\n\nconsole.log(result); // null\n```\n\n\n\n### str.matchAll(regexp)\n\n返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器\n\n```js\nconst regexp = /t(e)(st(\\d?))/g;\nconst str = 'test1test2';\n\nconst array = [...str.matchAll(regexp)];\n\nconsole.log(array[0]);\n// expected output: Array [\"test1\", \"e\", \"st1\", \"1\"]\n\nconsole.log(array[1]);\n// expected output: Array [\"test2\", \"e\", \"st2\", \"2\"]\n```\n\n\n\n\n\n\n\n### str.search(regexp)\n\n返回第一个匹配项的位置，如果未找到，则返回 `-1`\n\n```js\nlet str = \"A drop of ink may make a million think\";\n\nconsole.log( str.search( /ink/i ) ); // 10（第一个匹配位置）\n```\n\n这里需要注意的是，`search` 仅查找第一个匹配项\n\n\n\n\n\n\n\n## str.replace(regexp)\n\n替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配`g`的时候，只替换第一个匹配成功的字符串片段\n\n```js\nconst reg1=/javascript/i;\nconst reg2=/javascript/ig;\nconsole.log('hello Javascript Javascript Javascript'.replace(reg1,'js'));\n//hello js Javascript Javascript\nconsole.log('hello Javascript Javascript Javascript'.replace(reg2,'js'));\n//hello js js js\n```\n\n\n\n### str.split(regexp)\n\n使用正则表达式（或子字符串）作为分隔符来分割字符串\n\n```js\nconsole.log('12, 34, 56'.split(/,\\s*/)) // 数组 ['12', '34', '56']\n```\n\n\n\n### regexp.exec(str)\n\n`regexp.exec(str)` 方法返回字符串 `str` 中的 `regexp` 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的\n\n根据正则表达式是否带有标志 `g`，它的行为有所不同\n\n如果没有 `g`，那么 `regexp.exec(str)` 返回的第一个匹配与 `str.match(regexp)` 完全相同\n\n如果有标记 `g`，调用 `regexp.exec(str)` 会返回第一个匹配项，并将紧随其后的位置保存在属性`regexp.lastIndex` 中。 下一次同样的调用会从位置 `regexp.lastIndex` 开始搜索，返回下一个匹配项，并将其后的位置保存在 `regexp.lastIndex` 中\n\n```js\nlet str = 'More about JavaScript at https://javascript.info';\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  console.log( `Found ${result[0]} at position ${result.index}` );\n  // Found JavaScript at position 11\n  // Found javascript at position 33\n}\n```\n\n\n\n### regexp.test(str)\n\n查找匹配项，然后返回 `true/false` 表示是否存在\n\n```js\nlet str = \"I love JavaScript\";\n\n// 这两个测试相同\nconsole.log( /love/i.test(str) ); // true\n```\n\n\n\n\n\n## 四、应用场景\n\n通过上面的学习，我们对正则表达式有了一定的了解\n\n下面再来看看正则表达式一些案例场景：\n\n验证QQ合法性（5~15位、全是数字、不以0开头）：\n\n```js\nconst reg = /^[1-9][0-9]{4,14}$/\nconst isvalid = patrn.exec(s)\n```\n\n校验用户账号合法性（只能输入5-20个以字母开头、可带数字、“_”、“.”的字串）：\n\n```js\nvar patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;\nconst isvalid = patrn.exec(s)\n```\n\n将`url`参数解析为对象\n\n```js\nconst protocol = '(?<protocol>https?:)';\nconst host = '(?<host>(?<hostname>[^/#?:]+)(?::(?<port>\\\\d+))?)';\nconst path = '(?<pathname>(?:\\\\/[^/#?]+)*\\\\/?)';\nconst search = '(?<search>(?:\\\\?[^#]*)?)';\nconst hash = '(?<hash>(?:#.*)?)';\nconst reg = new RegExp(`^${protocol}\\/\\/${host}${path}${search}${hash}$`);\nfunction execURL(url){\n    const result = reg.exec(url);\n    if(result){\n        result.groups.port = result.groups.port || '';\n        return result.groups;\n    }\n    return {\n        protocol:'',host:'',hostname:'',port:'',\n        pathname:'',search:'',hash:'',\n    };\n}\n\nconsole.log(execURL('https://localhost:8080/?a=b#xxxx'));\nprotocol: \"https:\"\nhost: \"localhost:8080\"\nhostname: \"localhost\"\nport: \"8080\"\npathname: \"/\"\nsearch: \"?a=b\"\nhash: \"#xxxx\"\n```\n\n再将上面的`search`和`hash`进行解析\n\n```js\nfunction execUrlParams(str){\n    str = str.replace(/^[#?&]/,'');\n    const result = {};\n    if(!str){ //如果正则可能配到空字符串，极有可能造成死循环，判断很重要\n        return result; \n    }\n    const reg = /(?:^|&)([^&=]*)=?([^&]*?)(?=&|$)/y\n    let exec = reg.exec(str);\n    while(exec){\n        result[exec[1]] = exec[2];\n        exec = reg.exec(str);\n    }\n    return result;\n}\nconsole.log(execUrlParams('#'));// {}\nconsole.log(execUrlParams('##'));//{'#':''}\nconsole.log(execUrlParams('?q=3606&src=srp')); //{q: \"3606\", src: \"srp\"}\nconsole.log(execUrlParams('test=a=b=c&&==&a='));//{test: \"a=b=c\", \"\": \"=\", a: \"\"}\n```\n",
    "level": 2,
    "status": 2,
    "appId": 7,
    "createAt": "2021-07-03T13:56:15.000Z",
    "updateAt": "2024-01-24T17:37:37.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 157,
    "prev": "b1b488cb-0f79-4d12-bdab-4c070e0da072",
    "next": "bbcedbfa-a74f-411f-a309-01f7e590ee50"
  },
  "post": {
    "exerciseKey": "e3f52a7b-4c54-4b00-bd6c-b63f2b60421c",
    "category": "QA",
    "title": "正则表达式是什么，有哪些应用场景？",
    "level": 2,
    "updateAt": "2024-01-24T17:37:37+00:00"
  },
  "tag": {
    "id": 10,
    "tagName": "JavaScript",
    "type": "1",
    "exerciseCount": 322
  }
}
