---
title: 将静态资源缓存在本地的方式有哪些？
pubDatetime: 2024-09-09T14:26:34.000Z
author: caorushizi
tags:
  - 性能优化
postSlug: 1f734f01-90ea-4e70-8968-5aed96d8662e
description: >-
  关键词：静态资源缓存本地 浏览器可以使用以下几种方式将前端静态资源缓存在本地：
  HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、max-age（设置资源缓存的最大时间）等。浏览器根据这些缓存策略来决定是否将资源缓存在本地。
  ETag/If
difficulty: 1.5
questionNumber: 2334
source: https://fe.ecool.fun/topic/1f734f01-90ea-4e70-8968-5aed96d8662e
---

**关键词**：静态资源缓存本地

**浏览器可以使用以下几种方式将前端静态资源缓存在本地**：

1. HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、max-age（设置资源缓存的最大时间）等。浏览器根据这些缓存策略来决定是否将资源缓存在本地。

2. ETag/If-None-Match：服务器可以通过在响应头中添加ETag字段，用于标识资源的版本号。当浏览器再次请求资源时，会将上次请求返回的ETag值通过If-None-Match字段发送给服务器，由服务器判断资源是否发生了变化。如果资源未发生变化，服务器会返回304 Not Modified状态码，浏览器则直接使用本地缓存的资源。

3. Last-Modified/If-Modified-Since：服务器可以通过在响应头中添加Last-Modified字段，用于标识资源的最后修改时间。浏览器再次请求资源时，会将上次请求返回的Last-Modified值通过If-Modified-Since字段发送给服务器。服务器根据资源的最后修改时间判断资源是否发生了变化，如果未发生变化，则返回304 Not Modified状态码，浏览器使用本地缓存的资源。

4. Service Worker缓存：使用Service Worker可以将前端资源缓存在浏览器的Service Worker缓存中。Service Worker是运行在浏览器后台的脚本，它可以拦截和处理网络请求，因此可以将前端资源缓存起来，并在离线状态下提供缓存的资源。

5. LocalStorage或IndexedDB：对于一些小的静态资源，可以将其存储在浏览器的LocalStorage或IndexedDB中。这些存储方式是浏览器提供的本地存储机制，可以将数据以键值对的形式存储在浏览器中，从而实现缓存的效果。

**如何将静态资源缓存在 LocalStorage或IndexedDB**

以下是一个使用LocalStorage将静态资源缓存的示例代码：

```javascript
// 定义一个数组，包含需要缓存的静态资源的URL
var resources = [
  "https://example.com/css/style.css",
  "https://example.com/js/main.js",
  "https://example.com/images/logo.png",
];

// 遍历资源数组，将资源请求并存储在LocalStorage中
resources.forEach(function (url) {
  // 发起资源请求
  fetch(url)
    .then(function (response) {
      // 检查请求是否成功
      if (!response.ok) {
        throw new Error("Request failed: " + response.status);
      }
      // 将响应数据存储在LocalStorage中
      return response.text();
    })
    .then(function (data) {
      // 将资源数据存储在LocalStorage中，以URL作为键名
      localStorage.setItem(url, data);
      console.log("Resource cached: " + url);
    })
    .catch(function (error) {
      console.error(error);
    });
});
```

以下是一个使用IndexedDB将静态资源缓存的示例代码：

```javascript
// 打开或创建一个IndexedDB数据库
var request = indexedDB.open("myDatabase", 1);

// 创建或更新数据库的对象存储空间
request.onupgradeneeded = function (event) {
  var db = event.target.result;
  var objectStore = db.createObjectStore("resources", { keyPath: "url" });
  objectStore.createIndex("url", "url", { unique: true });
};

// 成功打开数据库后，将资源请求并存储在IndexedDB中
request.onsuccess = function (event) {
  var db = event.target.result;
  var transaction = db.transaction("resources", "readwrite");
  var objectStore = transaction.objectStore("resources");

  resources.forEach(function (url) {
    // 发起资源请求
    fetch(url)
      .then(function (response) {
        // 检查请求是否成功
        if (!response.ok) {
          throw new Error("Request failed: " + response.status);
        }
        // 将响应数据存储在IndexedDB中
        return response.blob();
      })
      .then(function (data) {
        // 创建一个资源对象，以URL作为键名
        var resource = { url: url, data: data };
        // 将资源对象存储在IndexedDB中
        objectStore.put(resource);
        console.log("Resource cached: " + url);
      })
      .catch(function (error) {
        console.error(error);
      });
  });

  // 完成事务
  transaction.oncomplete = function () {
    console.log("All resources cached in IndexedDB.");
  };

  transaction.onerror = function (event) {
    console.error("Transaction error:", event.target.error);
  };
};
```

以上代码仅为示例，实际应用中需要根据具体的需求进行相应的优化和错误处理。
