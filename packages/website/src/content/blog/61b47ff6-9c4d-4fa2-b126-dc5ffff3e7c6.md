---
title: 简述 html 页面渲染过程
pubDatetime: 2021-07-04T16:01:56.000Z
author: caorushizi
tags:
  - HTML
postSlug: 61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6
description: >-
  整个渲染过程其实就是将URL对应的各种资源，通过浏览器渲染引擎的解析，输出可视化的图像。 基本概念
  HTML解释器：解释HTML语言的解释器，本质是将HTML文本解释成DOM树（文档对象模型）。
  CSS解释器：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。
  布局：将DOM和css样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这
difficulty: 3
questionNumber: 273
source: https://fe.ecool.fun/topic/61b47ff6-9c4d-4fa2-b126-dc5ffff3e7c6
---

整个渲染过程其实就是将 URL 对应的各种资源，通过浏览器渲染引擎的解析，输出可视化的图像。

## 基本概念

- HTML 解释器：解释 HTML 语言的解释器，本质是将 HTML 文本解释成 DOM 树（文档对象模型）。
- CSS 解释器：解释样式表的解释器，其作用是将 DOM 中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。
- 布局：将 DOM 和 css 样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型即渲染树。
- JavaScript 引擎：JavaScript 可以修改网页的内容，也能修改 CSS 的信息，JavaScript 引擎解释 JavaScript 代码并把代码的逻辑和对 DOM 和 CSS 的改动信息应用到布局中去，从而改变渲染的结果。

## 基本过程

- 1.解析 HTML 文件，创建 DOM 树

浏览器解析 html 源码，然后创建一个 DOM 树。并行请求 css/image/js 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentElement，对应的是 html 标签。

- 2.解析 CSS,形成 CSS 对象模型

浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的语法它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：

> 浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html 中的 style。

- 3.将 CSS 与 DOM 合并，构建渲染树（renderingtree）

DOM Tree + CSSOM –> 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。

- 4.布局和绘制

一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果 DOM 或者 CSSOM 被修改，以上过程会被重复执行。实际上，CSS 和 JavaScript 往往会多次修改 DOM 或者 CSSOM。

### Repaint(重绘)

重绘是改变不影响元素在网页中的位置的元素样式时，譬如 background-color(背景色)， border-color(边框色)，visibility(可见性)，浏览器会根据元素的新属性重新绘制一次(这就是重绘，或者说重新构造样式)，使元素呈现新的外观。

重绘不会带来重新布局，所以并不一定伴随重排。

### Reflow（重排）

渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。

"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。

但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

## 引申问题：浏览器如何优化渲染？

- 将多次改变样式属性的操作合并成一次操作
- 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
- 由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发 2 次重排。
