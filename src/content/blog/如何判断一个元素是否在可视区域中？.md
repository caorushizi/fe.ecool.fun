---
title: 如何判断一个元素是否在可视区域中？
pubDatetime: 2021-07-03T16:00:00.000Z
author: caorushizi
tags:
  - javascript
postSlug: a271538ed08ac7029ce3f94bad77a2c9
description: >-
  ![](https://static.vue-js.com/d848c790-8a05-11eb-85f6-6fac77c0c9b3.png)预览一、用途----可视区域即我们浏览网页的设备肉眼可见的
difficulty: 2
questionNumber: 312
source: >-
  https://fe.ecool.fun/topic-answer/ccde1c25-c646-4521-bf81-fcb0a3581ce2?orderBy=updateTime&order=desc&tagId=10
---

![](https://static.vue-js.com/d848c790-8a05-11eb-85f6-6fac77c0c9b3.png)

预览

## 一、用途

可视区域即我们浏览网页的设备肉眼可见的区域，如下图

![](https://static.vue-js.com/9c5bbb10-8a56-11eb-85f6-6fac77c0c9b3.png)

预览

在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：

- 图片的懒加载
- 列表的无限滚动
- 计算广告元素的曝光情况
- 可点击链接的预加载

## 二、实现方式

判断一个元素是否在可视区域，我们常用的有三种办法：

- offsetTop、scrollTop
- getBoundingClientRect
- Intersection Observer

### offsetTop、scrollTop

`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：

![](https://static.vue-js.com/b4b63ca0-8a54-11eb-85f6-6fac77c0c9b3.png)

预览

下面再来了解下`clientWidth`、`clientHeight`：

- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`
- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`

这里可以看到`client`元素都不包括外边距

最后，关于`scroll`系列的属性如下：

- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小
- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置
- - 垂直滚动 `scrollTop > 0`
  - 水平滚动 `scrollLeft > 0`
- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置

#### 注意

- 上述属性都是只读的，每次访问都要重新开始

下面再看看如何实现判断：

公式如下：

```typescript
undefined;
```

代码实现：

```typescript
undefined;
```

### getBoundingClientRect

返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性

```typescript
undefined;
```

属性对应的关系图如下所示：

![](https://static.vue-js.com/e34ac5d0-8a05-11eb-85f6-6fac77c0c9b3.png)

预览

当页面发生滚动的时候，`top`与`left`属性值都会随之改变

如果一个元素在视窗之内的话，那么它一定满足下面四个条件：

- top 大于等于 0
- left 大于等于 0
- bottom 小于等于视窗高度
- right 小于等于视窗宽度

实现代码如下：

```typescript
undefined;
```

### Intersection Observer

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比`getBoundingClientRect` 会好很多

使用步骤主要分为两步：创建观察者和传入被观察者

#### 创建观察者

```typescript
undefined;
```

通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行\`

关于`callback`回调函数常用属性如下：

```typescript
undefined;
```

#### 传入被观察者

通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者

```typescript
undefined;
```

### 三、案例分析

实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色

`Html`结构如下：

```typescript
undefined;
```

`css`样式如下：

```typescript
undefined;
```

往`container`插入 1000 个元素

```typescript
undefined;
```

这里，首先使用`getBoundingClientRect` 方法进行判断元素是否在可视区域

```typescript
undefined;
```

然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`

```typescript
undefined;
```

通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费

下面通过`Intersection Observer`的形式同样实现相同的功能

首先创建一个观察者

```typescript
undefined;
```

`getYellow`回调函数实现对背景颜色改变，如下：

```typescript
undefined;
```

最后传入观察者，即`.target`元素

```typescript
undefined;
```

可以看到功能同样完成，并且页面不会出现卡顿的情况
