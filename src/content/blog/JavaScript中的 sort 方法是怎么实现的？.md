---
title: JavaScript中的 sort 方法是怎么实现的？
pubDatetime: 2022-03-20T16:00:00.000Z
author: caorushizi
tags:
  - javascript
postSlug: e3dd46ac3661c9a8fe00d74bdd1f50a5
description: >-
  本答案将介绍js中常用的几种排序算法，并结合v8中相关源码分析sort实现的策略常见排序算法------首先温习下排序算法需要关注的两大要素###时间复杂度描述该算法的运行时间，通常用`大O`描述，附
difficulty: 3.5
questionNumber: 129
source: >-
  https://fe.ecool.fun/topic-answer/807ac3c6-6e75-4cbf-9a5d-3084f860ea11?orderBy=updateTime&order=desc&tagId=10
---

本答案将介绍 js 中常用的几种排序算法，并结合 v8 中相关源码分析 sort 实现的策略

## 常见排序算法

首先温习下排序算法需要关注的两大要素

### 时间复杂度

描述该算法的运行时间，通常用`大O`描述，附上一张时间复杂度曲线图帮助理解

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/911d36f5d6e345aba9cd29ccd7e8297b~tplv-k3u1fbpfcp-watermark.image)

### 空间复杂度

度量一个算法在运行过程中占用存储空间大小

### 常见排序

常见的[十大经典排序算法](https://gitee.com/webfrontup/javascript-algorithms)就不在这科普了，根据特性可将它们从不同角度进行分类

- 是否基于比较：比较类排序和非比较类排序
- 是否稳定：稳定类排序和不稳定类排序

通常我们`从是否基于排序`的视角进行分类

- 比较类排序

  通过比较来决定元素间的相对次序，其时间复杂度不能突破 `O(nlogn)`，因此也称为`非线性时间比较`类排序。

- 非比较类排序

  不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以`线性时间运行`，因此也称为`线性时间非比较`类排序。

具体分类枚举可以结合下图理解

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e8c91cb7184b9fbbee18013f20bc59~tplv-k3u1fbpfcp-watermark.image)

接下来我们写下几个常见的经典排序

#### 快速排序

快速排序主要使用`递归分支`的思想，通过一趟排序，将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序。

```typescript
undefined;
```

#### 堆排序

堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵`完全二叉树`，可以用数组实现。

根节点最大的堆叫作`大根堆`，根节点最小的堆叫作`小根堆`，你可以根据从大到小排序或者从小到大来排序，分别建立对应的堆就可以。请看下面的代码。

```typescript
undefined;
```

#### 归并排序

归并排序是建立在`归并`操作上的一种有效的排序算法，该算法是采用`分治法`的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为`二路归并`。

```typescript
undefined;
```

最后附上一张各排序算法统计对照表:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e017396d617e4507a6700c11d1249a5b~tplv-k3u1fbpfcp-watermark.image)

## js 中的 sort 方法

### sort 方法基本使用

> arr.sort(\[compareFunction\])

如果不传入 compareFunction，则元素按照转换为字符串的各个字符的 `Unicode` 位点进行排序，有些同学经常在整数排序上犯错误，多半是因为遗漏了这一规则

```typescript
undefined;
```

如果指明了 compareFunction 参数 ，那么数组会按照调用该函数的`返回值排序`，即 a 和 b 是两个将要被比较的元素：

- compareFunction（a, b）< 0，a 会被排列到 b 之前
- compareFunction（a, b）=== 0，a 和 b 的相对位置不变
- compareFunction（a, b）> 0，b 会被排列到 a 之前

### sort 源码分析

查阅 [v8 源码 sort 部分](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L709) 我们可以发现，对于需要排序的元素个数 n，具体排序策略有几下中情形：

- 当 n<=10 时，采用`插入排序`；
- 当 n>10 时，采用`三路快速排序`；
- 10<n <=1000，采用中位数作为哨兵元素；
- n>1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。

乍一看结论你可能会纠结两个问题

##### 1、为何元素较少的时候要用快排

其实仔细分析一下不难究其原因。对于插排和快排，理论上的平均时间复杂度分别为 O(n^2)和 O(nlogn)，其中插排在最好情况下的时间复杂度是 O(n)。对比不难得出结论，当 n 足够小的时候，快排优势变小。事实上插排经优化后对于小数据集的排序性能可以超过快排。

##### 2、为何要选择哨兵元素

因为快速排序的性能瓶颈在于`递归的深度`，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。如果这么排下去，递归的层数就达到了`n`, 而每一层的复杂度是 `O(n)`，因此快排这时候会`退化`成`O(n^2)`级别。

这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少

最后我们看下源码中的 sort 的基本结构

```typescript
undefined;
```
