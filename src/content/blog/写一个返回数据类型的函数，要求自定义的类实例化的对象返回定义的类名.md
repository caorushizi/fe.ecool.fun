---
title: 写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名
pubDatetime: 2022-06-24T16:00:00.000Z
author: caorushizi
tags:
  - 编程题
postSlug: 0b28ecab3292359c32929ca6fa52e2e0
description: >-
  Javascript是一门动态类型的语言，一个变量从声明到最后使用，可能经过了很多个函数，而数据类型也会发生改变，那么，对一个变量的数据类型判断就显得尤为重要。获取数据类型======我们先来看下怎么
difficulty: 2
questionNumber: 36
source: >-
  https://fe.ecool.fun/topic-answer/c25081e4-6374-4e78-abec-1a31999e528e?orderBy=updateTime&order=desc&tagId=26
---

Javascript 是一门动态类型的语言，一个变量从声明到最后使用，可能经过了很多个函数，而数据类型也会发生改变，那么，对一个变量的数据类型判断就显得尤为重要。

# 获取数据类型

我们先来看下怎么获取一个数据的类型。

## typeof 是否能正确判断类型？

由于由于历史原因，在判断原始类型时，`typeof null`会等于`object`。而且对于对象（Object）、数组（Array）来说，都会转换成`object`。例子如下：

```typescript
undefined;
```

所以我们可以发现，typeof 可以判断基本数据类型，但是难以判断除了函数以外的复杂数据类型。于是我们可以使用第二种方法，通常用来判断复杂数据类型，也可以用来判断基本数据类型。

对于返回值为`object`，有三种情况：

- 值为 null
- 值为 object
- 值为 array

对于 null，我们可以直接用===来进行判断，那么数组和对象呢？不急，我们接着说。

## instanceof 是否能正确判断类型？

`instanceof`是通过原型链来判断的，但是对于对象来说，`Array`也会被转换成`Object`，而且也不能区分基本类型`string`和`boolean`。可以左边放你要判断的内容，右边放类型来进行 JS 类型判断，只能用来判断复杂数据类型,因为 instanceof 是用于检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。例如：

```typescript
undefined;
```

单独使用`instanceof`好像也是不行的，但是我们对于 typeof 已经得出结论，不能区分数组和对象，那么，我们结合下`instanceof`，来写一个完整的判断逻辑

```typescript
undefined;
```

## constructor

constructor 判断方法跟 instanceof 相似,但是 constructor 检测 Object 与 instanceof 不一样,constructor 还可以处理基本数据类型的检测,不仅仅是对象类型。

注意:

1.  null 和 undefined 没有 constructor;
2.  判断数字时使用(),比如 (123).constructor,如果写成 123.constructor 会报错
3.  constructor 在类继承时会出错,因为 Object 被覆盖掉了,检测结果就不对了

```typescript
undefined;
```

## Array.isArray()

Array.isArray() 用于确定传递的值是否是一个 Array。如果对象是 Array ，则返回 true，否则为 false。

```typescript
undefined;
```

## 正则判断

我们可以把对象和数组转成一个字符串，这样就可以做格式判断，从而得到最终的类型。

```typescript
undefined;
```

## Object.prototype.toString.call()

上面我们通过`typeof`和`instanceof`实现了一版类型判断，那么是否有其他渠道，使我们的代码更加简洁吗？答案就是使用`Object.prototype.toString.call()`。

每个对象都有一个`toString()`方法，当要将对象表示为文本值或以预期字符串的方式引用对象时，会自动调用该方法。默认情况下，从`Object`派生的每个对象都会继承`toString()`方法。如果此方法未在自定义对象中被覆盖，则`toString()`返回`[Object type]`，其中`type`是对象类型。所以就有以下例子：

```typescript
undefined;
```

所以综合上述知识点，我们可以封装出以下通用类型判断方法：

```typescript
undefined;
```

# 获取实例化对象的类名

题目中的第二个要求，是对于自定义的类实例化的对象，需要返回定义的类名。

这个也比较简单，我们对于上述获取的 Object 类型的数据，直接使用 `xx.constructor.name` 即可获取到这个数据对应的类名。

# 最终实现

```typescript
undefined;
```
