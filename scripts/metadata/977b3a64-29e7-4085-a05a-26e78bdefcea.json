{
  "data": {
    "id": 1637,
    "exerciseKey": "977b3a64-29e7-4085-a05a-26e78bdefcea",
    "category": "QA",
    "renderType": "md",
    "title": "如果使用Vue3.0实现一个 Modal，你会怎么进行设计？",
    "desc": null,
    "options": null,
    "explanation": "## 一、组件设计\n\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式\n\n现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同\n\n这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可\n\n这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 `Bug `和更少的程序体积\n\n\n\n## 二、需求分析\n\n实现一个`Modal`组件，首先确定需要完成的内容：\n\n- 遮罩层\n\n- 标题内容\n- 主体内容\n- 确定和取消按钮\n\n主体内容需要灵活，所以可以是字符串，也可以是一段 `html` 代码\n\n特点是它们在当前`vue`实例之外独立存在，通常挂载于`body`之上\n\n除了通过引入`import`的形式，我们还可通过`API`的形式进行组件的调用\n\n还可以包括配置全局样式、国际化、与`typeScript`结合\n\n\n\n## 三、实现流程\n\n首先看看大致流程：\n\n- 目录结构\n- 组件内容\n- 实现 API 形式\n- 事件处理\n\n- 其他完善\n\n\n\n\n\n### 目录结构\n\n`Modal`组件相关的目录结构\n\n```\n├── plugins\n│   └── modal\n│       ├── Content.tsx // 维护 Modal 的内容，用于 h 函数和 jsx 语法\n│       ├── Modal.vue // 基础组件\n│       ├── config.ts // 全局默认配置\n│       ├── index.ts // 入口\n│       ├── locale // 国际化相关\n│       │   ├── index.ts\n│       │   └── lang\n│       │       ├── en-US.ts\n│       │       ├── zh-CN.ts\n│       │       └── zh-TW.ts\n│       └── modal.type.ts // ts类型声明相关\n```\n\n因为 Modal 会被 `app.use(Modal)` 调用作为一个插件，所以都放在`plugins`目录下\n\n\n\n\n\n### 组件内容\n\n首先实现`modal.vue`的主体显示内容大致如下\n\n```html\n<Teleport to=\"body\" :disabled=\"!isTeleport\">\n    <div v-if=\"modelValue\" class=\"modal\">\n        <div\n             class=\"mask\"\n             :style=\"style\"\n             @click=\"maskClose && !loading && handleCancel()\"\n             ></div>\n        <div class=\"modal__main\">\n            <div class=\"modal__title line line--b\">\n                <span>{{ title || t(\"r.title\") }}</span>\n                <span\n                      v-if=\"close\"\n                      :title=\"t('r.close')\"\n                      class=\"close\"\n                      @click=\"!loading && handleCancel()\"\n                      >✕</span\n                    >\n            </div>\n            <div class=\"modal__content\">\n                <Content v-if=\"typeof content === 'function'\" :render=\"content\" />\n                <slot v-else>\n                    {{ content }}\n                </slot>\n            </div>\n            <div class=\"modal__btns line line--t\">\n                <button :disabled=\"loading\" @click=\"handleConfirm\">\n                    <span class=\"loading\" v-if=\"loading\"> ❍ </span>{{ t(\"r.confirm\") }}\n                </button>\n                <button @click=\"!loading && handleCancel()\">\n                    {{ t(\"r.cancel\") }}\n                </button>\n            </div>\n        </div>\n    </div>\n</Teleport>\n```\n\n最外层上通过Vue3 `Teleport` 内置组件进行包裹，其相当于传送门，将里面的内容传送至`body`之上\n\n并且从`DOM`结构上来看，把`modal`该有的内容（遮罩层、标题、内容、底部按钮）都实现了\n\n关于主体内容\n\n```html\n<div class=\"modal__content\">\n    <Content v-if=\"typeof content==='function'\"\n             :render=\"content\" />\n    <slot v-else>\n        {{content}}\n    </slot>\n</div>\n```\n\n可以看到根据传入`content`的类型不同，对应显示不同得到内容\n\n最常见的则是通过调用字符串和默认插槽的形式\n\n```html\n// 默认插槽\n<Modal v-model=\"show\"\n       title=\"演示 slot\">\n    <div>hello world~</div>\n</Modal>\n\n// 字符串\n<Modal v-model=\"show\"\n       title=\"演示 content\"\n       content=\"hello world~\" />\n```\n\n通过 API 形式调用`Modal`组件的时候，`content`可以使用下面两种\n\n- h 函数\n\n```js\n$modal.show({\n  title: '演示 h 函数',\n  content(h) {\n    return h(\n      'div',\n      {\n        style: 'color:red;',\n        onClick: ($event: Event) => console.log('clicked', $event.target)\n      },\n      'hello world ~'\n    );\n  }\n});\n```\n\n- JSX\n\n```js\n$modal.show({\n  title: '演示 jsx 语法',\n  content() {\n    return (\n      <div\n        onClick={($event: Event) => console.log('clicked', $event.target)}\n      >\n        hello world ~\n      </div>\n    );\n  }\n});\n```\n\n\n\n\n\n### 实现 API 形式\n\n那么组件如何实现`API`形式调用`Modal`组件呢？\n\n在`Vue2`中，我们可以借助`Vue`实例以及`Vue.extend`的方式获得组件实例，然后挂载到`body`上\n\n```js\nimport Modal from './Modal.vue';\nconst ComponentClass = Vue.extend(Modal);\nconst instance = new ComponentClass({ el: document.createElement(\"div\") });\ndocument.body.appendChild(instance.$el);\n```\n\n虽然`Vue3`移除了`Vue.extend`方法，但可以通过`createVNode`实现\n\n```js\nimport Modal from './Modal.vue';\nconst container = document.createElement('div');\nconst vnode = createVNode(Modal);\nrender(vnode, container);\nconst instance = vnode.component;\ndocument.body.appendChild(container);\n```\n\n在`Vue2`中，可以通过`this`的形式调用全局 API\n\n```js\nexport default {\n    install(vue) {\n       vue.prototype.$create = create\n    }\n}\n```\n\n而在 Vue3 的 `setup` 中已经没有 `this `概念了，需要调用`app.config.globalProperties`挂载到全局\n\n```js\nexport default {\n    install(app) {\n        app.config.globalProperties.$create = create\n    }\n}\n```\n\n\n\n\n\n### 事件处理\n\n下面再看看看`Modal`组件内部是如何处理「确定」「取消」事件的，既然是`Vue3`，当然采用`Compositon API` 形式\n\n```js\n// Modal.vue\nsetup(props, ctx) {\n  let instance = getCurrentInstance(); // 获得当前组件实例\n  onBeforeMount(() => {\n    instance._hub = {\n      'on-cancel': () => {},\n      'on-confirm': () => {}\n    };\n  });\n\n  const handleConfirm = () => {\n    ctx.emit('on-confirm');\n    instance._hub['on-confirm']();\n  };\n  const handleCancel = () => {\n    ctx.emit('on-cancel');\n    ctx.emit('update:modelValue', false);\n    instance._hub['on-cancel']();\n  };\n\n  return {\n    handleConfirm,\n    handleCancel\n  };\n}\n```\n\n在上面代码中，可以看得到除了使用传统`emit`的形式使父组件监听，还可通过`_hub`属性中添加 `on-cancel`，`on-confirm`方法实现在`API`中进行监听\n\n```js\napp.config.globalProperties.$modal = {\n   show({}) {\n     /* 监听 确定、取消 事件 */\n   }\n}\n```\n\n\n\n下面再来目睹下`_hub`是如何实现\n\n```js\n// index.ts\napp.config.globalProperties.$modal = {\n    show({\n        /* 其他选项 */\n        onConfirm,\n        onCancel\n    }) {\n        /* ... */\n\n        const { props, _hub } = instance;\n\n        const _closeModal = () => {\n            props.modelValue = false;\n            container.parentNode!.removeChild(container);\n        };\n        // 往 _hub 新增事件的具体实现\n        Object.assign(_hub, {\n            async 'on-confirm'() {\n            if (onConfirm) {\n                const fn = onConfirm();\n                // 当方法返回为 Promise\n                if (fn && fn.then) {\n                    try {\n                        props.loading = true;\n                        await fn;\n                        props.loading = false;\n                        _closeModal();\n                    } catch (err) {\n                        // 发生错误时，不关闭弹框\n                        console.error(err);\n                        props.loading = false;\n                    }\n                } else {\n                    _closeModal();\n                }\n            } else {\n                _closeModal();\n            }\n        },\n            'on-cancel'() {\n                onCancel && onCancel();\n                _closeModal();\n            }\n    });\n}\n};\n```\n\n\n\n### 其他完善\n\n关于组件实现国际化、与`typsScript`结合，大家可以根据自身情况在此基础上进行更改\n",
    "level": 3.5,
    "status": 2,
    "appId": 7,
    "createAt": "2022-01-16T12:41:15.000Z",
    "updateAt": "2024-01-25T19:30:45.000Z",
    "updateUserId": 11,
    "isCollected": false,
    "currentIndex": 54,
    "prev": "23ad38a6-12b2-4969-8dac-bfcfb00834d4",
    "next": "7a9f621a-416f-4c2b-8d08-8f8e0a113c6a"
  },
  "post": {
    "exerciseKey": "977b3a64-29e7-4085-a05a-26e78bdefcea",
    "category": "QA",
    "title": "如果使用Vue3.0实现一个 Modal，你会怎么进行设计？",
    "level": 3.5,
    "updateAt": "2024-01-25T19:30:45+00:00"
  },
  "tag": {
    "id": 14,
    "tagName": "Vue.js",
    "type": "1",
    "exerciseCount": 68
  }
}